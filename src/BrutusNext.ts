/*
          ____             _               _   _ ________   _________
         |  _ \           | |             | \ | |  ____\ \ / /__   __|
         | |_) |_ __ _   _| |_ _   _ ___  |  \| | |__   \ V /   | |
         |  _ <| '__| | | | __| | | / __| | . ` |  __|   > <    | |
         | |_) | |  | |_| | |_| |_| \__ \ | |\  | |____ / . \   | |
         |____/|_|   \__,_|\__|\__,_|___/ |_| \_|______/_/ \_\  |_|

                        Server program entry point

  To run the server you need to compile it first using ./compile, then
  run it using ./server [options]
    (both 'compile' and 'server' scripts are in BrutusNext directory)

  Options:
    -p, --port ... Port to listen to telnet (default is 4443).
*/

'use strict';

import {Server} from './server/Server';
import {Syslog} from './server/Syslog';
import {Message} from './server/message/Message';
import {AdminLevel} from './server/AdminLevel';

// Include sourcemap support module. It uses .js.map files generated by
// typecript compiler to change stack traces to actually show TypeScript
// stack trace (instead of stack trace in generated JavaScript).
require('source-map-support').install();

let parser = require('commander');

// Include package.json file (located in BrutusNext directory)
// (it contains version number and list of all required modules along with
// their required version)
let packageDotJson = require('../package.json');

// This handler catches exceptions thrown from withing async (promisified)
// functions. A new exception is thrown, which will crash the mud and print
// the original stack trace. Without this, exceptions thrown from withing
// async function would lead to silent crashes.
process.on
(
  'unhandledRejection',
  err =>
  {
    if (err.name === "Script cancelled")
    {
      // Running scripts are cancelled by rejecting the Promise, which
      // throws an exception. It is not an error to be reported though.

      /// This was used for debugging:
      console.log(err.message);
    }
    else
    {
      throw err;
    }
  }
);

/// Asi to nakonec udělám přes Proxy, takže tohle nebude platit
/*
function typeErrorPossibleExplanation()
{
  let message = "Possible explanation:"
             + " Someone might be trying to dynamically modify non-primitive"
             + " property (Array, Object, etc.) of some class instance with"
             + " a dynamic prototype. This is intentionally disabled by"
             + " freezing all non-primitive properties on entity prototypes,"
             + " because non-primitive properties are inherited to instances"
             + " only as references. It means that when you modify"
             + " a non-primitive property (like Array, Object, etc.) on an"
             + " entity, the change will affect all instances of that class,"
             + " because it will happen on prototype rather than on your"
             + " instance. If that's the reason for this error, the solution"
             + " is to  manually clone the property you want to modify and"
             + " than do the change on the clone (that's what inheritance"
             + " should do automatically but doesn't do it).";

  /// TODO: Posílat to do syslogu, ne jen do konzole.
  console.log(message);  
}
*/

// This handler catches all uncaught exceptions.
// It can be used to explain what they could posibly
// mean and also syslog them so immortals know what
// happened and it is logged.
process.on
(
  'uncaughtException',
  err =>
  {
    /// TODO: Poslat hlášku do syslogu.

    /*
    if (err.name === "TypeError")
    {
      /// TODO: Posílat to do syslogu, ne jen do konzole.
      console.log(err.name + " occured: " + err.message);
      typeErrorPossibleExplanation();

      if (err.message.search("object is not extensible") != -1)
      {
        typeErrorPossibleExplanation();
      }

      if (err.message.search("Cannot assign to read only property") != -1)
      {
        typeErrorPossibleExplanation();
      }

      throw err;
    }
    */

    throw err;
  }
)

// Parses commandline parameters.
// - Return object imported from 'commander' module.
function parseCmdlineParams()
{
  parser.option(
      "-p, --port [portNumber]",
      "Port to listen to telnet [default: " + Server.DEFAULT_TELNET_PORT + "]",
      Server.DEFAULT_TELNET_PORT);

  parser.parse(process.argv);

  return parser;
}

// Program entry point.
// It's called main() to sound familiar to C programmers ;)
async function main()
{
  // Log our name and version.
  Syslog.log
  (
    packageDotJson.name + " server v. " + packageDotJson.version,
    Message.Type.SYSTEM_INFO,
    AdminLevel.IMMORTAL
  );

  let cmdlineParser = parseCmdlineParams();

  // Create an instance of server.
  // (server is a singleton so we use static method to do it)
  Server.create();
  // Run the server at specified telnet port.
  // (Server.run() is async function)
  await Server.getInstance().run(cmdlineParser.port);
}

// Run the main() function.
// (it's not done automatically in JavaScript)
main();
