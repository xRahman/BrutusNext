
TODO: Přesunout /Keys do /Server/Keys

------------------------------------------------------------------------------

TODO: ErrorUtils by mohly být v Shared/Log
- a obnecně XyUtils by mohly být vždycky někde kontextově a ne ve Shared/Utils
  (protože SyslogUtils je v zásadě privátní část Syslogu spíš než obecné
   utility funkce).

TODO: Jak přistoupit k handlerům na socketu.
- connection na klientu je singleton. Řešil jsem to tak, že
  v Connection.ts je static classa zděděná ze Shared.Connection,
  která má v sobě instanci 'connection' - ouch, to je velká divočina.
- buď z toho udělat namepace, kterej bude mít instanci connection,
  nebo prostě v Client.Connection implementovat vlastní handlery
  socket eventů (případně je tahat z ConnectionUtils nebo tak něčeho).

IDEA: volat socket.close(1000) je nejspíš špatně, protože kód 1000
  není "available for use by applications". To by mohl bejt důvod, proč
  dorazí jinek kód.


TODO: funkce HttpsServer.prependMessage() by asi měla bejt globální
  (a měla by se asi jmenovat názornějš).
- hodilo by se Error.prependMessage(), ale to asi nepůjde.
  (nebo error.prependMessage())
- je to ve ErrorUtils, ale nejsem si jistej, že to je dobrý pojmenování
  (ale asi jo).

TODO: Proč vlastně ze socketu při zavření removuju event listenery?
  V příkladech se to nikde nedělá.


------------------------------------------------------------------------------


Proč se v onClose() na socketu volá socket.close()?
  https://github.com/heineiuo/isomorphic-ws#readme
To je asi blbě, zrušit.


Socket class hierarchy
------------------------

'Socket' zapouzdřuje WebSocket
- nemůže se jmenovat WebSocket, protože by se to bilo, ale to asi ničemu nevadí
- měl by řešit čistě věci kolem WebSocketu, tj. event handlery, posílání
  raw dat (nemusí nic vědět o paketech), možná zavírání socketu, pokud
  to bude potřeba.

- otázka je, jestli by měl vůbec mít bejt onMessage() handler. Ale asi jo,
  lepší je přetížit metodu, kteá se z handleru zavolá.
  - tak jako tak ten handler musí bejt metoda, buď aby šel přetížit, nebo
    aby mohl volat metodu, která jde přetížit.

- Socket rozhodně nepotřebuje umět zpracovávat packety, tj. dědit ho
  z PacketHandleru je špatně.

Ze socketu by asi mělo bejt zděděný něco, co umí pracovat s paketama,
  tj. přečíst z paketu data a poslat je do socketu a vyrobit z příchozích
  dat paket a zavolat na něm process().
- mohlo by to i socket zapouzdřovat, ale pak by mu to muselo předávat
  callback na zpracování příchozích dat - v zásadě dává smysl spíš to
  zdědění.

Server verze Connection má na sobě getIp, což client verze nepotřebuje
  (protože je připojená vždycky na server). Ale pokud to mít může
  (bylo by to ip serveru?), tak to asi ničemu nevadí.
Server a client verze connectionu (packet handleru) mají jinak posílání
  paketů - při posílání na klienta se serializuje jinak než při posílání
  na server.
Klient určitě taky potřebuje vlastní verzi connectionu, už proto, že
  na klientu je jen jedna connection.

TODO: Vymyslet, kam dát metody na zpracování packetů.
- možná to prostě jen přehodit, ze Socketu zdědit PacketHandler a z toho
  Connection.

Proč má vlastně connection Playera? Aby věděla, koho se týkají přijatý pakety?
- playera asi každopádně zatím řešit nemusím.

------------------------------------------------------------------------------

TS verze fastpriorityqueue:
---------------------------

https://github.com/voxeline/FastPriorityQueue.ts
https://github.com/ddurschlag6river/TypedPriorityQueue/tree/tsport

https://github.com/lemire/TypedFastBitSet.js
- tohle je kupodivu javascript, ale i tak je to asi lepší než fastbitset


TODO: Použít FastPriorityQueue na saving queue nedává smysl (ehm),
  protože save requesty se nesortěj, prostě jen seděj v řadě za sebou.


------------------------------------------------------------------------------

Juju mapper:
-------------

http://www.mudportal.com/forum/support/22-jujumapper-open-beta


------------------------------------------------------------------------------

Zákaz spouštění package skriptů v npm:
---------------------------------------

npm config set ignore-scripts true


