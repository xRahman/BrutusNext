------------------------------------------------------------------------------

Socket class hierarchy
------------------------

'Socket' zapouzdřuje WebSocket
- nemůže se jmenovat WebSocket, protože by se to bilo, ale to asi ničemu nevadí
- měl by řešit čistě věci kolem WebSocketu, tj. event handlery, posílání
  raw dat (nemusí nic vědět o paketech), možná zavírání socketu, pokud
  to bude potřeba.

- otázka je, jestli by měl vůbec mít bejt onMessage() handler. Ale asi jo,
  lepší je přetížit metodu, kteá se z handleru zavolá.
  - tak jako tak ten handler musí bejt metoda, buď aby šel přetížit, nebo
    aby mohl volat metodu, která jde přetížit.

- Socket rozhodně nepotřebuje umět zpracovávat packety, tj. dědit ho
  z PacketHandleru je špatně.

Ze socketu by asi mělo bejt zděděný něco, co umí pracovat s paketama,
  tj. přečíst z paketu data a poslat je do socketu a vyrobit z příchozích
  dat paket a zavolat na něm process().
- mohlo by to i socket zapouzdřovat, ale pak by mu to muselo předávat
  callback na zpracování příchozích dat - v zásadě dává smysl spíš to
  zdědění.

Server verze Connection má na sobě getIp, což client verze nepotřebuje
  (protože je připojená vždycky na server). Ale pokud to mít může
  (bylo by to ip serveru?), tak to asi ničemu nevadí.
Server a client verze connectionu (packet handleru) mají jinak posílání
  paketů - při posílání na klienta se serializuje jinak než při posílání
  na server.
Klient určitě taky potřebuje vlastní verzi connectionu, už proto, že
  na klientu je jen jedna connection.

------------------------------------------------------------------------------

ÚVAHA O ERROR REPORTINGU
------------------------

Errory se dělí na tři druhy:
- reportuju přímo exception
- nemám exception, ale chci zalogovat stack trace
  (takže si vyrobím Error object a reportnu ho).
- stack trace nedává smysl.

IMPORTANT: REPORT(new Error()) je blbost, stack trace loguje
  i funkce ERROR().

- možná by to šlo ale zjednodušit tím, že zruším funkci ERROR(),
  strack trace budu vždycky tvořit funkcí REPORT a log bez stack
  trace půjde vždycky přes Syslog.něco().
- na druhou stranu budu psát víc kódu.

U funkce ERROR() bych asi taky přece jen chtěl rozlišovat druh erroru
  (aby se daly filtrovat skript errory od jiných errorů).
- možná zavést funkce jako SCRIPT_ERROR() etc. Ale popravě rozlišovat to
  jednotně message typem je asi lepší.

Otázka je, jeslti stack trace něčemu vadí. Jako ok, u socket erroru
  ho asi nepotřebuju, ale to je nejspíš ojedinělej případ.
=> Nelogovat WEBSOCKET_ERROR přes Syslog.log().

Závěr:
  Když loguju jakejkoliv error, tak:
  - zajímá mě stack trace
  - asi bych chtěl rozlišovat druhy errorů, abych mohl filtrovat
    třeba jen skript errory (i když...)
    Možná by se dala sloužit funkce ERROR() a REPORT()
    (ať už přes REPORT(new Error()) nebo tím, že ERROR() bude testovat
     typ parametru a pokud to bude Error object, tak ho reportne).
  Do funkce Syslog.log() by neměly chodit žádný errory.

Vidím to takhle:
- sloučím ERROR a REPORT (půjde dát Error object jako parametr ERRORu)
  (tohle sice nebude tak názorný jako REPORT(error), ale nebude se mi stávat,
   že bych napsal REPORT(new Error)).
- nebudu zavádět různý typy errorů, protože všechny errory jsou high
  priority a je třeba je opravit
  (možná zavést WARNING, ale spíš ne.)

Tak nakonec ještě jinak:
- Veškeré reportování bude v Syslogu
  Sylog.log() na info hlášky
  Syslog.logError() na errory (jak Error objekty, tak stringy).

-----------------------------------------------------------------------------

ÚVAHA: kdy házet REPORT(error)

- asi když k tomu můžu dát smysluplnou informaci

Obecně asi nemá smysl probublávat chyby až do top-level funkcí. Dokonce
  v nich mám i napsáno, že by měly bejt odchycené dřív.

IDEA: Možná se řídit tím, co jsem sám napsal do komentáře k funkci REPORT():
- když bych vyhodil ERROR() a dal return, tak je lepší místo toho hodit
  exception. Výjimka mě prostě vyhodí z předpokládanýho stavu věcí.

Ještě jde o to, že s výjimkou můžu něco dělat. Když posílám broadcast
  do všech connectionů a jeden z nich failne, tak to asi ničemu nevadí
  a můžu to klidně poslat do všech zbylých. Když ale posílám třeba nějakou
  entitu na klienta a neprojde to, tak bych dál neměl pracovat s tím,
  že je úspěšně poslaná. Tj. potřebuju, aby výjimka vybublala nahoru,
  protože to je informace o tom, že se to celé nepovedlo.

------------------------------------------------------------------------------