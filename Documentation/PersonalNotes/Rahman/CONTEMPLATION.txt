------------------------------------------------------------------------------

Mapa
-----

MUD data
  Koordináty v gridu
  - X a Y musej bejt celý čísla
  - Z nutně ne, ale platí, že v každém celočíselném intervalu může bejt
    jen jedna rooma (tj. efektivně i z je celočíselné + může mít offset).
    A offset stejně teď nemám jak zobrazit, takže na něj sere pes a bude
    i Z fixně.

Map data
  - map data jsou 2d, tj. čtvercová síť. Jsou v ní roomy, který se maj
    zobrazit - ne nutně jen řez gridem, můžou se zobrazovat i roomy co jsou níž.
  - můžou tam bejt odkazy na roomy v gridu
  - exity do 10 směrů.

  Exity by to chtělo mít separátně, jeden objekt pro každej exit, abych je
    mohl vykreslit v jednom průchodu.


  \|/  \|/  \|/  \|/  \|/  \|/  \|
  --x----x----x----x----x----x----x
  /|\  /|\  /|\  /|\  /|\  /|\  /|
    | \/ | \/ | \/ | \/ | \/ | \/ |
    | /\ | /\ | /\ | /\ | /\ | /\ |
    |/  \|/  \|/  \|/  \|/  \|/  \|
  --x----x----x----x----x----x----x
  /|\  /|\  /|\  /|\  /|\  /|\  /|
    | \/ | \/ | \/ | \/ | \/ | \/ |
    | /\ | /\ | /\ | /\ | /\ | /\ |
    |/  \|/  \|/  \|/  \|/  \|/  \|
  --x----x----x----x----x----x----x

  IDEA: Rozdělit to na několik seznamů, vždycky existy v jednom směru:
  - n/s
  - e/w
  - nw/se
  - sw/ne
  Pokud je mapa čtvercová, tak mi vlastně u každýho exitu stačí vědět,
    kolikátej v pořadí je (což je pořadí v poli). Podle toho dopočítám,
    ke kterejm roomám vede.
  (Teleportační exity nechám zatím bejt.)
    Tzn. když budu mít N/X roomů, tak potřebuju N-1 exitů od každýho za 4 typů.
  - Je teda otázka, jesltli je potřeba mít celou síť exitů, i když se jich
    většina nebude zobrazovat (pro editaci asi jo), ale můžu tohle použít
    minimálně na indexaci exitů (tj. nasypu je třeba do hashmapy a budu je
    indexovat číslem, který by měly v plný síti).

------------------------------------------------------------------------------

Text Colors
------------

Jak je to s escapováním:

&&r -> &r
&&? -> &?

&x? -> &x

To znamená, že && nejspíš vůbec nemusím řešit. Když to není color kód,
tak prostě outputnu nezměněný znaky. I když vlastně ne, && musím nahradit za &


IDEA:
Nejdřív split podle "&&" a nakonec join přes &&.
=> Efektivně řeším pouze problém stringu vždy s jedním ampersandem.

IDEA: Všechny

Řešení color kódů:
- split podle "&".
  Když je první prvek &&, znamená to, že začínám ampersandem, tj. už první
  prvek může bejt <span>. Vlastně vždycky je, protože i když tam není
  barva, tak použiju base color.

Brute Force:

Otevřu <span>
  Doplním barvu podle toho, jeslti je na začáku color code.

  Když uvntiř najdru color code, tak
  - zavřu <span>
  - otevřu <span>

Zavřu <span>

------------------------------------------------------------------------------

Component hierarchy
--------------------

• Should text link be component or just element?

• Should window content be component or just element?
  - možná obecná komponenta "Content" s tím, že jméno "window_content"
    dostane od okna, které ji vyrobí?

• Should text be component or just element?

Svádí mě to udělat všechno jako komponenty. Bude to sice hodně
  ts souborů, ale zas bude všechno oddělené a bude přehledné
  dědění css (nebude víc deklarací css na classu).

=> Budu na všechno dělat componenty.

------------------------------------------------------------------------------

Vytváření custom "style" elementu
----------------------------------

var style = (function() {
    // Create the <style> tag
    var style = document.createElement("style");

    // WebKit hack
    style.appendChild(document.createTextNode(""));

    // Add the <style> element to the page
    document.head.appendChild(style);
  
    console.log(style.sheet.cssRules); // length is 0, and no rules

    return style;
})();

------------------------------------------------------------------------------

Stavy jako mouseover, active etc.
---------------------------------

V prvé řadě budu asi potřebovat rozšířit definici css. Nebude to jeden
  objekt, ale něco ve smyslu:

{
  normal: Partial<CSSStyleDeclaration>,
  hover: Partial<CSSStyleDeclaration>,
  active: Partial<CSSStyleDeclaration>
}

S tím, že hover, active apod. by asi měly automaticky dědit
  z normal (nejspíš v Element.setCss()).


Další otázka je, jak ty stavy přehazovat. Asi to budu muset dělat
  přes event handlery - což je ok, ale bojím se, abych si to nepřepsal,
  až budu ty handlery potřebovat na něco jinýho. Nejspíš budou muset
  bejt v Componentě, aby se z potomků dalo volat super().



Druhá možnost:
- nesetovat elementům jednotlivý css properties, místo toho vytvořit
  pro každou komponentu css classu (pokud to půjde) a setnout tu.

  https://stackoverflow.com/questions/1720320/how-to-dynamically-create-css-class-in-javascript-and-apply




Konverze jména property CSSStyleDeclaration na jméno css property.
  http://www.java2s.com/Tutorials/Javascript/CSS/How_to_use_CSSStyleDeclaration_Objects.htm#property_from_CSSStyleDeclaration


"fooBarBaz".replace(/([A-Z])/g, "-$1").toLowerCase();
https://stackoverflow.com/questions/24758284/how-to-change-camelcase-to-slug-case-or-kabob-case-via-regex-in-javascript


------------------------------------------------------------------------------

Css all
---------

Zvážit resetování css pro každou komponentu pomocí:

.module
{
  all: initial;
}

https://css-tricks.com/almanac/properties/a/all/

- Asi by se pak musel nastavovat font pro každou komponentu,
  ale to by snad nemuselo vadit (dal bych je někam na jedno místo
  a všude je importoval).

Zkusil jsem to nastavit pro * a vedlo to k tomu, že se zobrazil i title,
kterej je v headeru.

=> kašlat na to.


-------------------

Jelikož budu používat css classy, nedává smysl nastavovat je v instancích.
Tn. buď statickou metodou, nebo automaticky při vytvoření objektu.

A dědění udělám prostě tak, že komponentě nafrkám všechny classy předků,
ono to zjevně funguje.


------------------------------------------------------------------------------

Dědičnost css
--------------

 S děděním css properties to není tak jednoduchý, protože na neprimitivní
  properties nefunguje prototypová dědičnost.
  => Definice css by musela bejt class a v potomkovi bych musel
    explicitně napsat, že ji dědím.


* Možný řešení 1:

  interface I
  {
      a?: number,
      b?: number
  }

  const cssA: I = { a: 1, b: 2 };

  class Css
  {
      constructor(private css: I) {}
      
      public extends(ancestor: I)
      {
          Object.setPrototypeOf(this.css, ancestor);
          return this.css;
      }
  }

  const cssB = new Css
  (
    {
      a: 7
    }
  ).extends(cssA);

  console.log(cssB.a, cssB.b);


* Možný řešení 2:

  Udělat to stejně jako u Entit, tj. Nejdřív vyrobit neprimitivnjí properties
  přes Object.create() a až pak do nich zapsat hodnoty.

Dědění přímo css má nevýhodu v tom, že se musím extra specifikovat, z čeho
  dědím, nestačí zdědit classu. To by ale mohla bejt i výhoda, pokud
  budu mít vícero css v jednom ts souboru, což asi mít budu.

=> Zatím nechám solution 1. Uvidí se, jak se s ním bude pracovat.

--------------

Ještě přece jen zvážím dědičnost ve stylu entit, aby nebylo třeba ručně
psát, z čeho se dědí.

Problém je, že každá komponenta by pak musela mít svoji instanci css,
  nebo aspoň odkaz na ni.
- kdyby to byl odkaz, tak intancování každý entity by ho asi přepsalo.
  I když vlastně ne. Instancuje se z prototypu, kterej se vytváří
  jen jednou. Do něj se nasetujou hodnoty přiřazené v classy. Nově
  vytvořené instance pak jsou jen {}.

Takže zřejmě na Componenty potřebuju to samý co na Entity.
  Je nějakej důvod, proč by to neměly bejt rovnou Entity?
  - budou mít vlastní id, což ale ničemu nevadí. Můžu ho
    používat jako idčko html elementu.
  - budu muset povolit vyrábění entit na klientu. Což je trochu
    problém, protože se mi budou bít idčka.
    - To má easy řešení - entity na klientu budou mít jinej prefix.
      Nepotřebujou timestamp, protože klient entity se nesavujou.


------------------------------------------------------------------------------

Socket class hierarchy
------------------------

'Socket' zapouzdřuje WebSocket
- nemůže se jmenovat WebSocket, protože by se to bilo, ale to asi ničemu nevadí
- měl by řešit čistě věci kolem WebSocketu, tj. event handlery, posílání
  raw dat (nemusí nic vědět o paketech), možná zavírání socketu, pokud
  to bude potřeba.

- otázka je, jestli by měl vůbec mít bejt onMessage() handler. Ale asi jo,
  lepší je přetížit metodu, kteá se z handleru zavolá.
  - tak jako tak ten handler musí bejt metoda, buď aby šel přetížit, nebo
    aby mohl volat metodu, která jde přetížit.

- Socket rozhodně nepotřebuje umět zpracovávat packety, tj. dědit ho
  z PacketHandleru je špatně.

Ze socketu by asi mělo bejt zděděný něco, co umí pracovat s paketama,
  tj. přečíst z paketu data a poslat je do socketu a vyrobit z příchozích
  dat paket a zavolat na něm process().
- mohlo by to i socket zapouzdřovat, ale pak by mu to muselo předávat
  callback na zpracování příchozích dat - v zásadě dává smysl spíš to
  zdědění.

Server verze Connection má na sobě getIp, což client verze nepotřebuje
  (protože je připojená vždycky na server). Ale pokud to mít může
  (bylo by to ip serveru?), tak to asi ničemu nevadí.
Server a client verze connectionu (packet handleru) mají jinak posílání
  paketů - při posílání na klienta se serializuje jinak než při posílání
  na server.
Klient určitě taky potřebuje vlastní verzi connectionu, už proto, že
  na klientu je jen jedna connection.

------------------------------------------------------------------------------

ÚVAHA O ERROR REPORTINGU
------------------------

Errory se dělí na tři druhy:
- reportuju přímo exception
- nemám exception, ale chci zalogovat stack trace
  (takže si vyrobím Error object a reportnu ho).
- stack trace nedává smysl.

IMPORTANT: REPORT(new Error()) je blbost, stack trace loguje
  i funkce ERROR().

- možná by to šlo ale zjednodušit tím, že zruším funkci ERROR(),
  strack trace budu vždycky tvořit funkcí REPORT a log bez stack
  trace půjde vždycky přes Syslog.něco().
- na druhou stranu budu psát víc kódu.

U funkce ERROR() bych asi taky přece jen chtěl rozlišovat druh erroru
  (aby se daly filtrovat skript errory od jiných errorů).
- možná zavést funkce jako SCRIPT_ERROR() etc. Ale popravě rozlišovat to
  jednotně message typem je asi lepší.

Otázka je, jeslti stack trace něčemu vadí. Jako ok, u socket erroru
  ho asi nepotřebuju, ale to je nejspíš ojedinělej případ.
=> Nelogovat WEBSOCKET_ERROR přes Syslog.log().

Závěr:
  Když loguju jakejkoliv error, tak:
  - zajímá mě stack trace
  - asi bych chtěl rozlišovat druhy errorů, abych mohl filtrovat
    třeba jen skript errory (i když...)
    Možná by se dala sloužit funkce ERROR() a REPORT()
    (ať už přes REPORT(new Error()) nebo tím, že ERROR() bude testovat
     typ parametru a pokud to bude Error object, tak ho reportne).
  Do funkce Syslog.log() by neměly chodit žádný errory.

Vidím to takhle:
- sloučím ERROR a REPORT (půjde dát Error object jako parametr ERRORu)
  (tohle sice nebude tak názorný jako REPORT(error), ale nebude se mi stávat,
   že bych napsal REPORT(new Error)).
- nebudu zavádět různý typy errorů, protože všechny errory jsou high
  priority a je třeba je opravit
  (možná zavést WARNING, ale spíš ne.)

Tak nakonec ještě jinak:
- Veškeré reportování bude v Syslogu
  Sylog.log() na info hlášky
  Syslog.logError() na errory (jak Error objekty, tak stringy).

-----------------------------------------------------------------------------

ÚVAHA: kdy házet REPORT(error)

- asi když k tomu můžu dát smysluplnou informaci

Obecně asi nemá smysl probublávat chyby až do top-level funkcí. Dokonce
  v nich mám i napsáno, že by měly bejt odchycené dřív.

IDEA: Možná se řídit tím, co jsem sám napsal do komentáře k funkci REPORT():
- když bych vyhodil ERROR() a dal return, tak je lepší místo toho hodit
  exception. Výjimka mě prostě vyhodí z předpokládanýho stavu věcí.

Ještě jde o to, že s výjimkou můžu něco dělat. Když posílám broadcast
  do všech connectionů a jeden z nich failne, tak to asi ničemu nevadí
  a můžu to klidně poslat do všech zbylých. Když ale posílám třeba nějakou
  entitu na klienta a neprojde to, tak bych dál neměl pracovat s tím,
  že je úspěšně poslaná. Tj. potřebuju, aby výjimka vybublala nahoru,
  protože to je informace o tom, že se to celé nepovedlo.

------------------------------------------------------------------------------