TODO: Zoomování mapy kolečkem myši
[done]

TODO: Mazání roomy nemaže exity.
- hmm a kdo ví, jestli to vůbec smaže to roomu. Když do ní totiž vedou
  exity, tak se v nich na ni drží reference.
  - aha, jasně. To znamená, že se asi dál vykreslujou jendosměrný exity.
Možná by exity měly přece jen vést na coords a ne na roomu.
- alternativně budu muset při mazání roomu odmazat ze všech room, které
  do ní mají exit - což může bejt problém zjistit, pokud budou existovat
  exity "na dálku".
- Exity směřované na coords taky vyřeší problém u automapy, že exit vede
  do neprozkoumané místnosti.
Otázka je, jestli při smazání roomy exity smazat chci.
  Asi jo, exit do neexistující místnosti je beztak naprd (neměl by existovat).
TODO: Při mazání roomy smazat exity, které do ní vedou.
[done]

TODO: Vymyslet, jak mazat exity (nějak pohodlnějš než editací roomy).
  - Asi to spojit se změnou metody mazání místností (obojí deletem při
    mouseoveru). Díky tomu půjde dát na pravý myšítko něco jinýho (nejspíš
    editace roomu).
Problém: Dávalo by smysl mazání dragováním pravým myšítkem, stejně jak se
  buildí dragováním levým myšítkem. V tom případě se ale nemůže mazat
  mačkáním deletu.
  - šlo by to držením deletu, ale to pravý myšítko je asi šikovnější.
Bude to pravým myšítkem
[done]

TODO: ExitSvg by se možná měl jmenovat spíš RoomConnection.
  Exit je ven z roomy...
  I když, ono to je možná srozumitelný i takhle (jednosměrnej exit, obousměrnej
  exit, atd.)
[nechám to být]

TODO: Exity směřovat na Coords místo na Room
[done]

TODO: Editor přejmenovat na MapEditor
[done]

TODO: Data pro exity
  - potřebuju classu Exit a musí mít idčko (klidně ho nafakovat).
  - v roomě potřebuju 10 odkazů do příslušných směrů
[done]

TODO: Zobrazení exitů
[done]

TODO: Naklikávání exitů
[done]

TODO: Vyrábění room dragnutím přes ně
 (ostatně když někam vyrobím exit, tak tak zjevně chci i roomu, že)
[done]

TODO: Assert, že vytvářenej exit nevede do stejný roomy
[done]

TODO: Vyrobit room už v onmouseleave
[done]

TODO: Udělat Exit.nowhere(), což vrátí instanci exitu, kterej nikam nevede.
  Důvod: Časem bude potřeba look description v daném směru a bude lepší, když
    to bude ve standarní struktuře exitů.
  (exit to "Nowhere").
[done]

TODO: Rozdělit funkci na distance a direction
  (direction hodí exception když je distance 0).
[done] 

TODO: V RoomSvg.onMouseEnter() vyrábět exit pouze pokud ještě není
  vyrobenej (respektive hlavně nepřegenerovávat mapu, pokud už exit
  existuje, protože pak se pořád dokola posílá onmouseenter);
[done]

TODO: Do event handlerů v RoomSvg dát funkce popisující, co se vlastně dělá.
[done]

TODO: V RoomSvg místo Editor.areAdjacentCoords zavolat rovnou
  Coords.areAdjacent() (bude ji třeba napsat místo Coords.distance().
[done]

TODO: Ze statických metod v Coords, které nemusí být statické, udělat
  instanční metody
[done]

TODO: "No change was required" zkrátit na "No change"
[done]

TODO: Pamatovat si lastSelectedRoom na konci onmouseenter() místo
  onmouseleave()
- tohle nepůjde. Když do místnosti vlezu myší bez lmb down, tak
  se coords nezapamatujou.
[won't do]

TODO: V onmouseup() zapomenout zapamatované coords (protože jinak exit navazuje
  na roomu, u které už to builder nečeká)
[done]

TODO: V Gui.updateMap() je třeba nejdřív vysypat obsah room a exitů v mapě.
[done]

TODO: Gui.updateMap() volat asi rovnou z svg komponent. Bude pak z toho kódu
  jasnější, co se děje.
[done]

TODO: Když dragnu exit z neexistující roomy, tak se pokusí vytvořit
  a hodít to exception, že zdrojová rooma neexistuje (pochopitelně)
  - asi ji automaticky vytvořit.
[done]

TODO: Když jedu myší rychle, tak zjevně odjedu z nově vytvořené roomy
  dřív, než se pro ni vytvoří element, a tudíž se nespustí onMouseLeave().
- Co s tím?
  Nejspíš nově vytvořenou roomu zapamatovat jako naposledy označenou.
  - Jo, to pomohlo.
[done]

TODO: Cestu k ikoně hodit do Roomy (a číst ji z ní).
[done]

TODO: Zamyslet se, jestli nebude lepší v Grid.delete() házet exception,
  když tam mazanej item není (asi jo).
[done]

TODO: Zakázat context menu v celém dokumentu
[done]

TODO: Vyrobení roomy kliknutím na její ikonu.
- Změní se grafika, do World.grid se na příslušný souřadnice přidá new Room().
[done]

TODO: Smazat Element.ts.deprecated
[done]

TODO: Grafika pro neexistující roomu (možná jí prostě nedat ikonu?)
- není to moc hezký, ale zatím to stačí.
[done]

TODO: Implementovat Grid3d (pořadí souřadnic je e, s, u).
  TODO: Zaokrouhlovat coords na celá čísla.
  [done]
[done]

TODO: namespace World a class Room
  (zóny zatím neřešit, potřebuju zobrazit celej World)
[done]

Na začátku žádný roomy neexistujou. Zavolám RoomsSvg.update(), vyrobí
  to 2d řez neexistujících room.
[done]

TODO: setPosition nefunguje u SvgG elementu.
 - respektive musela by to bejt transformace, což asi klidně může.
 - ale setRelativePosition() nebude fungovat určitě.
TODO: Dát setRelativePosition() jen do Svg, jinde stejně nejspíš
  nebude potřeba.
[done]

Idea: Místo MudMap dát MapSvg, místo RoomOnMap dát RoomSvg, místo IconOnMap
  dát IconSvg.
  - sounds good.
[done]

TODO: Potřebuju vůbec classu na Ikony? Nestačila by SvgImage?
- nepotřebuju, zrušit
[done]

TODO: Vyrobit soubor se seznamem užitečných extensionů
[done]

TODO: Napsat návod, jak z inkscapu vyexportovat co nejčistší svg.
[dine]

TODO: Zkontrolovat css.
[done]

TODO: Kód z MapCenteringContainer rozhodit do podkomponent.
[done]

TODO: Přesunout svg komponenty do /Svg a text komponenty do /Text
[done]

TODO: Funkce na jednotlivé svg transofrmace (translace atd.)
[done]

TODO: SpanComponent, SvgComponent etc přejmenovat na Span, Svg etc.
[done]

TODO: Přejmenovat Map na MudMap, protože se to tluče s hashmapou.
[done]

TODO: Možná by 'parent' předávanej konstruktoru komponent mohl
  bejt Component a ne element.
- to by ale asi znamenalo, že div a podobně by musela vyrábět až Component.
- a pak by asi bylo lepší udělat to tak, že z Component zdědím DivComponent,
  SpanComponent, SvgComponent atd., z nichž každá automaticky vyrobí
  element příslušnýho druhu.
[done]

TODO: state by asi měl bejt jinde než ve Windows. Application?
- Gui could have a state.
[done]?

TODO:
- vytvořit okna pro defaultní game view:
  - GroupWindow, RoomWindow, MapWindow
  Dole:
  - ChatWindow, CombatWindow, SpamWindow
  Někde bude ještě muset bejt player frame, target frame a tak - nejspíš
    někde uprostřed.
[done]

TODO: Connection.open() by měla bejt async funkce, která se resolvne
  v Connection.onOpen().
[done]

TODO: pořešit app state a to, kdy se má co zobrazovat.
[done]

TODO: Otestovat novou verzi TextColors.
[done]

TODO: Přejmenovat MudColors na TextColors.
[done]

TODO: Setovat text do title baru (default: "New window).
[done]

TODO: Newrapovat MudColors.htmlize() do extra spanu, protože
   do spanu se to bude dávat při vytváření elementu.
[done]

TODO: Refactoring MudColors.ts
[done]

TODO: Escapovat string, ze kterého dělám html.
[done]

TODO: Escapovat až outputnutý charactery (dělám si to zbytečně složitý).
[done]

TODO: Vyrobit komponentu Text (a asi rovnou i TextLink)
[done]

TODO: Přesunout css do style sheetu
[done]

Hmm...
- vytvořit vlastní typ pro css properties
- generovat z něj stringovou reprezentaci css classy
  (při té příležiosti můžu pořešit vícenásobnou definici některejch
   properties kvůli zpětný kompatibilitě)
- a asi by stálo za to, zamyslet se ještě jednou na využitím true
  prototypal inheritance pro Component classy.
  - to teda bude znamenat instancovat je přes ClassFactory...
Tohle nakonec bude jinak.
[won't do]

TODO: Nejdřív předělat komponenty na entity a stávající dědičnost
  udělat přes true prototypal inheritance
Tohle nakonec bude jinak.
[won't do]

TODO: Potom založit novej typ na css a umožnit v něm deklarovat
  :hover, :active a podobně.
Tohle nakonec bude jinak.
[won't do]

TODO: Pak napsat vyrábění stringové reprezentace css classy.
Tohle nakonec bude jinak.
[won't do]

TODO: A zautomatizovat vyrobení a setnutí css classy pro každou
  komponentu.
  (vyrábět by se měla jen jednou, takže nejspíš v konstruktoru,
   protože ten se zavolá jen při vytváření prototypu - další
   instance se pak vyráběj pře Object.create() a konstruktor se
   nevolá)
Tohle nakonec bude jinak.
[won't do]

TODO: Client/Entities
[done]

TODO: Vyřešit stavy jako mouseover, active etc.
- vyzkoušet vytváření vlastních css class.
Tohle nakonec bude jinak.
[won't do]

StandaloneWindow? CenterScreenWindow? ScreenCenterWindow? CenteredWindow?
- Šířku definovat přes 'rem', ne přes grid.
 Výšku automaticky, centrovat na střed
- Hmm, vlastně asi v gridu bejt může, prostě přes celej grid a vycentrovat se.
[done]

TODO: Udělat z window content komponentu
[done]

TODO: Použít symbolické konstanty pro grid arey
[done]

TODO: TitledWindow
[done]

TODO: Dávat komponentám jména.
[done]

TODO: Použít všude defaultní hodnotu parametru místo ternary operátoru.
[done]

TODO: Udělat z TitleBaru Componentu.
[done]

TODO: Přejmenovat Resources na ^Resources nebo tak něco.
[done]

TODO: Zprovoznit defaultění css v rámci Component hierarchie.
- bacha, v GUI je definované css mimo Component classu.
[done]

TODO: Používat všude grid místo flexboxu.
- např. ve Window
[done]

V Gui už zbylo jen setování css pro Body element,
  takže z toho možná můžu zase udělat Body.ts (a možná
  rovnou zase komponentu, protože proč ne).
- hmm tak ne, asi budu potřebovat <html> element kvůli
  globálnímu nastavování velikosti fontů.
TODO: Určitě z toho zase udělat komponenty. Bude dávat větší smysl,
  když budou zděděné z Component stejně jako všechno statní.
[done]

TODO: Všude používat 'rem' místo 'em':
  'rem' values are relative to the root html element, not the parent element.
- a používat to i pro padding, grid gap a podobně, ať mi všechno scaluje
  s velikostí fontu.
[done]

TODO: Pořešit init Body, Html a Windows.
[done]

IDEA: Možná by taky nebylo od věci mít nějakej "default" pro css values,
  podobně jako mám defaultní hodnoty pro property attributes.
[done]

Setování elementu do component.
- určitě v konstruktoru, pak nemusím řešit, jestli existuje. Čili stopro
  se bude přeávat konstruktoru předka.
[done]

Setování css při vytváření componenty
- asi ho setnout rovnou při vytváření elementu, tzn. v konstruktoru Component
  nevolat setCss().
[done]

TODO: Potřebuju vůbec classy Body a Html?
- asi by stačilo v Gui setnout 'body' elementu css.
- to samý pro Html.
[done]

TODO: Updatnout client-side npm moduly
[done]

TODO: Projít client a server verzi Connection, jestli by nedávalo smysl
  sdílet část kódu (ale asi bude přehlednější to nedělat).
- zatím to fakt nemá smysl.
[done]

TODO:
  Sylog.log() čistě na info hlášky
  Syslog.logError() na errory (jak Error objekty, tak stringy).
[done]

TODO: Použít FastPriorityQueue na saving queue nedává smysl (ehm),
  protože save requesty se nesortěj, prostě jen seděj v řadě za sebou.
[done]

Proč se v onClose() na socketu volá socket.close()?
  https://github.com/heineiuo/isomorphic-ws#readme
To je asi blbě, zrušit.
[done]

TODO: Reportovat disconnect zavřením browser tabu
[done]

TODO: Proč vlastně ze socketu při zavření removuju event listenery?
  V příkladech se to nikde nedělá.
- v novém kódu se to taky nedělá
[done]

TODO: funkce HttpsServer.prependMessage() by asi měla bejt globální
  (a měla by se asi jmenovat názornějš).
- hodilo by se Error.prependMessage(), ale to asi nepůjde.
  (nebo error.prependMessage())
- je to ve ErrorUtils, ale nejsem si jistej, že to je dobrý pojmenování
  (ale asi jo).
[done]

Jak přistoupit k handlerům na socketu.
- connection na klientu je singleton. Řešil jsem to tak, že
  v Connection.ts je static classa zděděná ze Shared.Connection,
  která má v sobě instanci 'connection' - ouch, to je velká divočina.
- buď z toho udělat namepace, kterej bude mít instanci connection,
  nebo prostě v Client.Connection implementovat vlastní handlery
  socket eventů (případně je tahat z ConnectionUtils nebo tak něčeho).
TODO:Udělat z  Client/Connection napespace.
[done]

TODO: Přesunout /Keys do /Server/Keys
[done]

TODO: Přejmenovat adresář /Build na /Server. V něm bude /js, stejně
  jako v /Client, a do něj se bude buildit. Data na serveru budou tudíž
  v adresáři /Server.
[done]

TODO: V Client/js by měl bejt adresář BrutusNext a v něm až /Shared a /Client.
  To samý na serveru.
[done]

TODO: Možná rozdělit typ Syslog.messageType na ok message a error message.
- zamítnuto, errory se reportují jinak než pomocí Syslog.log().
[won't do]

Proč jsou vlastně WebSocketServer a Https server classy?
  Však jsou to beztak singletony.
TODO: Předělat je na namespacy.
[done]

U socketu to je už jiná otázka, těch může bejt víc a různě se na něj věšej
  event handlery a tak.
- možná na klientu to nemusí bejt classa.
[done]

TODO: Udělat z WebSocketServer namespace.
[done]

TODO: Zvážit, jestli by typy přece jen neměly bejt dependancy místo
  dev dependancy.
- jo, mají být dependancy, prorože jsou používané v runtime kódu.
[done]

TODO: RETHROW možná není potřeba, dělám to ručně a možná je to tak
  čitelnější.
- RETHROW() určitě zrušit, throw Error() je dostatečně výmluvné
  a většinou se beztak novej message formátuje speciálně.
[done]

------------------------------------------------------------------------------

Eslint
------

TODO: Nastavit pravidla pro eslint [done]
- až budou, smazat tslint.json [done]

TODO: Zvážit použití prettify [done]
- nepoužitelný, nedá se konfigurovat

TODO: Vyřešit lintování celého kódu (extension zřejme lintuje jen otevřené
  soubory). [done]

  TODO: Zmigrovat tslint na typescript-eslint [done]

  https://github.com/palantir/tslint/issues/4534

  tool na migraci: https://github.com/typescript-eslint/tslint-to-eslint-config

  Návod (možná):
  https://medium.com/@cosmvs/painless-migration-from-tslint-to-eslint-for-react-with-typescript-4befb4918ba8


  Instalace typescript-eslintu:
  -----------------------------
  npm install eslint --save-dev
  npm install @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev


  If you don’t want to lint certain files, then at the root level of your application’s folder structure you can add a .eslintignore file, where you can list any files that should be ignored.
  For example:
  src/serviceWorker.ts
  src/**/__tests__/**

  Do package.json se prej má přidat:
    "scripts": {
      "lint:ts": "eslint --ext=jsx,ts,tsx src"
    },
  ale nic to nedělá.

  
  Rules: https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin

  Eslint rules: https://eslint.org/docs/rules/

  ------------------------------------------------------------------------------

  Syslog [done]
-------------

  - Přespání metody static classy zjevně funguje. Šlo by to i bez classy?
  - Přepsat metoda přímo v interfacu nejde

  Další možnosti:
  - hodit ty přepisovací metody do objektu (a ten exportnout).
  Ha, ono to zjevně funguje i přímo v namespacu, jen jsem ho špatně importoval.

  Tzn. asi to půjde přes namepacy, ale nebudu mít protected metody...
  - možná ze Shared/Syslog exportovat dva namespacy s tím, že v tom druhém
  budou pomocné metody?

  Ještě to udělám jinak:
   - SyslogUtils bude samostatnej file a v Syslog.ts bude pouze funkce log()
     a typ Syslog.MessageType

  Ok, takže nakonec ještě jinak:
  ------------------------------
  - Shared verze Syslogu exportuje prázdné metody
  - Client a server verze importnou shared Syslog, předefinujou tyhle
    metody a zase exportnou Syslog.
  - Protected metody Syslogu jsou v modulu SyslogUtils, který Syslog importuje.
    Tím je zajištěno, že ten, kdo si importne Syslog, uvidí jen "public" metody
    Syslogu.
  

------------------------------------------------------------------------------