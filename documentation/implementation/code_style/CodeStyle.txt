New stuff:
============

Multiline strings
------------------

// Always put space at the start of a new line like this:

ERROR("Unable to compose prototype save path for"
  + " prototype '" + className + "' because dynamic"
  + " class '" + className + "' doesn't exist. Prototype"
  + " will be saved to " + errorPath + " instead");

// This way it's easy to see that you missed a space.

============================================

Indentation
------------
{
  // Use two spaces (don't use tabs)
}

Trailing spaces
----------------

// Don't leave spaces at the end of lines if possible.
// Don't put spaces on empty lines if possible.

Comments
---------

// Use multiline comments only outside blocks and function bodies, usually
// when you are commenting what a function does.
// This allows commenting-out of whole blocks or functions.

/*
  This is a multiline comment.
  Ident it with two spaces as if it were a block.
  Finish sentences with dots. So it's always clear where the sentence begins
  and where it ends.

  Insert empty line if you are covering more topics.

  We generally only use multiline comments for how-it-works explanations
  placed outside all blocks and functions (usually at the start of each file).
  (this is to allow commenting-out of large chunks of code with multiline
  comments)
*/


// Insert 1 space in between '//' and comment text.
// Start with capital letter, end sentences with dots.
// (additional one-sentence info is best put within paranthesis without
// leading capital letter and finishing dot on the next line, even if it
// splits to multiple lines)
//   Don't put multiple sentences within paranthesis, though. Indent them
// with two spaces like this one instead, if it helps readability.

// You don't need capital letter and dot for non-sentence comments
// like this one:

var color = [0, 255, 0];  // green

// Indent comments on the same line with two spaces after ';'.
// (or more if you can align it with other comments)

var baseColor = [0, 255, 0];    // green
var outlineColor  = [0, 0, 0];  // black

// If you comment a line of code, don't insert an empty line:
var commentedLine;

// So not like this:

var thisVariableWouldLikeToBeCommentedAsWell;

Line width
-----------

// Never exceed 80 characters on a line.
// (good editors can visualise the limit for you if you have wider screen)
// Best practice is to only use maximum of 79 characters so there is at least
// one space left at the end of 80-character line.
// (don't put a ' ' there though, just hit enter)

Function headers:
-----------------

// Don't insert white spaces neither in between function name and '(' nor
// in between '(' or ')' and parameter name, but do insert single space
// after ','.

function myHappyFunction(firstParam, secondParam)
{
}

// If you need to split parameter list to multiple lines, put each parameter
// on the new line and indent parameters with usual 2 spaces. Brackets
// are each placed to new line as well as return value. This way you can
// also easily comment any parameter.

function myHappyFunction
(
  firstParam,
  // Comment of secondParam.
  secondParam,
  thirdParam,
  fourthParam
)
: returnValue
{
  // ..
}

// This also applies when you are calling a function with long parameter list:

{
  myHappyFunction
  (
    "One hundred and one",
    "One hundred and two",
    "One hundred and three",
    // 104 is skipped on purpose.
    "One hundred and five"
  );
}

Blocks, function bodies, etc.
-----------------------------

// Put opening bracket on the new line.
// If possible align values with the one most to the right.

var person =
{
  firstName: "John",
  lastName:  "Doe",
  age:       50,
  eyeColor:  "blue"
};

// Try to keep blocks and functions as short as possible. More than one page
// (20 lines) is only acceptable if you reduced every subblock to a single
// non-block statement.
//   E.G. switch with many cases should look like this:

  case 1:
    if (sunIsShining)
      doSomething();
    break;

// or even better:

  case 1:
    doSomething(sunIsShining);
    break;

// but not like this:
// (only if total length of function exceeds one page of course,
// otherwise it's perfectly ok!)

  case 1:
    if (sunIsShining)
    {
      doSomething();
      doSomethingElse();
    }
    break;


Return values of functions
---------------------------

// If you are returning complex expression, put it in a local variable
// and return that variable, so it's clearly readable what is the return
// value.
// (this way the return value is self-documented, you don't need to comment it)

function toCelsius(fahrenheit)
{
  var temperatureInCelsius =
    (5 / 9) * (fahrenheit - 32);

  return temperatureInCelsius;
}

// Remember that in JavaScript you cannot insert newline in between 'return'
// and returned value like this:
{
  return
    false;
}
// This is because of automatic semicolon insertion, it will actually
// get interpreted as: return; false;
// (it is another reason for returning a named variable instead of long
// expression)


Update:
  Specify return type of a function unless it's a simple one-line getter.
Even though the type will be automatically infered from return values
by typescript, there are two reasons to do it manually:

- Code will be self-commented: It will be easy to see what the function
  returns.

- It will help you catch mistakes - typescript won't let you return
  something that is not of correct type. You would probably find out
  when you called your function somewhere, but it still helps a little
  bit.

Verbose union types in return values:
  Don't return 'undefined' or 'null', return a string literal type
  instead. For example:

public find(id: string): Entity | "NOT FOUND"
{
  ...
}

There are two reasons:

- Code will be self-commented: It will be easy to see what is the meaning
  of return value even without an extra comment.

- Usage of this function will also be self-documented.

Exmple:
{
  let searchResult = this.find(id);

  if (searchResult === "NOT FOUND")
  {
    doSomething();
    return;
  }

  // Here we are exploiting typescript control flow analysis.
  // The type of 'searchResult' is (Entity | "NOT FOUND") but
  // we have narrowed it in the first if clause. Because we
  // have specified that the type of 'entity' is 'Entity',
  // typescript will only allow us to assign 'searchResult'
  // to 'entity' if we have handled all other cases of original
  // union type and the only remaining variant is of type 'Entity'.
  //   It means that this code is not only self-documented but it
  // also ensures that all possibilities are handled.
  let entity: Entity = searchResult;
}


Conditions
-----------

// If you are evaluating complex condition, put it in a local variable and
// evaluate that variable. You should also do it to split really crazy
// conditions to more readable ones.

var isValueValid = value >= 0 && value < 100 && value != 13;

if (isValueValid)
{
  // ...
}

// Insert single space in between if and '('.
// Insert single space in between identifiers and operators:

var isInvalid = isNull || isUndefined;

// If you split condition to multiple lines, put opertors at the beginning of
// the next line like this:

var isValueValid =
  value >= 0
  && value < 100
  && value != 13;

// Always put newline after condition:

if (isNight)
  visibility = 0;
  
// not like this: if (isNight) visibility = 0;

Identifiers
------------

// Use camelCase (starting with lowercase letter) for local variables, function
// parameters, object properties and all functions and methods except
// constructors

fistName = "John";

Use PascalCase (starting with uppercase letter) for constructors and TODO

// Always start with a letter (don't start identifiers with '_', '$' etc.).
// (except when using stuff from 3rd party modules of course)


Closures as function params
----------------------------

function doSomething
(
  firstParam,
  secondParam = function()
  {
    // ..
  }
)
{
 // If there is a body, it's formatted as usual.
}


Variables declaration
----------------------

// Declare each variable with separate 'let' and put it on a separate line.
// PS: Never use 'var', only use 'let' or 'const'.

let variable1 = 1;
let variable2 = 2;
let stringVariable = "It's cold here.";

// Don't declare like this: let varible1, varible2 = 3;


// You can also declare variable within cycle header like this:
for (let i = 0; i < tmpArray.length(); i++)
{
  // ...
}

// If you have a meaningful value for it, initialize variables at declaration.
// You don't have to initialize at all costs, however, like:
//   let stringVariable = "";
// This is because uninitialized variable have value of "undefined" so you
// can test it for (not) being initialized like this:

let x;
let txt = "x is initialized";

if (x === undefined)
{
  txt = "x is not initialized";
}

Update:
  With typescript strict checking and control flow analysis, it is now
perectly ok to do something like this:

{
  let message: String;

  if (something)
    message = "Some message";
  else
    message = "Other message";
}

If you specify the type of your variable, typescript won't let
you let it undefined - the code won't compile.



Naming conventions
===================

Getters and finders
--------------------

1) Don't ever declare methods named get() or set().

These are used in built-in typescript classes and get()
usually returns 'undefined' if an item isn't found.
  
We don't do that, we return named union type instead
(like (Entity | "NOT FOUND") so we shouldn't name our
functions 'get()' because readed would expect standard
javascript behaviour.

2) getters should always return exactly the expected type
   and throw an exception if it's not possible.

(By getters we mean both javascript getters like
 'public get something() {}' and c-style getters
 like 'public getSomething()'.)

Example:

class Blah
{
  private component: Component | null;

  // ! Throws an exception on error.
  public getComponent(): Component
  {
    if (!this.component)
      throw new Error("Attempt to get an invalid 'component'");

    return this.component;
  }
}

In this example, property 'component' can be 'null' (probably
because it cannot be passed to this class when it is instantiated
and needs to be assigned later) but method getComponent() is only
supposed to be called when'component' exists.
  Note that return value of getComponent() is (Component), not
(Component | null). This way whoever is using it doesn't have
to check for null value and can use it directly like.

let componentSize = this.getComponent().size;

Possible exception still needs to be handled somewhere of course.

3) findSomething() functions.

If you want to test for existence of something (usually an element
of the list) and return it if it exists in one function call, name
the function findXxx().

Such function should return union type like (Something | "NOT FOUND").