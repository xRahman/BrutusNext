TODO: Kromě mapy id -> prototypeObject potřebuju ještě
      className -> prototypeObject
(Protože chci tvořit instance hardcoded entit z kódu a nemůžu jako parametr
 předávat idčko.)
- blbnu, to tam samozřejmě už je.

Jinak:
- nechci implementovat prototype chain v rámci hardcoded class.
  Když chci instanci přímo hardcoded classy, tak bych měl udělat
  (Object.create(new Class)).instantiateProtperties();
  - to způsobí, že se na prototypu nainicializuje všechno, co je hardcoded,
    a instance to bude korektně dědit díky Object.create()
    a instantiateProperties().
  - Díky tomuhle postupu můžu korektně udělat instanci libovolné hardcoded
    classy
    - není možné kombinovat hardcoded classu se savem, ale to je asi ok
      ... vždycky můžu z hardcoded classy zdědit prototyp a ten savnout.
Ok, teď už jen musím nějak zajistit, že se z hardcoded classy dá zdědit
  editovatelná classa.
  - problém je přejmenovávání hardcoded class, proto jsem chtěl idčka.
    Kdybych totiž hardcoded předka odkazoval jménem, při přejmenování
    bych musel změnit tenhle odkaz ve všech přímých potomcích (no, asi by
    to taky šlo...)
  - idčka bych asi mohl držet stranou, třeba v tvrdém savu EntityManageru
    nebo ClassFactory.
    - savovala by se asi mapa <id, className>.
    - a v initu by se vytvářely hardcoded prototype entity prostě jako isntance
      daných entit.
    - při vytváření editovatelného prototypu by se idčko předka hledalo nejdřív
      v harcodedPrototypes a pak v EntityManageru.
  - stále by zůstalo automatické dogenerovávání idček pro nové hardcoded
    classy.

Stále taky zůstává, že se do prototypové instance hardcoded classy savují
  idčka editovatelných potomků
  - to znamená, že v hashmapě musí být nějaký savovatelný record.

---------------

- entity.load() použitá na the root prototype entitu jako prototype
  použije 'new Entity'.
 
---------------

TODO: The prototype Entity by měla mít prototypeId = null
- to má, protože to je defaultní hodnota.

TODO: Ostatním entitám je třeba nastavovat prototypeId.


TODO: ClassFactory.createInstance() stačí jen jedna.
  - jednak může poznat, jestli je potřeba vytvořit prototyp
    nebo instanci
  - a za druhé mi asi nic nebrání vyrobit při startu prototypy
    i pro classy, které nejsou entity.
Potřebuju umět:
- createInstance() podle ClassName (i když je to entita)
- createInstance() podle idčka
createInstance() se podívá do class
- když nenajde, tak se podívá do idček
(obojí povede na prototyp?)
Tak ne - mapu id -> entity přece nepotřebuju, ta už je v EntityManageru.
=> to znamená, že v ClassFactory mi stačí držet className -> instance prototypu
Algoritmus pro init bude:
1) V DynamicClasses.init se budou rovnou vyrábět instance prototypu
   - tak ne. Protože potřebuju rozhodnout, jestli je to entita nebo ne.
   - takže tady se pouze nastaví konstructory class, prototypové instance
     se z nic vyrobí až v ClassFactory.initPrototypes().
2) V ClassFactory.initEntityPrototypes se přidají entity do EntityManageru.
Algoritmus pro createInstance() bude:
1) mrkni do ClassFactory.prototypes
2) pokud tam 'prototypeNameOrId' není, tak to ještě může být idčko, takže
   mrkni ještě do EntityManageru.

ClassFactory.initPrototypes()
{
  if (isEntity)
  {
    let prototypeEntity = new Entity; // obecne new Class

    let prototype = EntityManager.createEntityFromPrototype
    (
      prototypeEntity,
      NamedEntity.Cathegory.prototypes
    )
  }
  else
  {
    let prototype = this.createPrototype(Class);
  }

  this.add(prototype);
}

public ClassFactory.createInstance(prototype)
{
  instance = Oject.create(prototype);
  instance.instantiateProperties();

  return instance;
}

public ClassFactory.getPrototype(className)
{
  return this.prototypes.get(className);
}

private ClassFactory.createPrototype(Class)
{
  prototype = new Class;

  return createInstance(prototype);
}

------------------------------------------

public EntityManager.createEntity(prototypeId, nameCathegory)
{
  let prototype = this.getEntity(prototypeId);

  let entity = this.createEntityFromPrototype(prototype, nameCathegory)

  this.proxify(entity);
}

public EntityManager.createEntityFromPrototype(prototype, nameCathegory = null)
{
  let bareEntity = ClassFactory.createInstance(prototype);

  bareEntity.setId(generateId());

  let proxy = proxify(bareEntity);

  if (nameCathegory !== null)
    setUniqueName(proxy);

  return proxy;
}

------------------------------------------

SaveableObject.loadCosi()
{
  className = loadFromFile();

  let prototype = ClassFactory.getPrototype(className);

  ClassFactory.createInstance(prototype);
}


TODO: Nahradit PrototypeManager.createPrototype() něčím aktuálnějším.

TODO: Savování prototypeId
  - a vytváření instance na základě prototypu při loadu

TODO: Savování/loadování class, které nejsou entity

/*
  Prototypy jsou regulerní entity, a to včetně prototypu "Entity'
  - jako osatní entity jsou v EntityManageru
  - jsou za EntityProxyHandlerem

  Hledat podle jména prototypu je ok, ale držet se musí vždy jen idčko
  - tj. v editoru můžu jako předka zadat "Character", ale do prototypu
    se uloží idčko získané přeložením "Character" na idčko.
*/

TODO: Budu potřebovat dvě varianty ClassFactory.createInstance():
  - createInstanceByPrototypeId()
  - createInstanceByClass()
 (protože ne všechny classy mají idčka - třeba takové Exits nemají)
 - přes createInstanceByClass() by se možná mohla vyrábět i THE prototype
   Entity  

TODO: Určitě přejmenovat NamedEntity na UniqueEntity
  - bude se to míň plést s NamedClass

TODO: Uppercasovat hodnoty v NamedEntity.NameCathegory
  - lowercasovat to až při savu/loadu
  - asi by se to taky mohlo jmenovat prostě NamedEntity.Cathegory 

TODO: Intantiovat taky Acconty, Connectiony a podobně
  (a nemyslím tím jejich properties, ale přímo Account. Zatím se to děje
   jen u GameEntit, protože ty jsou vždycky za nějakým dynamickým prototypem)
Tohle je komplikované. Znamená to:
1) v ClassFactory si nepamatovat konstruktory, ale prototypy (tedy instance).
   tj. nikoliv Account, ale new Account.
2) v ClassFactory.createInstance() nedělat new Account, ale
   Object.create(accountPrototype).
3) Při vytváření dynamických prototypů pak asi nebude potřeba setovat
   properties do Class.prototype, místo toho se budou setovat do
   classPrototype, který si drží ClassFactory.
- možná by se pak class Prototype nemusela překopírovávat do Entity,
  mohla by se umět savovat sama o sobě. A nebyl by důvod držet je
  v PrototypeManageru, když by si je držela ClassFactory...
  - plus funkcionalita na vyrábění (a savování) skriptů by asi byla
    v nějakém zděděném mezistupni
  Znamenalo by to, že kód skriptů by měla každá instance?
  - neznamenalo, byl by jen na prototypu.
SOUNDS GOOOD

  /*
    3 vrstvy:

    mergnute_prototypy (predkove)
          |
          v
    primy_prototyp
          |
          v
    Object.create(primy_prototyp)

    - v primem prototypu budou jen nezdedene, pridane properties
    - v mergnutych_prototypech budou nakopirovane properties z prototypu predku

    Kazdy prototyp by měl mít seznam mergnutých prototypů, které jsou z něj
    zděděné, a které je nutné přenenerovat při jeho změně.

    Přejmenovávání prototypů
    - správné řešení by asi bylo, neodkazovat se na předka jménem, ale idčkem
      (protože předek je entita)
    - problém je, že to pak bude špatně čitelné na disku...
    Asi by to znamenalo, že i prototype savy by byly pojmenované idčkem,
    stejně jako entity.
    - měla by to být unikátní jména. Takže možná prostě přidat kategorii
      "prototypes"?
    - pak mi zas zmizí ta interní struktura...

    Smazání prototypu
    - je možné, pouze když nemá žádné potomky
      (tj. je třeba nejdřív potomkům nastavit, že jsou zděděné z něčeho jiného)

    Přejmenování prototypu
    - prostě se změní classname, plus se musí přejmenovat adresáře
      v /prorotypes a dost možná i v /entities (pokud i tam bude struktura
      podle dědičnosti.

    Prototypy v entity manageru
    - pokud budou prototypy přímo entity, tak asi mohou být přímo
      v EntityManageru místo v ClassFactory
      (classFactory pořád bude muset držet dynamické classy z kódu)
  - tak ne, prototypy by přece jen měly být v ClassFactory.

    Adresáře asi mohou být skrupturované podle typů
    - díky tomu by mohlo jít celkem snadno přejmenovávat classy v kódu,
      bude k tomu stačit současně přejmenovat adresáře ve struktuře
      (v /entities a v /prorotypes)
      - top-level prototypy budou to, z čeho jsou zděděné brát ze jména
        nadřazeného adresáře
        (tj. když ancestors === [], tak to znamená, že hledám dynamickou
        classu se stejným jménem jako adresář.
        - respektive možná ne classu, ale prototyp stejného jména, ale
          s malým písmenem (account). To by znamenalo, že adresáře uvnitř
          struktury budou malými písmeny (i když dynamické prototypy asi
          ne...)
  */

Jak to udělat se jmény?
- když prostě zdědím PrototypeEntity z NamedEntity a setnu jí unique name,
  tak všechny vytvořené instance automaticky budou mít to stejné jméno...
  (leda bych to hacknul v createInstance()...)

IDEA: Kašlat na stringová idčka, použít reference
  - problém s loadováním z disku. Z adresáře si přečtu jméno typu,
    tj. pořád potřebuju ta jména. 

IDEA: Určitě používat UpperCase jména, protože dynamické prototypy by
  v lowercasu nebyly čitelné (leda by to byl camelCase). Není to název
  proměnné, je to klíč v hasmapě, takže to klidně může být přímo ClassName.

TAKŽE:
- jméno předka se bude brát z názvu adresáře, aby při přejmenování prototypu
  stačilo přejmenovat adresář.
  - předci se vůbec nebudou savovat - kurnik ne, to nejde, to by nešla udělat
    vícenásobná dědičnost.

- určitě používat idčka. Ideálně teda vyrobit "dummy" prototypy i pro
  hardcoded classy.

- nemělo by se savovat, jaké mám předky, ale jaké mám potomky. Díky tomu
  půjde lodnout všechny prototypy rekurzivně - jen musí existovat kořen.
  (PrototypeManager?)

ALGORITHM loadování prototypů:
0) Pokud při startu hry neexistuje save GameEntity, tak se vytoří.
   (seznam classNames se vezme z DynamicClasses, idčka se vygenerují)
   - asi by se měla automaticky updatovat, i když náhodou existuje.
1) Loadnu GameEntity 
   - ta má seznam idček hardcoded prototypů.
   - z /data/names/prototypes si přečtu příslušné classNames.
   - Vytvořím instance (přes new className) a loadnu je z disku.
     - v savech je seznam idček potomků.
2) Rekurzivně instancuju potomky (už ne přes new? I když vlastně asi
   jo, tohle jsou prototypy).
   - tak ne, musím to dělat přes Object.create(), jinak by se mi v každém
     potomkovi znovu vytvořily všechny inicializované proměnné předků.
     - čili prostě vždycky loadnu generický JSON object - ale ideálně
       do instance, kterou jsem vytvořil přes Object.create(ancestor).

Pozn: V savech kromě primary potomků asi budou ještě secondary ancestoři
 (tj. ne přímý ancestor, jen doplňkoví, jako třeba Shaman).
 - ono vůbec asi zní jako docela dobrý nápad ty secondary funkcionality
   nedědit přímo z Entity.
  


TODO: Změna prototypu
- kromě jiného bude třeba znovu zavolat instantiateProperties().

TODO: volat instantiateProperties() taky při vytvoření prototypu.

TODO: CONNECTION_ERROR message by asi neměly být prompt (končit mezerou).

TODO: Sjednotit statická volání EntityManager.doCosi() a nepřímá volání
  Server.entityManager.doCosi()
- možná by entityManager mohl být komplet statický?

TODO: Pojmenované listy (AccountList) by se mohly jmenovat prostě Accounts
  (sedělo by to pak s názvem proměnných: public accounts: Accounts)

TODO: Ještě jednou se zamyslet nad unikátními jmény
 (unikátnost by se mohla setovat už v konstruktoru, každopádně teda
  nezávisle na setName()...)
- teď už do toho asi vrtat nebudu.

TODO: Ještě jednou projít celý proces vytváření a loadování entit.

TODO: Checknout, že je první založený char creator.

TODO:
Syslog message "Player X entered game with character Y"
Syslog message "Player X playing character Y has left the game"


TODO: K "welcome" mesage v connection.enterGame() by měl bejt přilepenej
  look do roomu.
  - nebo teda aspoň bezprostředně následovat.

TODO: Posílat info o uncaught exceptionech do syslogu.
  (v BrutusNext.ts)

IMPORTANT:
  Při dědění z prototypu se údajně neinstancují non-primitive properties,
tj. když má prototyp např. array, tak všechny jeho instance referencují
tu samou instanci pole.
Řešení:
  Inicializovat datové properties v konstruktoru.
  - jinak řečeno, prototyp by měl mít konstruktor, kterej projde data[],
    udělá z nich kopie a nasetuje je insatnci, kterou vytváří.
  - na druhou stranu tohle pak nebude dělat to, že změnou prototypu se změní
    všechny existující instance...
TODO: Vyzkoušet to
 - fakt to tak je :\
TODO: Jediné "řešení", co mě zatím napadá, je zavolat Object.freeze() na
  všechny non-primitive property prototypu - pak nejde ani přidávat prvky
  do pole.
  - ideálně rekurzivně.
- hází to pak TypeError při pokusu takovou property měnit.
BIG TODO: Rekurzivně freezovat všechny non-primitive property na dynamických
  prototypech.
- tak nakonec ne. Lepší bude dát všechny vnořené objekty za Proxy.
TODO: Při inicializování dat prototypu udělat z vnořených objektů (tj.
  ze všech non-primitive properties) Proxy.
- chce to nový proxyHandler
  Proxyhandler vnořeného objektu bude mít v sobě:
  - referenci na entitu (respektive teda na prototyp), do které je vnořený)
  - jméno property, kterou představuje (respektive nejvyšší level, pokud
    je to víckrát zanořené).
  V set() trapě:
    - Přes jméno property checkne, jestli už je na instanci entity naalokovaná
      instance vnořeného objektu.
      - pokud jo, tak do ní rovnou zapíše
      - pokud ne, tak ji nejdřív naalokuje a pak do ní zapíše
- musím si pamatovat referenci svého nejbližšího nadřazeného containeru
  a jméno property v něm, abych mohl poskládat dereference chain (a tudíž
  setnout správnou property poté, co naalokuju kopii v instanci). 
- musím umět poznat, jestli ta reference vede na entitu, nebo na vnořený
  objekt.
  - instance už možná může mít referenci na nadřazenej container 'null',
    protože už nebude potřebovat ten chain zkonstruovat.
- musím umět poznat, že už instance existuje
  - to by asi mělo jít porovnáním referencí - dokud není instancováno,
    tak by reference měly být rovné. 
TODO: Alokování dynamických class
  - asi jen className a ne přímo reference na kostruktor classy, ať není
  problém, když někdo ten prototyp vytvoří znovu (i když, hrozí to vůbec?
  změny se budou dělat setováním na existujícím prototypu. Problém může být
  jen přejmenování - a to zapamatované jméno neřeší, špíš naopak komplikuje)

[18:53] Rahman       : <64> Hmm, tak zatim to vypada, ze se savem/loadem nebude
                            vubec zadnej problem, jen musim rekurzivne
                            instanciovat entitu pred tim, nez ji necham
                            naloadovat
[18:54] Rahman       : <64> rekurzivni instanciovani udelat to, ze proleze
                            property prototypu a rekurznivne vyrobi prazdne
                            objekty zdedenych z tech na prototypu
[18:55] Rahman       : <64> tj. pri loadu bud ten prazdny objekt uz bude
                            existovat a pak se do nej proste zapise
[18:55] Rahman       : <64> nebo existovat nebude, ale v tom pripade neexistuje
                           ani na prototypu (protoze jsem duplikoval vsechny
                           property z prototypu), takze je to proste vec,
                           kterou ma instance navic oproti prototypu a tudiz
                           ji staci proste vytvorit a zapsat do ni to, co 
[18:56] Rahman       : <64> je v loadnutem JSONU

IDEA: SaveableObject bude savovat jen own properties.
  - což by mělo být ok, protože když se do nějaké zděděné property něco
    zapíše, tak se z toho stane own property
    - ovšem to platí pouze pro primitivní typy
- to asi znamená, že bych měl všem SaveableObjectům při instancování
  instancovat jejich neprimitivní properties.

ÚVAHY:
- Prtotypy asi můžu taky vyrábět přes Object.create() místo new class ...


TODO: vícenásobná dědičnost prototypů


TODO: Zvážit savování enumů stringovou hodnotou místo intu
- mělo by to výhodu v tom, že se to nerozbije, když někdo přidá hodnotu
  doprostřed enumu (tj. posunou se intové values).
- asi bych to musel savovat jako IndirectValue, abych při loadu
  zjistil, podle jakého enumu se ta hodnota má dereferencovat (ze stringu
  na int).
    Na to bych ale asi musel umět dynamicky přistoupit na enum podle jména
    ve stringu.
    - jinak řečeno, musel bych přidat enumy do dynamicClasses...

TODO: Při zakládání nového charu to mockrát checkuje existenci name lock file.

TODO: Při zakládání accountu se existence name lock file checkuje dvakrát.
- poprvé když hráč zadá jméno accountu
    (tam je to asi nutné, protože je třeba rozhodnout, jestli se loguje
     na existující account, nebo zakládá nový).
     - i když, Linux se vždycky ptá rovnou na heslo a až pak ověřuje.
       (i když v Linuxu se zas nezakládá účet prostým přilogováním)
       každopádně by to asi šlo pozdržet a ověřovat až po zadání hesla. Jen
       by to asi bylo míň uživatelsky přítulné (že jsem se přesal v account
       name bych se dozvěděl až po zadání hesla... To je asi špatně).
- podruhé když se nový account zakládá.
    Je to tady nutné? Teoreticky ten check už mám hotový. Na druhou stranu
    když ho tu neudělám, tak se nedozvím, že přepisuju existující name lock
    file (a že je někde nějaká chyba).
=> Asi jsou fakt oba checky nutné.

TODO: V ChargenProcessoru po neúspěšném isNameAvailable() zřejmě
  chybí nový prompt.
  - testnout a případně opravit.

TODO: V AuthProcessoru bych asi měl rovnou v loginAttempt() načíst
  account a zapamatovat si ho.
- tím, že si pamatuju jen accountName se jednak několikrát provádí check
  na unikátnost jména
  - a navíc se může stát, že než zadám heslo, tak někdo založí ten samý
   account a mě to pak failne.
Když založím account rovnou, tak tím zároveň vytvořím lock.
- na druhou stranu by asi bylo fajn mít aspoň nějakou DOS protection,
  tj. ideálně nezahazovat account hned (při nepovedeném hesle, shozené
  lince, atd.), ale až po nějakém timeoutu.
(druhá možnost je, udělat si ten lock v paměti. Tj. někde zaregistrovat,
 že se někdo snaží přihlásit pod daným jménem...)
 - buď je account online (někdo se reloguje), pak není co lockovat
   (ale možná by bylo dobré si pamatovat rovnou ten account místo accountName)
 - nebo online není, pak je třeba vyrobit lock
Ok, udělám si lock v paměti (hashmapou se jmény accountu - respektive asi
  spíš setem).
  - odstranit ho je třeba v okamžiku, kdy se vyrobí lockFile, případně když
    se closne connection.

TODO: Jelikož mám soft lock na accountName, tak už nemusím znova checkovat,
  že je volné, když vytvářím account.
  (na druhou stranu to se možná dělá automaticky...)

IDEA: Místo NamedEntity (createNamedEntity(), atd.) používat
  UniqueEntity (createUniqueEntity).

TODO: settings.ts možná hodit spíš do rootu projektu, než do ./src
  (a možná by to měl být spíš settings.json)


TODO: Misto Message.Type.AUTH_ERROR zavest SYSTEM_ERROR
  (ať nemám 20 různých druhů error messagů)
  - tak ne SYSTEM_ERROR (to už existuje), ale CONNECTION_ERROR.

BIG TODO: Vícenásobná dědičnost prototypů (a možná i hard codu, viz:
  https://typescript.codeplex.com/wikipage?title=Mixins%20in%20TypeScript)
Implementation: Nedělat dědičnot nastavením prototypu svému prototypu, ale
  zkopírováním všech properties z předků do svého prototypu.
  - Znamená to bohužel, že při každé změně libovolného prototypu bude potřeba
    updatnout všechny prototypy, které jsou z něj zděděné.

TODO: Zkontrolovat, že connection.close() dealokuje
  vše, co má dealokovat (odebrat account z listu, etc).
- asi jo...

TODO: Přejmenovat všechny 'filePath' v SaveableObjectu (a asi i jinde)
  na 'path'.

TODO: Nepoužívat Map<any, any> (což je implicitní, když napíšu
  jen newMap()), ale konkrétní typy.
  - tím mi zároveň odpadnou z commentu.

ÚVAHA: /data/entities by možná mohly mít strukturu podle struktury světa,
 tj. world/realms/areas/rooms etc.
- když bych chtěl dejme tomu statnout nějakej offline room (může to vůbec
  nastat?) tak mu prostě dám tuhle celou cestu. 

TODO:
  - ne všechny entity v rámci worldu by měly mít unikátní jména.
    Třeba roomy by nemusely.
Hmm, to bych asi měl nějak ošetřit na úrovni prototypu - jestli setName()
  setne unikátní jméno nebo ne (čili možná cathegory nesetovat v rámci
  setName, ale v konstruktoru/deklaraci?). 

TODO: getSaveDirectory může vrátit null
  - obecně při vytváření cesty nemá smysl dělat něco jako "INVALID_SAVE",
    protože by se mi stejně přepisovaly entity přes sebe.

IDEA: Množení referencí by šlo ještě vyřešit tak, že isValid() nebude
  automaticky obnovovat referenci - tj. bude to nutit k tomu, vždycky
  si od Entity manageru vzít novou referenci, když ta stará přestala
  být valid.
  - To je asi rozumné řešení, protože automatická validace dotazem na
    isValid() není zrovna intuitivní - zahlásí mi to chybu na invalid
    přístup, já si pak na stejné místo dám isValid() a ono se to najednou
    bude tvářit jako validní reference.
Výhledově by samozřejmě stále bylo fajn, kdyby to šlo pořešit úplně
automaticky a reference zachovávaly identitu, ale dokud to nepůjde, tak
je asi nejlepší řešení prostě jen hlásit invalid reference jako invalid
a nechat na uživateli, ať si je sám updatne na aktuální, když to potřebuje.

TODO: Handle file operation return variables in SaveableObject.

TODO: Sjednotit FileSystem
 - buď tam házet FATAL_ERROR
 - nebo hlášku do syslogu a vracet boolean
určitě ale neházet hlášku do syslogu a pak vyhodit exception, od toho
je fatal_error.
- ideálně asi vracet ten boolean (obecně by měl mud být co nejodolnější proti
  crashům).

TODO: Projít všechno zděděné z Entity a odstranit zbytky staré
  adresářové struktury

TODO: Rozhodnout, co se bude savovat v accountu (idčka?, jména + další info?)

TODO: Projít save()
  - u named i generic entit.

TODO: Zkontrolovat, že celý chain používající FS.exists() je async.

TODO: V rámci EntityManager.loadNamedEntity() je třeba přidat entitu
  do EntityManageru.

Entity.load() nemusí umět číst unique name soubory - entita vždycky zná
  svoje idčko.
Entity.save() musí umět savnout unique name soubor, protože když se změní
jméno entity, musí se změnit tenhle soubor.

V Accountu nesmí být přímo jména charů.
- protože když přejmenuju entitu, tak by odkaz z accountu přestal fungovat.
  - když tam budou idčka, tak je to v pohodě.
To ale znamená, že account bude muset při loadu načíst všechny chary
  - minimálně do té míry, aby z nich mohl přečíst jména (aby je mohlo game menu
    vypsat hráči a aby se hráč mohl loadnout s konkrétním charem.)
- možná bych mohl vyžadovat, že přejmenovat char jde jen s online acocuntem
  (tedy je to metoda accountu, pak by v accountu mohla zůstat jména...)

IDEA: V menu bych možná mohl vypsat víc informací o charu. Což ale zase
  znamená, že bych buď musel všechny ty chary načíst (aspoň do JSON objectu),
  nebo si to info pamatovat v accountu (stejně jako jméno charu).
  - ovšem věci jako level se potenciálně mohou měnit i když account nebude
    online (offline reward za questy třeba?)....

Moc to komplikuju, podrobnější info o charech v accountu teď rozhodně
implementovat nebudu - není to zásadní pro prvotní hratelnou verzi.
(ale počítat bych s tím mohl...)

----------------

TODO: Přibyla static metoda Entity.isValid(entity);
  - použít ji všude, kde dává smysl ji použít.

TODO: Předělat všechny async fce, které by mohly vracet hodnotu, ale nevrací,
  protože jsem si myslel, že to nejde.

/// TODO (ClassFactory.createInstance()): Typecast.name nemusi existovat
///   (u dynamicky vytvorenych class, coz jsou vsechny prototypy).
/// - nebo mozna jo (mohlo by to byt v NamedClass nějak ošéfované)?
      Zkontrolovat
      - tak není, je tam jen className. takže TODO (opravit to v ClassFactory)

TODO: Nesavovat property 'id'
  - id bude vzdycky dano jmenem souboru.

TODO: Nesavovat typ odkazované entity do objektů, ze kterých je odkazována
  - protože pak nepůjde měnit typ entit (savnuté odkazy by se pak loadovaly
    špatně).
- místo toho savovat jen stringId, podle kterého se načte soubor (do
  generického Objectu, takže v pohodě), z něj se přečte className a až podle
  něj se vyrobí instance.
- problém bude s Accountama, Worldem a podobně, kde nejde z idčka odvodit
  cesta k save filu.
  - Obojí by asi šlo odvodit z jména...
Takže:
- odstranit className z id recordu v savech
- charactery savovat nadvakrát. V /data/characters budou soubory pouze
  s idčkem (tj. bude se tím překládat jméno na idčko a bude se tím kontrolovat,
    že je jméno unikátní)
Asi bude nejlepší udělat to úplně jednotně, tj.:
  - všechny uniqueNamedEntities budou mít soubor v adresáři data/uniqueNames
    - v něm budou podadrešáře (/world, /account, /character), unikátnost
      bude per adresář (což zajistí prostě to, že to budou soubory v adresáři).  
    Tyhle soubory budou obsahovat pouze idčko...
...
Hmm, už vím, na co jsem potřeboval typ v id recordu - bez něj nedokážu
  zkonstruovat adresář, do kterého se to savuje. Musely by být všechny entity
  v jednom adresáři
  - vadí to něčemu?
    Nebude to tak přehledné na disku, nepůjde třeba jednoduše prohledat jen
    všechny moby...
...
Ze hry budu chtít dělat:
  stat file Zuzka
  stat file account Rahman
  načtení accountu při logování do hry (podle jména accountu)
  pejmenování charu (takže by asi jména charů neměla být přímo v accountu) 
...
- asi bude nejlepší nesavovat vůbec entity.name do hlavního souboru,
  - to je blbost, protože bych pak nedohledal jméno čistě na základě idčka.
Nedá se nic dělat, jméno musí být na dvou místech.


TODO: Zařídit, aby se šlo na jeden account lognout s vícero connectionama
  aby do hry šlo vlézt s jedním mortalem a vícero immortalama či testplayerama.

TODO: Savovat Server
  (zatim kvuli MOTD, ale možná přibudou i další properties na savování).
  - možná ne celý server, ale jen do něj vložit SaveableObject?

TODO: Přejmenovat Connection.receive() na něco jiného (něco ve stylu
  sendAuthPrompt v authManageru) - a nastavovat msgType až uvnitř téhle
  metody.
  (neměla by to být obecná metoda na posílání messagů connectionu).

IDEA: Možná to s messagama udělat trošku jinak:
  - místo GameEntity.receiveMessage, Game.sendCosi, AuthProcessor.sendCosi atd.
    udělat statické metody do Message. Takže půjde psát např.:
    Message.sendToConnection(connection, text, msgType, sender);
    - statická metoda prostě založí new Message() a pošle ho.
sounds goood

TODO: Server možná zpřístupňuje věci, které by mohly zpracovávat
  metody Serveru. 

TODO: V LobbyProcessoru predelat menu
- po zalozeni accountu tam bude:
     0) Quit game
     1) Create new character
- po zalozeni prvniho charu tam bude:
     0) Quit game
     1) Enter game as Zuzka
     2) Create new character

TODO: Projít celý kód a ze všech protected funkcí, které nemusí být
  protected, udělat private.

TODO Po promotu/demotu savnout AdminList.

TODO: Co když je imm do něčeho switchnutý?
  - asi se mu budou message bufferovat, podobně jako když je LD, a vypíšou
    se, když se odswitchne.

TODO: Předělat posílání všech stringů ve hře, aby používaly Message.

TODO: Vyzkoušet save/load Admins

TODO: Promotovací a demotovací syslog hláška a info.

TODO: Automatické přidávání (a případně i žraní) tečky na konci věty.
  - automaticky ji přidávat za text v příkazu send(), pokud tam není.
  - automaticky ji žrát z ERROR stringů.

IDEA: Pouze admin charactery mají private referenci na admins: Admins
    (důležité je, že je ta reference private v třídě GameEntity, takže
    potomci se na ni nedostanou přímo, ale pouze voláním existující metody)
  - Metoda udělá co:
    - zavolá this.admins.doSomething(this, action, params);
  + server má 'admins: Admins;' taky jako privátní proměnnou.

TODO: Nastavit idčko v entitě jako immutable property.

TODO: Immlevely ukladat nekam jinam nez k charu
- (asi do AccountManageru?)
TODO: Udělat na to classu Admins
  - instance v Serveru nebo v Game? Asi v serveru, protože práva se týkají
    i serverových věcí. 

TODO: Loadovat chary do konkrétní roomy.
[To je tak napul. Rahman ma nastavenou 'location', Zuzka ne a nove zalozene
chary taky ne]

TODO: Když se zakládá první character, udělat z něj implementora a dát ho do
  SystemRoom.
  - možná se bude hodit držet si systemRoomId ve Worldu jako proměnnou.
[jakz takz]
- Zatim spis nejakztakz
TODO (stále)

TODO: Zkontrolovat, že dobře loguje BAD PW attempt

------------------------------------------------------------------------------

TODO: Zvážit, jestli by stack tarce nešel získávat elegantněji než z error
  objectu, viz:
 using System.Diagnostics;
 StackTrace st = new StackTrace();
 Console.WriteLine(st.GetFrame(1).GetMethod().Name);

TODO: Sjednotit styl, jakým se píšou Enumy (asi na ten z Message.ts, protože
  potřebuju typ používat v jiných modulech).

TODO: Vyzkoušet, co se stane, když savnu objekt s invalid referencí
  (hráč třeba odlognul).
  - mělo by se savnou idčko.

TODO: Z invalid reference by asi pořád mělo jít vytáhnout idčko,
  name a className.
  - tzn. trapovat přístupy na tyhle fce/proměnné.

TODO: Vyzkoumat, jak je to udelane, ze v putty neni pri zadavani videt heslo

TODO: Do zahlavi souboru nakreslit stromy dedicnosti.

TODO: Udelat tridu Command, do ktere se vrazi cely command string, a ktera
  s nim bude umet pracovat (parsovat argumenty, atd.)
- Tohle je otazka. Koukal jsem na to a mozna to neni az tak dobry napad,
  v ruznych situacich se command parsuje ruzne (kazdy skill to muze delat
  jinak, napr.)

TODO: Zkontrolovat, ze datove properties, ktere maji get i set a pri
getu a setu se s nima nedela nic vic nez prirazeni a cteni, jsou rovnou
public.

TODO: Ve vsech classach hodit data na zacatek.

TODO: OLC

TODO (výhledově): Dodělat do AbbrevSearchListu funkčnost, že dokud je v něm
  málo záznamů, tak se vůbec nebude konstruovat vyhledávací struktura, prostě
  se lineárně projde pole aliasů (to proto, aby se zbytečně nezabírala paměť
  vyhledávací strukturou pro pár mobů v roomě, pát itemů v inventáři, atp.)

TODO: Otestovat AbbrevSearchList
  - pridat do nějakého roomu pár characterů
  - implementovat příkaz tell (globální search)
  - implementovat nějaký social do roomu (search v roomu)

TODO: Zprovoznit příkaz na založení nové entity (na Brutusu se tohle děje,
  když dám editovat dosud neexistující objekt)

TODO (hodně výhledově): Zajistit, aby se ze skriptů nedal nastavovat
  Account::adminLevel a nedaly dělat věci, na které je třeba adminLevel > 0.
  (viz ./documentation/code_architecture/admins)

TODO: Zprovoznit prikaz look (zatim asi jen do roomy)
[kostra by snad byla]

TODO: Používat 'new Map' místo 'new Object' (hlavně proto, že dynamicky
  generované klíče mohou kolidovat s existujícíma properties na objektu).
  - vyzkoušeno a přidáno do Saveableobjectu
TODO: Udělat to všude

TODO: Všude, kde se to hodí, předělat předávání parmetrů. Předávání objektem
  dělá kód mnohem čitelnější .
  - tímhle si nakonec nejsem až tak jistej.

TODO: Zvážit, jestli nepřejmenovat všechny proměnné typu newArray (zrušit new).

TODO: Optimalizovat savovani prototypu, kdyz se zmeni jen jeden prototyp
  (takze neni treba savovat uplne vsechny prototypy)
  - mozna metodou Prototype::save(), ktera zavola save prototypeManageru
    na konkretni prototyp?

TODO: Pokusit se sjendotit dynamic typecast (metodou z UTILS?)
  - ideálně ji přesunout někam jinam (někam do entity inheritance chainu)

TODO: Projít všechny FATAL errory a zkontrolovat, jestli musí být FATAL.

IMPORTANT TODO: U prototypu savovat jen přetížené properties, ne ty
  z prototypu.

TODO: Velmi výhledově se zamyslet nad lepším formátem savutých skriptů
  (hjson? samostatný soubor?), protože je to přece jen kód a bude se
  například diffovat v gitu (co na něm který immortal změnil?)

TODO: Casem odstranit consoli ze skriptoveho sandboxu.

TODO: Checkovatko na memoryleaky

TODO: Kontrola, že skript dostal správné parametry.
  - A to ve fci Script.scriptFunction (deklarovane v constuctoru classy Script)

TODO: Nastavitelný Lock proti opakovanému spouštění běžícího skriptu.

TODO: script.recompile

TODO: script.rename (nebo možná Prototype.renameScript)

TODO: Asi všude zrušit property deklarované jako parametry konstruktorů
  (ne vždy se konstruktor volá se všemi parametry a pak se stane to, že
  property není inicializovaná. Kromě toho to znepřehledňuje kód - hůř
  se hledá, co je nějaká property zač.)

TODO: Ještě jednou zvážit typescriptové enumy (Entity.satus, atpod.).
  - použít se dají (je třeba je deklarovat mimo classu a a do classy je pak
    dát jako static proměnnou).
TODO: Projít kód a zvážit, kde by se spíš hodil enum.

TODO: Typescript používat inline místo linkem.

TODO: Odstraněním saveTree z PrototypeManageru jsem přišel o informaci, jaké
  prototypy se mají načíst při startu hry.
  - nějak to pořešit.
Jedna možnost je, prostě prolézt celý adresář /Prototypes

TODO: Při loadu game entity kontrolovat, že savnutá 'location' (její stringové
  idčko) odpovídá tomu, do čeho entitu loaduju (stejné stringové idčko).
  - pokud neodpovídá, tak odmítnout entitu přiřadit
    (Tohle ošetřuje situaci, kdy se jeden player savne, dá item druhému
    playerovi, ten se savne a následně spadne mud. Tomu prvnímu to při loadu
    item nedá, protože nebude sedět location. Tomu druhému load projde.
    - to samé platí i pro restorování ze zálohy.)

TODO: Classu EntityRecord asi vyhodit z EntityManageru do samostatného
  modulu.

TODO: V SaveableObjectu (a možná i jinde) předávám do vnořených volání
 hromadu stejných parametrů.
 - zabalit je do objektu 'param', dost se tím ten kód zpřehlední.

TODO: Výhledově přesunout některá nastavení z workspace settings (ve VS code)
  do user settings. User settings by to ale pak asi chtělo přidat do gitu,
  ať je mám vždycky po ruce. 

TODO: Pokud budu implementovat EditableObject (jako že asi jo), tak
  ho nejspíš přesunout ze /shared do /editor

TODO: Zkontrolovat, že všude, kde něco dereferencuju, je to oifované
  (zejména v SaveableObjectu).

TODO: V SaveableObjectu sjednotit jména parametrů, aby to nebylo jednou
  'myProperty' a podruhé 'variable', když obojí znamená totéž.

TODO: Úplně se mi nelíbí, že fci entityManager.createUniqueEntity()
 (a asi i createEntity()) dávám jako parametr stringovou reprezentaci
 typu a za ní ještě typ.
 - asi by bylo lepší udělat dvojice fcí, jedna (createDynamicEntity()?)
   co dostane i string a druhá, která si vystačí s konstruktorem classy.
   - nebo možná dát string jako volitelný parametr (kontrolovat to uvnitř
     funkce).
Jo a při tý příležitosti bych asi mohl udělat statické fce, abych nemusel
chodit přes Server.entityManager....
  (a nebo se na to vyprdnout a dělat to naopak vždycky, tj. zrušit tu
  existující statickou zkratku)

TODO: Sjednotit návratové hodnoty: Když něco není nalezeno, tak nevracet
  null, ale undefined
TODO: Zrušit z entity proměnné SAVE_DIRECTORY

---------------

Úvahy o hot reloadu
  - nakonec asi bude nejjednodušší udělat si to růčo, podobně jako
    save/load. Nejspíš tak, že se po reloadu modulu vytvoří instance
    příslušné entity a všechny existující entity v game entity containeru
    si vždycky najdou svůj nový "prototyp" (nejspíše podle className),
    projdou všechny svoje properties (jdou projít i metody?), metody si
    přiřadí ty z nového "prototypu", existující property si nechají
    (možná zruší ty, které na novém "prototypu" nejsou) a přidají ty, co
    má nový "prototyp" navíc - zkopírováním, takže budou inicializované
    podle nového kódu.
  - reload proběhne automaticky, protože poběží watch na změny příslušných
    souborů.


------------------------------------------------------

Vyhledove rozbehat tslint

===============================================================================

TODO: loadAccount v AccountListu a loadCharacter v CharacterListu
  jsou téměř totožné fce - nějak to sjednotit.
[done]

TODO: To, že se player disconnectuje přes connection.quitGame(), není
  zrovna intuitivní. Mělo by se to dělat přes connection.disconnect()
  (nebo close()).
- zavírat přes connection.close().
[done]

TODO: Rename named entity - musí přesavovat soubor v /data/names
 - viz class NamedEntity
[snad done]

TODO: V class Entity:
  - setId() by mohlo checkovat, že id je null a nepovolit setnutí, pokud není
    (tzn. id by bylo "write once").
[done]

TODO: Za všechny message přidávat defaultní "ukončovací" barvu
- a to proto, že tak bude obarven player input (a ten by asi měl
  mít vždycky stejnou barvu).
[done]

TODO: World má sice reference na vybrané entity, ale ty entity v něm
  nejsou vložené (respektive Realmy v něm nejsou vložené, ten zbytek
  zas rekuzivně do svého nadřazeného konteineru), takže se nesavujou.
[done]

TODO: Možná založit classu na unikátní jména - UniqueNames
  - bude umět checknout existenci souboru v příslušném adresáři
  - bude mít enum s kategoriemi (v NameSearchListu to fakt není
    moc intuitivní).
[done]
TODO: Někde se checkuje unikátnost jmen -> přesunout to do classy
  UniqueNames
- V character listu se to checkuje (metodou existsSync()).
[nakonec je to jinak, dělá to přímo NamedEntity]

IDEA: vykašlat se na flagu isNameUnique, savovat pouze cathegory.
- když je cathegory null, jméno není unique.
[done]

TODO: Možná unikátní jména dávat do adresáře /data/names/
[done]

TODO: SaveableOject, bufferování requestů
  - mělo by to být tak, že saveToFile() se vrátí až poté, co je skutečně
    savnuto (a ideálně poté, co je savnut její request, ne až když se
    dosavují úplně všechny, co přišly v průběhu savování).
- jak to udělat?
IDEA: Každy si savne svůj vlastní request (a jen ten jeden).
- pokud je nějaký request v bufferu, tak musím dát do fronty
  svůj resolve callback, abych dostal slovo, až na mě dojde řada.
CONSIDERATION: Deduplikovat requesty ano, ale pouze ty, které se
  ještě nezpracovávají. Aktuálně zpracovávaný request je třeba zopakovat,
  kdy přijde ten samej, protože se mezi tím mohou změnit data, která se
  mají savnout.
IDEA: Možná by se save procesy měly registrovat globálně. Teď spoléhám
  na to, že se každý SaveableObject savuje do jiného souboru, ale to nemusí
  být 100%
ALGORITHM:
1) Checknu, jestli je cílový soubor v globálním registru právě savovaných
   souborů.
   - pokud ne, tak se zaregistruju, savnu, odregistruju.
   - pokud ano, musím svůj request přidat do globálního bufferu
     (deduplikace, ale pouze u requestů, které se ještě nezačaly savovat)
globální saveProcessBuffer bude hashmapa.
  klíč: savePath
  value: true/false? Možná taky odkaz na následující save proces.
[done]

TODO: Použít classu Reference na savování entity referencí.
[done]

IDEA: classu MapRecord přejmenovat na Hashmap.
- možná něco podobného i s Date record... (ale co?) DateObject?
- DateRecord asi nakonec není úplně zlé (když to Date být nemůže).
[done]

TODO: Na savovaní Entity Reference taky udělat samosatnou classu.
  (jako DateRecord nebo MapRecord (asi Reference?)).
[done]

IDEA: classy Map a Date by se asi neměly do JSONu savovat přímo svou
  primtivní reprezentací (tj. string, respektive array), ale jako Object
  s nějakou className).
Důvod: Půjdou pak loadnout i do null proměnné, protože typ půjde poznat
  z JSON objectu.
[done]

TODO: Sjednotit metody TelnetSocketDescriptor.normalizeCRLF
  a Message.normalizeNewlines (asi do Utils)
[done]
TODO: Sjednotit taky konstantu NEW_LINE
[done]

TOODO: Vyházet debugovací spam z logu.
[done]

TODO: Message by asi neměly začínat na '\n'
  - odřádkování by se mělo řešit v Message.compose().
[done]

IDEA - jak řešit MOTD:
  - metoda getMotd() prostě jen vrátí obarvený string s motd,
    který se pak z různých míst pošle různě.
    - hra ho pošle jako Message.Type.COMMAND
    - AuthProcessor za něj (nebo možná před něj přilepí) last login info
      (taky getLLI() a taky pouze string) a pošle to celé jako
      Message.Type.LOGIN_INFO
[done]

TODO: Z enmumů v AuthProcessoru, LobbyProcessoru a možná i Connection
  vyhodit hodnotu INITIAL a místo ní používat 'null'.
[done]

TODO: Možná by stálo za to přesunout MessagePart.Type do Message a říkat jí
  Message.Type a původní MessageType přejmenovat na Message.Cathegory.
  - sice to bude trochu matoucí v rámci implementace MessagePart a Message,
    ale bude to možná dávat vštší smysl při použití zvenku (a hlavně bude
    stačit includovat Message).
A nebo se na MessagePart vykašlat úplně.
  - což dává smysl i vzhledek k pojetí base color, kdy je to první barva
    v odesílaném packetu a vztahuje se na celý packet (každý message se nakonec
    odešle jako celý packet).
  => odpadne mi separátní obarvování exitů a tak.
- MessagePart je komplet zrušeno.
[done]

ÚVAHA: Potřebuju vůbec k něčemu MessageType? Teoreticky na filtrování
  celých messagů, třeba jestli chci vidět gossip.
IDEA: Udělat to šalamounsky:
- Základ bude MessagePart.Type
  - tady budou všechny možný typy message partů
- Message.Type budou:
  - buď celé kategorie jednopartových messagů (např. COMMUNICATION)
  - nebo jednotlivé vícepártové message (třeba who)
- nakonec je to všechno v Message
[done]

TODO: Barvy messagů přesunout do nějaké samostatné struktury, ideálně
  i do samostatného modulu (MessageColors.ts).
  - pořád se budou indexovat message typem
  - getovací metody, dostanou messageType a coloredSectionType
    ("base", "quotes", etc.)
    - zaindexuje to message typem, checkne to, že existuje property
      příslušného jména, vrátí to barvu (nebo defaultní barvu, když něco
      failne).
[done]

TODO: Šaškování s promptem přesunout z Connection do Message.
- bude se vůbec nějakej message posílat jinak než jako prompt?
  - multipart message totiž asi řeší kusy, které se jako prompt neposílají.
[done]

TODO: Zrušit color kódy z AUTH_PROMPT messagů, přidávat je až v classe
  Message.
  - částečně done. Z messagů jsou zrušeny, ještě se ale nepřidávají
    v Message (respektive MessagePart.format().
KE ZVÁŽENÍ:
  Tohle je ve skutečnosti otázka. Určitě nepůjde obarvovat komplet všechno
  až uvnitř Message, to by se musely používat nějaké symbolické názvy barev
  (což by teda šlo, třeba něco jako <color:TELL.quotes>). Pokud ale budu
  stringy obarvovat tam, kde se vyrábí (a brát si barvy z MessageColors),
  tak pak moc nedává smysl přidávat base color až uvnitř Message (i když,
  ušetří to obarvování syslogu a podobných jednobarevných messagů, takže to
  asi smysl má, hmm...)
OK, asi to nakonec nechám tak, jak to mám. BASE color se bude přiřazovat
  automaticky v Message, interní barvy se budou dávat do stringů tam, kde
  se vyrábí stringy.
  - potom ale nepůjde přebarvit už jednou vyrobený string podle nového barevného
    schématu, hmm.
  - když bych někdy chtěl dělat lokalizaci, tak barevné kódy (ať už přímo
    kódy barev nebo nějaké symbolické varianty) budou muset být součástí
    překladových stringů. Na druhou stranu překladové stringy je taky třeba
    nějak skládat do sebe a ty skládací algoritmy musí být v kódu, takže
    možná dává větší smysl mít barvy jako součástí těch skládacích algoritmů
    a za překladové stringy pokládat ty malé jednobarevné kusy, ze kterých
    se message skládá...  
[done]

TODO: Zautomatizovat přidávání mezery za prompt mesage.
  - asi v Message.composeRawMessage().
[done]

TODO: Connection bude mít public metodu send(), která bude jako parametr
  chtít Message (aby se nedalo volat connection.send() přímo).
  - ta pak zavolá message.getRawText().
[done]

TODO: Asi přejmenovat MessagePart.format na MessagePart.addBaseColor()
[done]

TODO: Zavést color code pro message_base_color (aby se dala měnit barva
  celé zprávy s tím, že to zachová barvu zvýrazněných slov).
[done]


TODO: Syslog by se měl posílat charům (které na to mají admin level)
[done]

TODO: Řešit jinak single-part a jinak multi-part message, minimálně
  teda při vytváření. Volat na single-part messagi extra addMessagePart()
  je opruz.
  - asi to oiffovat v konstruktoru, že parametr 'text' je volitelný.
    (nebo možná volitelný parametr messagePartType).
- hlavně bych chtěl vyhodit partType SAME_AS_MESSAGE, což bych asi udělal
  přesunem textu u jednopartového message přímo do message. Ale pak by mi
  zas chyběla metoda format(), hmm. 
[done]

TODO: Static metoda Server.getAdminLevel();
  - metoda serveru a ne entity, aby si ji entita nemohla predefinovat
    a vracet creatora ;-)
[done]

TODO: Visibility dává smysl jen u sendToAllIngameConnections
[done]

TODO: class Admins by se asi měla jmenovat spíš AdminList.
[done]

TODO: Je dobrý nápad nastavovat messagi target?
- možná by bylo lepší prostě zavolat příslušnou metodu
  (sendToConnection(), sendToGameEntity(), sendToAllInRoom(),
   sendToShoutingDistance(), sendToAllInGame(), SendToAllConnections()).
  - v těhle funkcích se pak případně může zapamatovat, komu jsem to
    posílal a tak.
[done]

TODO: Kdo bude sender u Syslog messagů? Standardní message se filtrují
  podle visibility sendera...
  - možná přiadat do sendu parametr reciever_level s defaultní hodnotou
    MORTAL?
    (možná jen do plošných sendů. "Tady máš message speciálně pro tebe, ale
     nemůžeš si ho přečíst, protože na to nemáš admin level" je asi blbost :-))
- sender bude null.
- visibility už jde messagům předávat (ale nekontroluje se ;-)).
[done]

TODO: Chekovat u messagů visibility.
[done]

TODO: Funkce Entity.send(sender, string) by přece jen mohla existovat,
  interně vyrobí Message a pošle si ho.
[done]

IDEA: Založit class Message
  // Asi by mel existovat nejaky anonymni sender (system? nebo world?)
  - sender
  // muze jich byt vic
  // nemusi byt inicializovane hned od zacatku
  - recipients
    // TELL, GOSSIP, SKILL, COMMAND
    // Podle typu se bude obarvovat a gagovat.
  - type
Proč?
  Protože si je pak můžu házet do bufferu (takže budu mít historii),
  a buffer různě zpětně filtrovat
message.send()
  - tj. nepoužívalo by se sendToChar() ani char.send(), ale vždycky
    message.send().
message.format()
  - něco jako act() na Brutusu
- Je fakt, že tímhle můžu dost šetřit paměť, nemusím mít u každého
  playera zkopírovnaé každé INFO, můžu to mít na jednom místě jako
  Message a v playerově messageHistory na něj mít pouze odkaz.
- budu se moct zpětně podívat, kdo psal message v době, kdy jsem měl
  blind (je teda otázka, jestli je to žádoucí featura, ale půjde to.
  Jo a taky je otázka, jestli by blind měl mít vliv na to, co SLYŠÍM ;))
  (I když vlastně já to slyším, jen nevím, kdo to řekl. No...).
[done]

TODO: Metoda Game.sendToAll()
  - to samé co u sendu (na druhou stranu info je asi vždycky info?)
  - možná ne Game.info, ale game.send(message, INFO);
  Pozn: Procyklovat přes všechny connection, nikoliv přes všechny herní
    entity (nemá smysl procházet entity, kterým se nic posílat nebude).
[done]

TODO: Metoda send()
  - nebude to sendToChar(), protože posílat string jde kde čemu, ne pouze
    charům.
  TODO: Zvážit, jestli by by to nemělo bejt nějak oflagované, aby se to
    podle toho dalo třeba gagovat nebo automaticky obarvovat.
    - asi určitě ano.
nakonec existují metody:
  sendToSelf()
  receiveMessage()
[done]

TODO: Možná parametr 'type' u Messagů přejmenovat na 'msgType'.
[done]

TODO: Syslog má nějaký msgType a Message má type. Možná by se to dalo Sloučit
  (pod Message.type, protože to je obecnější).
[done]

ÚVAHA: Má smysl pamatovat si seznam entit, kterým jsem poslal Message?
- Když mi lidi odejdou z roomu, tak posílat jim ten samý vzkaz (vázaný na room)
  už nebude dávat smysl...
- asi je to blbost, message se prostě pošle všem valid targetům v okamžiku
  volání message.send() a zapomatuje se jen co se posílalo, ne komu.
- Každý recipient si bude své message dávat do své vlastní historie, takže
  'this' bude recipient při jejím parsování.
  - pokud bych si chtěl pamatovat například visibilitu v okamžiku poslání
    zprávy, tak si ji musím uložit asi do té historie, mimo vlastní Message
    (protože Message je sdílený záznam pro všechny, kdo jej dostali).
TODO: Zrušit Message.recipients.
  - Komu se pošle tell? Na to se asi přece jen bude muset recipient nastavit.
[done]

TODO: Přidat do accountu seznam charů, které mají admin práva (nebo možná na
  char flagu, že má admin práva - checkne se this.playerConnection, přes ni
  account a na něm je adminLevel).
[Tohle bude jinak - pres classu Admins]

TODO: Charactery savovat na disk v lowercasu
  - ze dvou duvodu:
    1) aby neslo vytvorit soucasne char Zuzka a zuzka
    2) aby se slo prihlasit case-insensitive verzi
  - nebo se na to vykaslat a enforcovet Prvnivelke pismeno ve jmene charu?
    (Asi prece jen bude hezci, kdyz na disku budou chary savnute s velkym)
  - kazdopadne to case-insensitive prihlaseni by fungovat melo.
[Forcuje se Prvni Velke]

TODO: Zrušit automatické updatování invalid referencí.
  - automaticky se updatuje při volání isValid()
  - neupdatuje se při přístupu na ostatní properties.
[done]

TODO: class Admins (a ani EntityList) nemůže interně používat reference
  jako klíč v hashmapě, musí používat stringId. A to proto, že mohou
  existovat různé proxy odkazující na stejnou entitu, takže by se do seznamu
  mohla dostat jedna entita víckrát.
  - Admins jsou předělané (interně je klíč string id, metody si ho vytahují
    z reference na entitu).
  - EntityListu se to kupodivu netýká, protože ty už stringovým idčkem klíčují
    (reference na entitu je hodnota klíčovaná stringovým idčkem, což je ok).
[done]

TODO: Přejmenovat AdminLevels na AdminLevel
[done]

TODO: Na AdminLevels by asi fakt byl lepsi enum.
[snad done]

===============================================================================  

TODO: co se stane, když mi umře entita, na které běží async skript?
[to už by mělo být ošetřené]

TODO: Možná založit adresář /game/search a dát do něj AbbrevSearchLis.ts
  (časem by tam mohlo být vyhledávání v grafu místností, apod.)
[tohle zatím dělat nebudu]

TODO: Dodělat ClassFactory (zbývá Prototype a PrototypeManager)
[done]

TODO: Možná do ClassFactory přesunout i vytváření nových class (to je tuším
  v prototypu).
[done]

TODO: Přidat do /documentation soubor se seznamem používaných datových
  struktur a návodem k použití (Object, Array, Map, FastBitSet,
  FastPriorityQueue, Enum...).
[přidal jsem na to adresář]

TODO: Mudlog přejmenovat na Syslog a možná ho přesunout do /shared
- nechám ho v /server, protože bude posílat text online charům.
[přejmenováno]

TODO: Sjednotit názvy adresářů. Neměl by se jeden jemnovat characters
 (se 's' na konci) a druhej /entity (na druhou stranu /flags by asi mělo
 zůstat. I když...)
[flags zůstaly, zbytek je v jednotmém čísle]

TODO: Možná založit adresář /shared/entities a dát tam vše, co se týká
  entit
[done]

TODO: Možná založit adresář /shared/error a dát tam ERROR a FATAL_ERROR
[done]

TODO: Ještě jednou se zamyslet nad tím, jestli má smysl chybový výpis v apply()
  handleru InvalidValueProxyHandleru.
  - pravděpodobně nemá, navíc to pak spamuje při systémových voláních (výpis
  do konzole, util.inspect, apod..
[Asi tam fakt být nemá. Okomentováno]

TODO: V SaveableObjectu
  - operátor 'in' nefunguje na proxy, je třeba ho volat nad entitou.
  - to se týká i případu if ('saveIdToJsonObject' in variable)
[done] 

TODO: Vyzkoumat, proč se mi savujou skoro prázdný entity
[snad done]

TODO: TrimType.PROXY_HANDLER uvnitr get() by se mel trimovat jen o 4
[Snad done]

TODO: Přesunout EntityRecord do samostatného souboru
[done]

TODO: Jit trochu jinak na error messages:
  - Vsemu rikat ACCESS_VIOLATION a o co presne jde upresnit v doplnujicim
    message.
[done]

TODO: Poresit zacykleni pri vypisu stack trace pri invalid property accessu.
- a asi taky trimovani o jiny pocet radku nez pri ERRORu
[tak to uz zrejme necykli, nejspis jsem to necim opravil]

TODO: V abbrevSeachList.ts::170 se nejak divne maze z hashmapy.
[opraveno]

TODO: metodu dynamicCast() asi přesunout z EntityManageru do Entity.
[je presunuta do EntityProxyHandleru]

TODO: Otestovat, že prirazeni this opravdu priradi proxy
[Zda se, ze opravdu ano, uff!]

TODO: createSystemRealm() a všechno uvnitř.
[done]

ÚVAHA: Monžná se přece jen vrátím k classe Id (- nakonec ne)
  - ne proto, že bych se chtěl zbavit přímých referencí, ale proto, že když
    si někdo říká o entitu na základě stringového idčka, tak musí dodat i typ,
    aby šla vrátit invalid entity se správně nastaveným typem v handleru (aby
    pak podle něj šla vytvořit správná instance).
Na druhou stranu ale kdy by se tahle classa použila?
- jako dočasná proměnná při savování
- jako dočasná proměnná při loadování
Držet si ji nikdo nebude, protož držej se reference a tyhle informace jsou
  schované v handleru.
S tím souvisí:
- kdo bude potřebovat volat entityManager.get()?
  - asi to samé, pouze SaveableObject.loadReferenceFromJsonObject().
  nebo ještě někdo?
  - z nejěkých důvodů jsem tam chtěl ošetřit, když je "id" null
[Tak nakonec ne]

TODO: EntityManager by neměl vyčítat data z JSON objectu - to má dělat
  SaveableObject.
[přesunuto do SaveableObjectu]

TODO: metoda createInstance() by neměla být v SaveableObjectu.
  - místo toho by měla existovat Server.classFactory a na ní by měla
    být metoda createInstance().
TODO: Při té příležitosti do ní přeshnout i dynamicClasses, ať nestrašej
  v global objectu.
[done]

TODO: EntityManager.proxyHandler by mozna nemuselo bejt pole (ale mapa).
  - nakonec to bude Set
[done]

TODO: Vytvořit modul EntityManager (again ;-))
TODO: Konstruktor Entity by měl vracet Proxy.
  IDEA: Konstruktor Entity bude vracet 'new Proxy()', takže nejpůjde mít
    nezaproxynovanou entitu.
TODO: Sebrat IdProvideru funkcionalitu na trackování idček.
  [done]
TODO: Předělat IdListy na EntityListy.
TODO: Ošetřit savování referencí na entity v SaveableObjectu.
  - musí se savnout Id záznam místo entity.
  - při loadu se zase jen načte Id záznam
    - možná to bude znamenat, že entity proxy musí umět ještě jeden stav
      (kromě entity = null). Nebo možná prostě jen pamatovat si idčko
      (protože EntityProxyHandler teď vlastně slouží jako původní class Id).
TODO: Přetypovat idčka z Id na string.
[některé věci jsou jinak, ale v zásadě done]

TODO: Odchytavat pristup na neexistujici property.
[done]

Pozn.: Accounty se mi savují postaru do /Accounts/Rahman.json, což je nakonec
  asi dobře. Každopádně to chce zkontrolovat.
[snad ok]

TODO: Opravit savovani entit.
[snad done]

TODO: Opravit AttributableClass
  - protože super.metoda dělá něco trochu jiného, než jsem si myslel
    (nevolá metodu přímého předka, ale toho předka, který ji jako první
    má jinou. Tzn. to může přeskočit několik stupňů dědění. A já je
    v AttributableClass potřebuju projít všechny).
  - toť otázka. Není to náhodou tak, že se mi ta statická proměnná
    automaticky zdědí, takže ji prostě uvidím na this.constructor, ať
    je deklarovaná na jakémkoliv předkovi?
    - v tom případě tam naopak šaškuju zbytečně složitě...
[Hmm, tak zjevně jsem to dělal zbytečně složitě.]

TODO: Opravdu to udělat, zní to rozumně.
BIG IDEA: Zuršit ASSERTY.
  Místo toho používat:
  //
  if (condition === false)
  {
    ERROR
    (
      "message"
    );
  }
  //
  - Ve skutečnosti stejně ty asserty píšu vždycky do podmínek a navíc ten
    zápis if (!ASSERT(condition, "message")) není moc intuitivní.
  - vyřeší to problém s tím, že se mi provádí kód na skládání stringu,
    přestože string není potřeba.
[done]

TODO: Korektne vycistit SaveableObject od pozustatku EntityId.
  (protože EntityId nemůže být includnuté v SaveableObjectu, byl
   by to křížový include (nebo je z něj zděděné). On to sice typescript
   compiler povolí, ale zuchne to pak v runtimu).
[done]

TODO: Asi se fakt vrátnit k Id místo EntityId.
[nakonec to je úplně jinak]

IDEA: Přesunout fci getTrimmedStackTrace do modulu Mudlog a zrušit UTILS.
[done]

TODO: Specialni kod na loadovani idcek musi byt primo v SaveableObjectu,
  ne az v Entity. Sice jen Entity muze mit idcko, ale to neznamena, ze si
  nekdo nemuze vytvorit SaveableObject, do ktereho si da idcko na JINOU entitu.
[done]

TODO: Zavest pocitadlo rozdanych referenci v IdManageru
  - kdyz klesne na 0, tak je mozne idcko vyhodit z manageru.
- Tak jinak, misto toho idProvider drzi idcka ve WeakMape
[Nakonec je to úplně jinak, ale done]

IDEA: Idcko se automaticky zaregistruje v IdManageru, pokud jsou parametry
  konstruktoru definovane.
  - diky tomu se mi nestane, ze by si nekdo vytvoril idcko (pres new EntityId)
    a nevlozil ho do IdManageru (jako se mi povedlo s WorldId).
  - ono se mu to teda asi nepovede ani tak, kdyz bude idProvider schovany
    uvnitr IdManageru. Ale takhle aspon usetrim kod, ktery se stejne musi
    vzdycky provest.
[asi done]

TODO: protected -> private v EntityId
[done]

TODO: Nastavovat idčkům status.
[snad done]

TODO: V SaveableObjectu sjednotit fce isPrimitiveObject, isDate, atd.
      - pokud bude fungovat .constructor.name, tak používat to.
[done]

TODO: Všude po volání entityId.getEntity() dát check na to, že result
      není null.
      (entityId.getEntity() může vrátit null. Dereference by pak shodila hru)
[už je to úplně jinak]

IDEA: Sloučit AbbrevSeachList a IdSearch list do jedné classy
      (AbbrevSearchList prostě bude zděděnej z IdListu)
      Přidat classu NameSearchList (zděděnou z IdListu)
[done]

TODO: PlayerConnection přejmenovat na Connection
      a Server.playerConnections na Server.connections
[done]

TODO: V Server a Game oddělit managery od idListu a dát k tomu komentáře,
      čím se to liší.
[done]

TODO: IdList přesunout do /shared
      (IdSeachList asi taky)
[done]

TODO: Všechny XXXManager přejmenovat na XXXList a zdědit je z IdList nebo
      IdSearchList
      - nebo ještě druhá možnost, místo AccountList prostě Accounts
      (ale asi raději AccountList, Accounts je divné jméno pro classu)
TODO: Všechny xxxList přesmenovat na xxxs (characterList na characters).
TODO: EntityContainer přejmenovat na EntityManager
      (bude z toho jasnější že je jen jeden)
TODO: Container přejmenovat na ContainerEntity
TODO: CommandInterpretter přejmenovat na CommandInterprettingEntity?
      nebo CommandEntity? CommandProcessingEntity? - to zní nejlíp.
      - hmm, to možná ne, to zní divně...
      [necham CommandInterpretter]
[done]

Obecně se držet schématu:
- Manager obsahuje přímo instance
  - EntityManager obsahuje entity (což jsou instance)
  - FlagNamesManager obsahuje instance FlagNames objektů
  - PrototypeManager obsahuje instance Prototypů
  - List obsahuje idčka
[v zásadě done]

TODO: Přidat classu IdSearchList a přesunout do ni abbrevSearchList z IdListu.
[done]

TODO: game/EntityContainer přejmenovat na něco jiného
      - buď EntityIdContainer
      - nebo GameEntityContainer
      - nebo prostě Container?
Nebo možná raději přejmenovat /shared/EntityContainer na EntityManager?
[done]

TODO: Pokud budu managery dědit z idListu, tak to udělat
      i s PlayerCharacterManagerem
[done]

TODO: Přesunout NamedEntity do shared
  (a možná i další classy).
[done]

TODO: Id přejmenovat na EntityId (a classu EntityId zrušit).
  - tohle si asi ještě rozmyslím... I když...
[done]

TODO: Výhledově dát 'dynamicClasses' někam jinam než do global objectu.
  - asi do serveru
TODO: Výhledově nějak líp pořešit dynamické classy než přes dynamicClasses.ts
  (možná všechny moduly requirovat místo importovat?)
[done]

TODO: S loadováním/savováním hashmap jsem se, zdá se, radoval předčasně
  - opravit loadování SaveableObjectů uložených v hashmapě.
[snad už ok]

TOFIX:
ARGH - directReference v Idckach je udelana spatne :\
  - dokud vsichni odkazuji na Idcko, ktere si drzi samotna entita,
  tak je to asi ok. Ale muze se stat, ze si nekdo vytvori vlastni
  instanci Id - třeba po loadu ze souboru. V ten moment se to rozbije,
  protože neexistuje jediná instance Idčka pro danou entitu...
Jak to spravit?
  - instance Idček asi budou muset být v příslušném containeru spolu
    s entitama. Takže (i při loadu) si nebudu nikdy vytvářet vlastní Idčko,
    vždycky si budu muset říct containeru, aby mi Idčko vyrobilo
    (já mu dám stringId a on mi buď vrátí referenci na existující instanci Id,
    nebo si ji vyrobí...)
[je to celé jinak]

TODO: entity.stopScript(scriptName);
TODO: entity.stopAllScripts();
- musí to vycházet z entity, ne ze Skriptu
[idea has been dropped. attachovat/detachovat scripty na entity nebude možné]

TODO: Skripty v Prototypu dávat do hashmapy místo do pole (protože bude třeba
  umět skript najít například při 'edit TutorialRoom.onLoad');
[done]

TODO: Do Script.code dávat jen tělo funkce. Hlavičku funkce a {} tam přilepí
  engine.
[done]

TODO: Změnit odkaz na prototyp ve Scriptu na jméno prototypu.
[done]

TODO: Otestovat skripty
  - ukládání do souboru [done]
  - zkompilovat a pustit dva různé skripty [done]
  - rekompilace běžícího skriptu [done]
[done]

TODO: Naucit SaveableObject savovat a loadovat obycejne objekty.
- ono by to v zásadě mohlo být ok, pokud je to dynamická classa a má
   className, tzn. by ji bylo možné instanciovat. Ale to už rovnou můžu
   trvat na tom, aby to byl SaveableObject.
[Aha, on už to umí. Odmítá savovat jen classy, které nejsou obyč Object
 a nejsou zděděné ze SaveableObjectu, což je asi dobře.]

TODO: Nahackovat savovani staticke property 'className'
[done]

TODO: Ještě přece jen zvážit, jestli nepoužívat nepojmenované classy
  (tj. že Class.constructor.name bude "") a nedávat jim className jako
  moji vlastní property.
  - ono to celkem dává smysl, protože to prostě nejsou statické classy.
[budu používat nepojmenované classy]

TODO: Změnit NamedClass, aby className nebyla property na instanci,
  ale statická property (tj. na constructoru).
[done]

TODO: Zjistit, jestli by classDeclarationScript nemohl byt zkompilovany
  jen jednou (a brat si parametry ze sandboxu).
[pokud mi bude fungovat vyrábění class bez skriptu, tak tohle nebude potřeba]

TODO: Ucesat Prototype.setMethods()
[done]

TODO: assert na internalFunction !== null
[done]

TODO: Testnout, jestli můžu z jednoho sandboxu vyrobit dvě skriptové funkce,
  které budou mít různé skriptName.
[done, nemůžu]

TODO: Instance savovat do /data/instances
[snad done]

TODO: Zkontrolovat, ze jsem Flags-related classy prejmenoval spravne
[snad jo]

TODO: Presunout flagNamesManager ze Serveru do Game
 - asi to nebyl dobrej nápad, protože když bych chtěl mít account flagy,
   tak nebudou fungovat bez toho, aby existovala hra.
   - nejspíš to budu muset přesunout zpět.
[done (přesunuto zpět)]

TODO: Projít nově vytvořená data a opravit všechny chyby
[done]

TODO: Při savu Map objectu je vždycky první prvek 'undefined'
[fixed]

TODO: Přejmenovat FlagsData na FlagData a FlagsDataManager na FlagDataManager
[done]

TODO: Promyslet a zkontrolovat, jak SaveableObject pracuje s null hodnotama
- nejspíš je tam navíc ten ASSERT, kterej to kontroluje, null už by to mělo
  zvládat (buď se vytvoří objekt správného typu, nebo se přímo přiřadí hodnota
  loadnutá z JSONu)
[done]

TODO: Možná mám někde zbytečně metody save() a load()
  - jsou v IdableSaveableObjectu (takže pokud je něco zděděné přímo ze
    saveableObjectu, tak to tyhle metody nemá.)
[snad done]

TODO: Zacina bitvector od nuly nebo od jednicky? Zjistit.
[zjevne od nuly, takze to mam spravne]

TODO: Loadovani/savovani classy 'Map' v SaveableObjectu
[snad]

TODO: Adresářová struktura prototypů (a asi i v rámci PrototypeDataManageru)
[snad done]

TODO: Když neexistuje adresář /data, tak vytvořit defaultní flagsData
  a prototypeData
  - respektive možná bude stačit ve flagsDataManageru hodit loaded flagu
    na true, aby se flagy vytvářely samy...
[asi ok]

TODO: Nekam naimplementovat metody setPrototypeData() a setMethods() :-)
- nekam do GameEntity chainu, asi na urovni /shared.
 (Nakonec jsou v PrototypeData, protože je to potřeba setovat zvenku do 
  class_constructor.prototype)
[Zatím je jen setPrototypeData()]
TODO: setMethods()
TODO: Skripty
[done]

TODO: V PrototypeData doplnit typ k predavanym typum (ja vim, zni to divne...)
[Jakz takz, nekde jsem neprisel na to, jak na to]

TODO: Hodit ASSERT_FATAL do samostatneho modulu (a fci getTrimmedStackTrace()
  taky, aby se dala includnout z obou assertu).
[done]

TODO: PrototypeData a PrototypeDataManager presunout do /shared
[done]

TODO: Zvážit, jestli nedávat dynamické classy (repsketive jejich konstruktory)
někam jinam než přímo do global objectu (asi do global.dynamicClasses ?).
[done]
TODO: Popravdě možná spíš pod server, nebo tak něco... Těžko říct.
[done]

TODO: Zrušit prefixy z flagů.
[done]

TODO: vsechna createNew asi prejmenovat jen na create (když něco vytvářím,
  tak je jasné, že to bude nové).
[done]

TODO: Přidat do SaveableObjectu savovani classy Map.
  (Ono to možná funguje samo, chce to každopádně zkontrolovat.)
  - tak samo to opravdu nefunguje
[done]

TODO: implementovat flagy (bitvector engine).
[done]

TODO: Udělat vlastní FS modul, ať jsou všechny souborové fce na jednom místě.
[done]

TODO: Nastavovat entity.location (kdyz entitu vkladam do nejake jine).
[Snad done (mozna ne vsude)]


IDEA: Udělat z IDčka generic - id.getObject() pak vždycky vrátí správný typ.
[Tohle nepůjde]
- místo toho id.getEntity() dělá dynamický typeCasting.
[done]

TODO: predelat vsechna idcka v savech na EntityId
- to asi pořeším tím, že vyrobím celý svět znovu.
[done]

TODO: Pri vytvareni noveho sveta generovat mistnostem nejake defaultni
  RoomInfo.
  (A to asi tak, ze se pri vytvareni nove rommy vytvori automaticky, pokud
  konstruktor nedostane jako parametr template - nebo mozna dve funkce, jedna
  na vytvoreni templatove roomy a druha na vytvoreni odvozene roomy?)
/* Predelavam cely koncept prototypu, takze tohle bude cele jinak */
[je to jinak]

TODO: Idcka dostala přímou referenci na odkazovaný objekt
  - při vytváření objektu je třeba tuhle referenci v idčku inicializovat
    (je to parametr constructoru)
  - a při mazání objektu (odebírání ze seznamu objektů) ji zase invalidovat.
[snad done]

TODO: V AbbrevSearchListu nahradit prime odkazy na GameEntity Idckama (idcko
  ma ted v sobe primy odkaz, takze to nebude vyrazne pomalejsi).
[snad done]

TODO: Zprovoznit resolvování aliasů složených z více klíčových slov
   v AbbrevSearchListu:
   - Dám do něj jednotlivě všechna klíčová slova z alias listu.
   - Při heldání je všechna matchnu, čímž dostanu n polí se seznamem entit
    "slyšících" na dané jméno. Ty následně projdu a vytvořím seznam idček,
    které se nachází ve všech těchto polích.
[snad done, zatím netestováno]


TODO: Vsude doplnit metodu getErrorIdString() a dusledne ji pouzivat v
  chybovych hlaskach.
[done]

TODO: Checkovat, ze loadnute id odpovida idcku, podle ktereho jsem
  entitu naloadoval.
  (a taky ze id odpovida nazvu souboru, pokud entita neni unikatni)
[snad done]


TODO: Zautomatizovat protopyování - asi by to měly umět všechny gameEntity
minimálně do té míry, že si budou držet odkaz na prototyp (idčko) a budou
automaticky prototypovat 'name'.
[tohle je jinak]


---------------------------------------

TODO: Upravit LobbyProcessor, aby prompt posilal pres generatePrompt()
[done]
- Pro AuthProcessor to neni dobrej napad, vedlo by to ke spouste internich
  stavu
[done]

TODO: v metode PlayerConnection::generatePrompt()
/// TODO: switch na stage lobby processoru by mel byt v LobbyProcessoru
[done]

TOFIX: Asserty pri connecteni z ruznych terminalu
[Co jsem vedel tak fixed]

TOFIX: Stalo se mi, ze jsem se pripojil, jeste nez se neco zinicializovalo,
  takze jsem nedostal menu.
  - a uz asi i vim, jak se mi to stalo: Nalogoval jsem az do hry a zabil
    putty (zavrel connection), nasledne jsem se pokusil znovu prihlasit.
  - bude to nejspis tim, ze zatim nemam implementovane korektni zavreni
    connection, kdyz player shodi connection, zatimco je ve hre.
    (viz PlayerConnection::close(), prvni vetev ifu)
[nejspis fixed]

TOFIX: Kdyz naloguju, vlezu do hry, quitnu a zatimco jsem v menu, tak se
  priloguju pres novou connection, tak to do logu vypise:
  "Player Rahman [::1] closed connection before logging in" 
  - zrejme se pri quitu ze hry neco nenastavi spravne.
- asi je spatne jen hlaska. Je spravne, ze je account null - byl setnuty
  na null proto, aby ho connection neodlogovala (protoze jde o reconnect)
  Ve fci PlayerConnection::onSocketClose() by mel byt switch podle
  stage lobbyProcessoru, ne jen test na to, jestli je je account null.
Pozn.: stage lobbyProcessoru bych nemel switchovat v metode PlayerConnection,
  mel bych na to udelat metodu v lobbyProcessoru.
[fixed]

TOFIX: Kdyz si uzurpnu connection, tak se nezavre
[fixed]

TODO: stage ve vsech managerech predelat z intu na stringy, at je pri
  debugovani videt, co je to za stage.
[done]


TODO: fixnout SYSTEM ERRORY, ktere vznikaji tim, ze se spusti 'onError'
event po zavreni connection
- mozna se to vyresi, kdyz pri zavirani socketu odstranim listenery
  na data:
    socket.removeAllListeners('data');
- tak ne.
[snad fixed]

TODO: Zprovoznit start z neexistujicich dat
(musi se vytvorit world, v nem 1 realm, v nem 1 zona, v ni 1 room)
[done]


TODO: Opravit barvy
[done]

TODO: loadovani a savovani obyc objektu (nezdedenych ze SaveableObject)
- kdyz objekt nema loadFromJsonObject, tak do nej proste priradit to, co se
  loadnulo z jsonu.
- tohle je potreba kvuli loadovani Date objektu.
- nebo mozna rozpoznavat, ze jde o Date object, tezko rict. Tohle prirazeni
  by mohlo vest k tomu, ze objekt nebude mit vsechny properties, ktere by mel
  mit.
  - asi by bylo lepsi detekovat, ze to je Date object...
[done]

TODO: Misto this.isSaved pri loadu/savu checkovat
  ClassAttributes.getAttribute(className, property, attribute);
[done]

TODO: Poresit radkovani pri posilani menu
/*
  Kdy se vypisuje menu:
  - pri nalogovani do hry
      (to jde tesne po prikazu a musi byt odradkovane)
      - tady by ve skutecnosti melo byt nejdriv MOTD a po nem "Pres return"
  - pri quitu ze hry
      (to jde po bloku textu, nema byt odradkovane, protoze odradkovani zaridi
      engine)
  - invalid option v menu (vypise se znovu jako prompt)
      (odradkovane ma byt v tomhle pripade "That's not a menu choice, takze
      menu jde opet po bloku jako prompt)
*/
[snad done]

TOFIX: Ponastavovat isSaved = false vsude, kde je to potreba
[snad done]

TOFIX: abbrevSearchList by nemel byt case sensitive
[done]

TOFIX: Do abbrevSearchListu se ocividne nedava posledni prvek
- a naopak se tam dava i prazdny string
[done, fixed]

TOFIX: Prvky v poli ocividne savuji saveRequests property
[tak prvky v poli se savovaly spravne, chyba byla v hashmape, coz je obyc
 Object]

TODO: Za prompt pridavat mezeru (aby byl player input od promptu oddeleny)
[done]

TODO: Fixnout "Invalid prompt >" pri "That's not a menu choice!"
[fixed]

TODO: Nejspis budu muset zrusit zrani newlinu na konci inputu, holt si to
  koderi budou muset hlidat sami. Bude to potreba na to, abych na patricnych
  mistech vyrobil vicenasobne odradkovani.
/*
  - mozna by se to mohlo kontrolovat v ramci sendAsBlock(), tj. kdyz to konci
  promptem. Tam se mezi prompt a blok automaticky prida mezera (pokud player
  nema brief mode) a asi nikdy nebude hrozit, ze by tam mely byt dve.
  - tohle by asi mohlo i stacit, btw. Drtiva vetsina herniho outputu bude
  rozhodne posilana jako blok (urcite sendToChar(), urcite act()).
*/
/*
  Tak ne, je to blbost. Po bloku bez promptu stejne nasleduje newline a po
  promptu naopak logicky byt nesmi, jinak by hrac psal na novou radku misto
  na stejnou.

  Ve skutecnosti je nekde potreba newline pred outputem, protoze je treba
  odradkovat po odeslani prikazu, a to se jinak udelat neda.
*/
[rozhodnuto: Newliny na konci outputu se zerou, je povolena newline pred
outputem - pouziva se na oddeleni outputu od player commandu]

TODO: Poresit barvu player inputu
/*
  Zjevne se pise barvou, kterou naposledy poslal mud.
  - tj. asi by to chtelo na konec kazdeho stringu prilepit &w.
*/
[done]

TODO: Poresit automaticke radkovani prikazu.
/*
  Uvaha: Za odradkovavani VZDYCKY zodpovida engine, tj. zadny send_cosi() prikaz
  nesmi koncit enterem
  - tohle mozna enfocnout v kodu - ASSERTEM a tim, ze se pripadny enter
    automaticky odstrani.
  - povolene jsou pouze entery uvnitr stringu, pokud ma byt viceradkovy

  TODO: Zajistit, aby to takhle opravdu bylo, i v prubehu logovani do hry.

  TODO: Sjednotit, jak se budou entery psat - asi vzdycky '\n' s tim, ze
    se to pripadne tesne pred odeslanim hromadne preklopi na '\r\n'

  Pozn: Matne si vzpominam, ze pri posilani progressbaru bylo potreba
    rozlisovat mezi sendem, ktery se ma odradkovat, a ktery se odradkovat nema
    - respektive mozna to bylo jeste jinak, ze se zapnul mod "ted posilam
    updaty progressbaru", pri kterem se neodradkovava nic.
*/
/*
  Je to trochu jinak:
  - za promptem nikdy neni newline, takze se prikaz pise rovnou za nej. Promt
    jsou i vsechny prikazy v menu a tak.
  To znamena, ze je treba rozlisovat, jestli se posila prompt, nebo neco
  jinyho.
*/
[snad done]

Zrusit savovani IdProvideru, misto toho k idcku prilepovat boot timestamp.
[done]

Zrusit prvni parametr z IdProvider.generateId()
[done]

TOFIX: Po quitu nebo reconnectu je nejspis nastaveno provazani
  s playerConnection, opakovany quit nezabere (respektive pak vubec nefungujou
  prikazy)
  [done]

TOFIX: qui spusti doQuit() misto doQui()
[Fixed]

---------------------------------------------
---------------------------------------------
---------------------------------------------
---------------------------------------------

Important TODO: Saving request buffer na savovani lastIssuedId
[Done - IdProvider ted vyuziva mnohem vic funkcnosti ze SaveableObjectu,
 vcetne bufferovani save requestu]

---------------------------------------------

TODO: Zrusit pevne idcko worldu. Bude se loadovat ze souboru
world.json, kde je ulozene.
[Done]

---------------------------------------------

TODO: accountName prejmenovat na name, at se savuje na zacatek souboru.
[Done]

---------------------------------------------

TODO: Udelat hack do SaveableObjectu, ze kdyz ma entita property 'name',
  tak se savne jako prvni (jestli to teda pujde).
[done]

---------------------------------------------

GameEntity by mel byt IdContainer<Id>
- tedy container Idcek
[Done - obsahuje IdList]

Staci mi, ze se idcka davaji do hashmapy?
- nestaci, protoze potrebuju pevne poradi
[Done - IdList ma Array idcek]

V cem se lisi:
EntityManager, IdContainer, EntityContainer?
  IdContainer
  /* Mel by se jmenovat asi spis IdableItemsContainer */
  - neni z niceho zdedeny
  - je to template (IdContainer<T extends IdableSaveableObject>)
  - itemy jsou v hashmape
  Umi:
    - pridat item pod existujicim idckem
    - vygenerovat itemu idcko a pod nim ho pridat
    - odebrat item z containeru
    - odpovedet, jestli je item daneho idcka v containeru
    - vratit item podle idcka (pres hashmapu)
    IMPORTANT: IdContainer nedrzi idcka, ale primo itemy!
  EntityManager
  - neni z niceho zdedeny
  - je to template (EntityManager<T extends GameEntity>)
  - vubec si nedrzi idcka ani itemy, drzi si pouze abbrevSeachList a uniqueNames
  Umi:
    - pridat item pod existujicim idckem
    - pridat novy item do Game.entities (tam se mu vygeneruje idcko)
    - checknout, jestli je entita v Game.entities (nikoliv jestli je v manageru)
    - vratit entitu (vezme ji z Game.entities, necheckuje, jestli mu idcko patri - nema jak)
    - odebrat entitu z manageru
  - jestli ma entita unikatni jmeno nebo ne je vlastnost entity, manager ji podle toho zaradi do
    seznamu unikatnich jmen nebo ne
  EntityContainer
  - je zdedeny z predka GameEntity (EntityContainer extends CommandInterpretter)
  - zatim nema nic, ale mel by mit SaveableArray idcek
  - mel by asi umet so same, co EntityManager (ale unikatni jmena ho asi nezajimaji)
[Done - jmenuje se to IdList]

save() a load() by mel automaticky savnout/loadnout i vsechny obsazene entity,
aby se nestalo, ze loadnu container, ale ne to, co je v nem.
[Done]

Zaver: GameEntity by v sobe proste mela mit entity manager
[Done - je to tochu jinak, misto manageru je ted classa IdList, ktera v sobe
 drzi seznam idcek a umi v nem vyhledavat.]

------------------------------------------------------------------------

Ke zvážení: Dávat před string idčko nějakou předponu, třeba e jako entity,
  a jako account?
- teoreticky by se pak dala generovat "spotřební" idčka (třeba timery) s jinou
  předponou zase od začátku
[Zatim na to kaslat]

Nesavovat playerConnectionId
[done]

Load/save entityContainerů
[asi done]

Check, že existují adresáře, do kterých se mám savnout (možná je automaticky
vyrobit, pokud neexistují?).
[done]

-----------------------------------------------------

TODO: Implementovat binarni vyhledavaci pole na hledani abbreviationu.
[nahrubo asi done. Je to hashmapa]

TODO: Pridelat do entity manageru trackovani neunikatnich jmen.
[snad done]

TODO: Z protected metod zrusit predponu 'my', stejne ji vetsinou nepouzivam.
(u dat zustane)
[zruseno i u dat]

------------------------------------------------------

Hodne vyhledove:

[23:49] Huan         : jiste ze muzou vracet. promise.resolve(navratovahodnota)
[23:50] Huan         : a presne tohle streamline resi
[23:50] Huan         : a resi i ty exception

[exceptiony jsou jakz takz poresene tim, ze se odchyti a vyhodi znova, takze
to vypise stack]


===============================================================
Uvahy k prototypovani, skriptovani, hot reloadu, etc.
-------------------------------------------------------

    /*
    // TEST:
    let script = "return 'Changed function!'";
    this.location.getEntity().printContents =
      <() => string>new Function(script);

      - Tohle funguje. Znamena to, ze skript muze byt ulozenej
      jako string a muzu ho v runtime povesit jako metodu na nejaky
      objekt (novou nebo existujici).

      - otazka je, jak udelat wait

      - chybi odolnost proti zacykleni (ale to zas neni tak zasadni, to
      se stava malokdy)

      - neni videt this, musi se predat jako parametr (coz je ale asi ok,
      tak se chovaji i brutusi skripty).

      - nejde volat jine funkce, pouze metody toho, co se preda jako
      parametr (nemam to ozkousene, ale snad jo). Coz je ale asi spravne,
      aspon je to odolne proti zneuziti.

      - musi to byt javascript (nemuze to byt typescript). Dalo by se ale asi
      udelat nejake externi volani typescript compileru
      vol
    */



    Asi by taky šel použít node.js modul 'vm':
    https://nodejs.org/api/vm.html

    - to bohužel pořád funguje jen na úrovni javascriptu...



    Když bych chtěl prototypovat nativní javascriptovou prototype inheritancí
    (jako že bych určitě chtěl), tak by každý brutusí vnum musel odpovídat
    samostatné class. Pak by prostě javascriptový prototyp té classy fungoval
    jako mudový prototyp.
      Editace prototypu v runtime by pak vypadala takhle:
        Mob82003.prototype.maxHitPoints = 20;



  ------------

  Jak na dynamické generování nových typů (prototypů)?

  - Musím to samozřejmě načíst z nějakého souboru v rozumném (tj. JSON) formátu
  - Co všechno dávat do jednoho souboru? Po zónách to asi organizované mít
    nechci... (respektive určitě by mělo jít vypsat, jací mobové jsou použiti
    v dané zóně, ale neměli by se vyrábat mobové (roomy, atd.) přímo do zón).

    Každopádně zatím můžu začít jednou entitou v jednom souboru, pak to kdyžtak
    rozšířím.

Takže:

class PrototypeData
{
  type: string;
    /* Jaky typ se má dynamicky vytvořit */
    - ten by se asi měl generovat automaticky
    ("Mob"/"Obj"/"Room" etc. - nebo možná 'mOrc21') + jméno + případně číslo?
    - je podstatné si uvědomit, že prototypy se nedávají do zón a že od každého
    prototypu může existovat víc instancí (i od prototypu roomy). Takže když
    budu chtít ve skriptu projít 10 room v zóně, tak budu ty roomy odkazovat
    přes jejich stringová idčka (nebo nějaký logický dns-like ekvivalent),
    nikoliv přes jméno prototypu.
    - na druhou stranu loadovat budu z prototypu, takže 'load mOrc21' se
    používat bude

  ancestor: string;
    /* Z čeho se má zdědit */

  data: Array<any>;
    /* Jaké property a s jakými hodnotami se mají nasetovat prototypu
      (tedy do Type.prototype) */

  scripts: Array<Script>;
    /* kusy kodu, ze kterych se maji vyrobit metody a povesit na prototyp */
}

class ScriptData
{
  methodName: string;
    /* Pod jakym jmenem se ma funkce povesit na prototyp */

  code: string;
    /* Tohle není přímo tělo funkce. Při navěšování na prototyp se ještě
       obalí nastavením sandboxu a voláním s timeoutem. */
}
    


Pozn (Globální skriptové funkce):
  Pokud budu chtít mít nějaké skriptové fce, tak je asi nahážu do nějakého
  objektu, který automaticky přihodím do každého sandboxu (tedy do každého
  nového prototypového typu, protože sandbox bude nejspíš vždycky celá
  entita).
  - to by znamenalo, že by se volaly přes nějakou dot notation, nejspíš
  se.doSomething(); // 'se' jako ScriptEngine
  (nebo možná utils.doSomething()?)
- on možná sandbox objekt funguje jako 'global', takže půjdou funkce volat
  přímo. Chce to vyzkoušet.


TODO: pořešit 2 death scripty na mobovi (obecně víc skriptů na stejném triggeru
  jedné entity)


===============================================================
Bitmapy
-------------------------------------------------------

IDEA: Zkombinovat moznost deklarovat flagy v kodu a deklarovat je dynamicky.
- Když je flaga v kódu i v soboru (a sedí value), tak to tak
  zůstane. Když je v kódu a není v souboru, tak se dosavuje do souboru.
  (Tj. vždycky budou všechny flag values v souboru, včetně těch deklarovaných
   v kódu, ale ne všechny flagy musí být deklarované v kódu).
- když to při loadování hry nesedí (v kódu je stejná flaga jako v souboru ale
  s jinou hodnotou), tak to sprostě zařve FATAL_ASSERTEM

Jinak řečeno (a i jianak implementováno): V kódu budou deklarovány jen
  symbolické konstanty (bez hodnoty), hodnota bude jen v souboru (repsketive
  v hashmapě).

/*
 Jinak: FlagValue nepotřebuju, tu si vyrobím interně při indexaci.
   (a vlastně ani to ne, budu přece přistupovat na Flags object konkrétního
   typu a ten mi řekne, že value "PLAYER_DISCONNECTED" v RoomFlags není).

 - možná by stálo za to vyžadovat, aby všechny flagy mělo globálně unikátní
   názvy (možná formou prefixů).
   (Prefixy by fungovaly tak, ze každý FlagData by si svůj prefix pamatoval
   a kontroloval by, že jím nově vytvářená flaga začíná (neměl by se připojovat
   automaticky, jen kontrolovat)).
*/


- flagy by měly jít přidávat za běhu, což znamená, že se musí umět savovat
  na disk (do kódu se za běhu zapisovat nedá).
  (Naprd je, že pak nebude napovídat visualko...)

Hodnota (konkrétní flaga) by měla být objekt, který v sobě má:
- vlastní číslo flagy
- jméno typu
(Díky tomu půjde za běhu kontrolovat, že RoomFlags indexuju opravdu room flagou
 a ne třeba PLR flagou se stejným číslem).


class RoomFlags extends Flags
{
  public static get ROOM_HOT() { return ROOM_HOT; };

  /*
     Not all existing room flags are necessarily defined here.
     Some of them may be declared dynamically - in that case the flag
     exists in files but doesn't have symbolic name here.
       Feel free to add symbolic names for such flags here if you want
     to use from the code.
     
     Note also that only the name of the flag is declared here, not its
     integer value. The value is still saved to file.

     You can also add a new flag here that doesn't yet exist in the file.
     It will be added there automatically on the next reboot (when the
     game loads itself from file) and an unused numeric value will
     automatically be assigned to it.

     If you really want to delete a flag (maybe because you addes some by
     mistake or it becomes obsolete), the only way to do it is to edit
     the file with respective FlagData (///TODO: cesta k souboru).
   */
}

--------------------

Automatický update flaglistů:
------------------------------

- FlagsDataManager má flagu this.loaded, díky které lze assertovat,
  když se někdo pokusí hrabat na FlagData před tím, než jsou poprvé
  loadnuta ze souboru.

- instance Flags objektů (třeba new CharacterFlags()) mají referenci
  na příslušný FlagsData object inicializovaný na false.
  Až když ho někdo bude chtít poprvé použít, tak se na FlagsDataManageru
  checkne, že takový FlagsData objekt existuje (a že už je loadnuto).
  Pokud ne, tak ho vytvoří a savne.
  - tohle se pochopitelně provede jen jednou za boot, proože při příštím
    accessu už existovat bude.

- Když si konkrétní instance Flags objektu žádá o referenci na svůj FlagsData
  object, tak se taky provede update seznamu flag podle statických proměnných
  na Flags objektu, které začínají příslušným prefixem.
  - FlagsData object má flagu this.flagsAutoUpdated, která zaručí, že se tohle
    provede jen jedno, i když instancí příslušného FlagsObjectu bude více
    (každá z nich si při prvním použití vyžádá referenci na svůj FlagsData
    object)


===============================================================
Multiple characters and connections per account
------------------------------------------------

0) Exit BrutusNext
1) Enter game as Rahman
nebo
1) Reconnect as Rahman
// Pokud už char ve hře je

2) Create new character.
3) Delete a character.


  // Player can be connected to her account multiple times - for example
  // When immortal wants to play her mortal character on one session and
  // here immortal on another.
  /* Pozn: Mortalove by mohli mit omezeni na jedinou connection soucasne. */
  pendingConnections = new Array<PlayerConnection>();


Reconnect:
- Zahodi se existujici connection navazana na character (pokud je jeste ziva)
  a misto ni se setne pending connection, od ktere prisel request.


===============================================================

Scripting
----------

Každý skript je deklarace funkce
- jméno skriptu je totožné se jménem funkce (obalovací kód musí umět vytáhnout
  ze sandbox objectu proměnnou s danou funkcí - což bude dělat kód, který se
  přilepí na konec skriptu. A ten samozřejmě musí vědět, jak se má ta fce
  jmenovat).
- díky tomu, že skript deklaruje funkci, je možné v ní použít i return.
- script editor by při editaci nového scriptu měl automaticky vložit hlavičku
  funkce + prázdné tělo. Může to být šedivé, tj. uvnitř editace skriptu edituju
  jen obsah a když chci změnit jméno fce nebo parametry, tak musím vyskočit
  ven (nebo si to prostě naparsuju, ono to zas tak těžké nebude - prostě první
  vnější {})

'stopscript'
- Už v zásadě vím jak na to: Nechám doběhnout timer a místo resolve() zavolám
  reject(). Tím vyhodím výjimku, kterou pak následně odchytím (jako všechny
  výjimky z async funkcí přímo v BrutusNext.ts, akorát musím odflitrovat,
  že jde o stopscript exception - nejspíš podle err.message).

  Otázka je, jak v kódu, kterej se zavolá po skončení timeoutu, zjistit, že
  patří ke skriptu, kterej někdo stopnul.
  - nestačí na to jméno funkce, protože mezi tím se ten skript mohl pustit
    znova a kdyby novému spuštění dřív doběhnul timeout, tak bych umřel to nové
    místo starého. Takže musím přesně identifikovat každé jednotlivé spuštění
    timeoutu (možná přes ten timeout id?)

Související problém: Rušení skriptů běžících na entitě, kterou někdo zabil.
  - když bych ty skripty nestopnul, tak budou sahat na neexistující this
  - to znamená, že údaje o spuštěných skriptech (do kterých se bude
    poznamenávat, které skripty se mají stopnout, nemůžou bejt přímo na entitě.
    Po smazání entity bude timeout stále čekat.)
    - teoreticky by to mohlo být na classe (jako static proměnná). To ostatně
      asi i dává smysl, protože skripty jsou vlastnost prototypu (můžu v zásadě
      přiřadit na instanci nějakej skript, ale definovat se budou na prototypu.
      Takže budu psát něco jako 'stopscript PrototypeRoom::onLoad()', což by
      mělo stopnout všechny běžící instance tohohle kusu kódu, včetně těch,
      které jsem připojil na nějakou jinou entitu než odvozenou
      z PrototypeRoom.)
      - ok, takže na classe PrototypeRoom budu mít něco jako 'runningScripts',
        což bude hashmapa indexovaná jmény skriptových fcí (třeba 'onLoad').
        A pro každou běžící instanci tohohle skriptu tam bude záznam.
        (díky tomu půjde vypisovat i statistiky, kolik instancí nějakého
        skriptu mi běží, na jakých běží entitách, atd.)

  Ok. Otázka teda je, jak do PrototypeRoom.runningScripts přidám info o právě
  spuštěném skriptu.
  - jediné možné místo je asi kód funkce delay(). A musím do ní nějak
    propašovat informaci Prototype::scriptName - s tím, že Prorotype nemusí
    nutně být this.prototype, protože metodu SystemRoom.doCosi() můžu klidně
    pustit i na nějaké jiné entitě (s jiným prorotypem).

  Jak to udělat?
  - když buildím skript, tak vytvořím funkci. Může ta funkce mít vlastní
    funkci delay? (Která zavolá funkci performDelay() s parametry 'Prototype'
    a 'ScriptName'?).

/*
TOHLE NEBUDU IMPLEMENTOVAT
- nepůjde attachovat/detachovat skripty na instance (entity), to je antipattern.

Stopování běžících skriptů
- ideálně bych měl do běžícího skriptu propašovat odkaz na 'script' object
  a odkaz na internalFunction(). Když bude při doběhnutí timeru
  internalFunction uvnitř funkce delay() jiná než ve script.internalFunction(),
  tak to znamená, že se má skript stonout.
- alternativně můžu předávat compilationCounter a incrementovat ho na 'scriptu'
  (když má delay() menší compilationCounter, tak to znamená, že se má stopnout)
*/
-----------------------------------------------------

Přejmenování skriptu
- Pokud je script jen na prototypu, tak to je relativně jednoduché, na
  prototype se ze Scriptu dostanu (a prostě assignu undefined místo původního
  jména a novou scriptFunction na nové jméno)

/*
TOHLE NEBUDU IMPLEMENTOVAT
- nepůjde attachovat/detachovat skripty na instance (entity), to je antipattern.

- Pokud jsem script attachnul na entitu, tak to bude těžší.
  IDEA: Při attachnutí skriptu na entitu se nesetne rovnou scriptFunction,
  ale nejdřív nově vytvořená interFunction, která bude vědět, (přes jaké jméno
  byla zavolána. Ta se následně může podívat, jestli skript s takovým jménem
  ještě existuje (jak?))...
*/

---------------------------

IDEA:
Deklarovat fci delay() uvnitr skriptu místo uvnitř compile().
- díky tomu uvidí na 'me' predane do skriptu jako parametr
Nevyhoda: Vsechny skriptove fce budou muset mit explicitni parametr 'me'.


IDEA:
- 'script' můžu pořád dostat do delay() přes closure metody compile(),
  jen musí přidat ještě jedno volání, které ji zavolá.

  (tj. delay() bude deklarovaný ve skriptu a uvidí na 'me' a na funkci
  interDelay, která je deklarovaná v closure metody compile() a nastavená
  jako parametr sandboxu - což je problém, protože sandbox je jen jeden
  pro všechny skripty....
  - může být interDelay() deklarovaný v closure scriptFunction()?
    - to mi asi k ničemu nepomůže. Leda že by...

  - může být interDelay() předaný jako parametr do skriptové fce? Asi může...


  IDEA: Script.internalFunction prejmenovat na Script.run


======================================================

  Úvahy nad idčky a entitami
  ---------------------------

  - IdableObject přejmenovat na IdableEntity (nebo jen Entity)
    (protože idčka mají funkci getEntity, tak ať to dává smysl)
    (pořád bude rozdíl mezi Entity a GameEntity)

  - IdableObjectContainer přejmenovat na EntityContainer

  - V celé aplikaci mít jen jeden Entity Container
    (tzn. budou v něm accounty, game entity, atd.)

  - Sloučit IdProvider s EntityContainerem (nejspíš ho dát do entityContaineru)


Validita idček
  Když idčko loaduju z disku
  - checknu, jestli už není zaregistrované v IdProvideru
    - pokud ano, vezmu si referenci (a už má validitu zjištěnou)
    - pokud ne, přidám ho do IdProvideru - a asi bych měl ověřit validitu
      (a nastavit ji do interní proměnné)

  Hmm, validita může znamenat různé věci
  - valid entita, ale není loadnutá
  - smazaná entita

  public status = Entity.STATUS.UNKNOWN;
  
  public static STATUS =
  {
    // Initial value - we don't know yet.
    UNKNOWN:                  "UNKNOWN",
    // Entity is valid and loaded.
    VALID:                    "VALID",
    // Entity is valid (not deleted) and loaded from disk.
    NOT_LOADED:               "NOT_LOADED",
    // Entity has been deleted, you should not access it anymore.
    DELETED:                  "NOT_LOADED"
  }

  // internalReference jde zcela nezavisle. Entita muze byt loadnuta
  // a validni a pritom internalReference null
  // - nebo ne?
  //   Co mi brani updatnout internalReference hned?

  TODO: Zrušit classu EntityId
  TODO Id.getEntity<T>() bude generic a bude dynamicky přetypovávat
    na requestnutý typ T.


=======================================================================
Úvahy o idčkách, weakmapách, atd...
=======================================================================


Počáteční stav
---------------

IdProvider
"a-skh2swe" : id->zlyMob

Zuzka
 id->zlyMob




delete zlyMob
--------------

id.entity = null;	// entity se smaže z paměti
id.entityDeleted = true;

/* ----------- */

aktuální IdProvider:
"a-skh2swe" : id->zlyMob

Zuzka
 id->zlyMob

Potřebuju vědět, že:
- můžu smazat stringový klíč
- můžu smazat id


stringKey můžu smazat až ve chvíli, kdy zmizí poslední reference na idčko
- protože do té doby potřebuju být schopen dohledat idčko podle jeho stringKey


================================================

Idea: Zrušit class Id, používat přímé reference

- když SaveableObject narazí na Entitu, tak zavolá entity.saveReference(), což vytvoří
  podobný záznam, jaký teď má idčko.

- při loadování se z tohohle záznamu vezme stringId a checkne se, jestli je odpovídající
  entita loadnutá. Když ne, tak se reference nastaví na null (nebo místo toho na Id object?).

- při pokusu dereferencovat odkazovanou entitu se znova zkusí najít entita podle stringId
  (respektive byla by to možnost. "Už je online?" "A teď?")

No jo, jenže...
  Kam se savne to stringId, když bude reference null? To by se musela automaticky vytvořit
  nová promměná ve stylu "jméno_proměnné" + "stringId" a do ní by se hodilo to string idčko...
  - a nebo se tam místo entity hodí ten object Id a dereferencování jeho metod bude holt
    crashovat... (dereference null by crashnula taky)

Proč přece jen používat idčka?

- protože o tom, že je problém, se dozvím už ve chvíli, kdy použiju
  id.getEntity()


- problém je se skriptama, protože tam si dám do proměnné entitu a pak
  dám wait... a entitu může mezi tím někdo smazat.

Proč raději používat přímé reference?
- protože když nenapíšu if (id.getEnity() !== null) ..., tak mi to spadne
  při pokusu na entitě cokoliv zavolat
Když místo toho neoifuju referenci, tak mi na ní metoda zavolat půjde - sice
  se bude volat na invalid entitě, ale nespadne na tom celá hra.
- zato můžu do nativních metod entit psát checky typu:
  if (!this.valid)
  {
    ERROR(message);
    return;
  }
  Takže se dozvím, že se snažím manipulovat se smazanou entitou (a přitom to
  nic neudělá a neshodí to hru).




================================================

1. Dejme tomu, že dokážu checknout, jestli je entita s daným idčkem savnutá
   na disku.
   - Jak na to?
     - musím umět získat fullSavePath od každé entity, ideálně bez toho,
       aby ta entita musela existovat (static metoda? Jenže jak zavolám static
       metodu, když nemám entitu? Přes dynamicClasses?
       - jo, to by asi šlo).



2. Při smazání entity:
   - nastaví se jí flaga deleted
   - smaže se z disku
   - smaže se záznam z idProvideru

Dokud je záznam v idProvideru, tak určitě existuje alespoň jedna reference
na entitu. Tzn. nemusí být reference nikde jinde.

IMPORTANT: V metodě Entity.save() zkontrolovat flagu deleted.
  - takže se smazaná entita nesavne.

Co se stane, když si za běhu vezmu referenci na entitu a někdo tu entitu smaže?
- Entita pořád existuje v paměti (já se na ni odkazuju), ale má flagu deleted.
- Už není záznam v idProvideru
  - když se teď někdo zeptá idProvideru, jestli je entita smazaná, dozví se, že
    ano.
  - když se loadne někdo s referencí na entitu:
    - Zeptá se idProvideru a dozví se, že záznam nemá.
    - Checkne, jestli existuje save. Pokud ne, znamená to, že je entita
      smazaná.


Úvaha bokem: Hráčské postavy a unikátní jména
- hráčské postavy se nemažou (tj. delete nesmaže záznam z disku, pouze nastaví
  flagu deleted), ale může se teoreticky smazat jméno.
- přitom bych ale asi potřeboval možnost zjistit čistě dotazem na existenci
  souboru, jestli je entita smazaná. To nejspíš znamená, savovat hráčský char
  na dvě místa - pod stringIdčkem a pod unikátnímJménem.



Struktura dat:
---------------

  ./data
       /Account
         1-imt2xk99.json
       /Character
         4-imt2xk99.json
     /entities
       /Account
         6-imt2xk99.json
       /World
       /Room
       /Character
     /prototypes
       /World
       /Room
       /Character
          7-imt2xk99.json
          /Orc
            8-imt2xk99.json
     /unique_names
       /*
         Pro každé unikátní jméno jeden prázdný soubor. Podle jejich
         existence se zjišťuje, jestli je jméno volné.
         (teoreticky tu mohou být podadresáře, pokud bych chtěl mít víc
         nezávislých kategorií unikátních jmen)
       */
       Zuzka
       Rahman

- hmm, asi bych chtěl, aby se všechno, co patří k Accountu, savovalo
  do /Accoounts/Rahman, včetně všech charů na accountu, lodí, základen, atd.
  - i když je to otázka, dost značně to všechno zkomplikuje.
  - navíc počítám s tím, že "hráčovy" assety mohou žít svým vlastním životem,
    takže pak nejsou až tak úplně 100% hráčovy...
    (což znamená, že by se u některých entit měnilo, komu patří, takže by se
     pak savovaly na různá místa na disku... Asi na to spíš kašlat a savovat
     všechny entity stejně.)

PS: Smazání entity, která má být obnovitelná, ji prostě přejmenuje na
.json.deleted, není třeba ji přesouvat do jiného adresáře.

---------------------------
Co by bylo potřeba, aby se daly savovat playerovy entity do /Acccounts?

- každý savnutý odkaz na entitu by si musel pamatovat, jakému Characteru
  a jakému accountu to patří.
  - co když hráčova věc zůstane ve hře a vezme si ji někdo jiný?
    - měl by ji vůbec mít savnutou hráč, když je stále ve hře?
      Očividně se to může stát, když hráč napíše 'save' a následně věc někomu
      dá. V ten moment je má savnutou u sebe a dotyčný si ji může savnout taky.
      Tím se nevynutí save prvního hráče, takže ji nyní mají savnutou oba,
      pokud dejme tomu crashne mud.
    - když by každý z nich měl savnuté jen idčko, tak se pořád může stát, že si
      to idčko savnou oba. Pak se při loadu stane co? Budou mít oba dva
      referenci na stejný item?
    - když se budou s hráčem savovat jen reference, tak to půjde pořešit přes
      to, že item samotný má u sebe savnutou 'location'. Když při loadu
      location entity nebude odpovídat tomu, do čeho se loaduje, tak se může
      zase zahodit - znamená to, že o ni hráč po svém savu přišel a savnul ji
      někdo jiný.


[09:51] Rahman       : <64> Zacinam si cim dal vic klonit k tomu, nesavovat
                            itemy do player filu ale do /Objects
[09:51] Rahman       : <64> Hlavnim duvodem je obrana proti duplikovani itemu
[09:52] Rahman       : <64> Kdyz jeden player napise 'save', da item druhemu
                            playerovi, ten napise 'save' a nasledne spadne mud
                            bez savu, tak je ten item savnuty ve dvou pfilech
[09:52] Rahman       : <64> a kazdy z nich ma jako ownera jineho playera
[09:54] Rahman       : <64> zatimco kdyz bude u playera savnute jen stringove
                            idcko itemu a item bude jinde, tak timhle vznikne
                            stav, kdy item je savnuty dvakrat na stejne misto
                            a dva ruzni playeri maji na nej odkaz (tvari se, ze
                            je item jejich)
[09:55] Rahman       : <64> jenze item ma u sebe savnutou 'location', takze
                            kdyz se logne ten prvni player, tak mu muzu rict
                            'sorry, tenhle item uz ma nekdo jiny'
[09:56] Rahman       : <64> samozrejme to znamena, ze bude peklo rucne
                            vytahnout playera ze zalohy, protoze jeho itemy
                            budou rozstrkane vsude mozne
[09:56] Rahman       : <64> na druhou stranu to pujde celkem jednoduse
                            zautomatizovat, takze ho budes moct restornout za
                            behu primo ze hry
[09:57] Rahman       : <64> proste si vytahnes prislusnou verzi z gitu do
                            jineho adresare (protoze v gitu bude ulne vsechno)
                            a forcnes playera, at se loadne ze /zaloha/data
                            misto z /mud/data
[09:58] Rahman       : <64> a pri te prilezitosti to muze item po itemu
                            kontrolovat, jestli nahodou neexistuji v ostre
                            verzi a nema je nekdo jiny, takze se zabrani
                            duplicitam


Ad unique names
- možná bude lepší držet je v paměti, ono jich zas až tak strašně moc
  nebude. Takže asi vytvořit nějaký UniqueNamesManager.
  - v něm budou kategorie accounts a characters

Class inheritance tree
-----------------

NamedClass
- AttributableClass
  - SaveableObject
    - AutoSaveableObject
      - Entity
        - NamedEntity
          - Account
          - CommandInterpretter
            - ContainerEntity
              - GameEntity
                - Sector
                  - Area
                - Dimension
                - Realm
                - Room
                - World
                - Character

Ok, co jsou kořeny adresářového stromu?
- Account (respektive NamedEntity) (protože ./data/entities/Account)
- GameEnity (protože ./data/entities/Realm apod.)

Tzn při volání getSavePath():
- NamedEntity by měla vracet ./data/entities
- GameEntity by měla vracet ./data/entities
- Entity by asi taky měla vracet ./data/entities
- Account by měl vracet className + super.getSavePath()
  // A navíc to nebude moct bejt super. protože se to nebude volat na instanci,
  // ale na prototype chainu.



================================================

IDEA: Rozlišovat:
  - Adresář, kam se savne celá hra se vším všudy před bootem
    (a po bootu se z něj zase celá se vším všudy loadne)
  - A adresář, kam se savují player data v průběhu bootu...

Asi spíš jinak: Mít dvě gitové repository. Do jedné se budou
  commitovat změny v kódu (samozřejmě i s aktuálním stavem dat),
  do druhé zálohy dat (samozřejmě i s aktuálním stavem kódu.
- restore dat ze zálohy se bude provádět z běžícího mudu, prostě se ty
  entity natáhnou z /backup/data místo z /mud/data
Důvodem pro dvě repository je, že nechci, aby do programátorské nespamovaly
commity se zálohama...
(Možná to takhle jednoduše nepůjde, uvidíme...)


================================================

Undelete
---------

Problém: Někdo si schová referenci na char, který smažu.
  - v ten moment se maže záznam z hashmapy (stringId->entita).
  Následně provedu undelete (ve stejném bootu). Znova loaduju entitu
  z disku a měl bych ji napojit na už existující, protože si ji někdo
  stále pamatuje - jenže na tu už se nemám jak dostat, protože už není
  záznam v hasmapě.

Řešení: undeletnutelné entity nemazat z hashmapy.
  - Týkat se to bude asi jen player charů (lodí, designů a tak)

Problém: Někdo qitne s charem a pak se zas naconnectí
  - to je vlastně stejnej problém jako s tím undeletem: Nemůžu vyhodit
  záznam z hashmapy, protože bych se pak nedokázal napojit na instanci,
  na kterou si někdo stále drží referenci.

  Tzn. quitnutý char bude zůstávat v paměti
  - teoreticky na něj můžu držet jen weak link (dát ho do WeakMapy),
    takže se pak z paměti vyhodí aspoň entita - jo, to zní hezky, ale jak
    to udělat? Já potřebuju držet tu referenci na entitu

================================================

Použití node-weak:

Když vyrábím novou entitu, tak si do hashmapy dám strong referenci a současně
weak referenci. Vrátím weak referenci, která se bude přiřazovat ve zbytku kódu.

Když budu chtít entitu zahodit z paměti, tak:
- do strong reference v hasmapě zapíšu null
  - v ten moment můžu dokonce rovnou checknout, jestli weakRef.isDead() a pokud
    ano, tak zahodit celý záznam v hashmapě (protože nikdo jiný nemá referenci).
    Pokud není dead, tak si nechám weakRef, protože mě možná časem někdo bude
    chtít oživit.

- využití callbacku:
    Když se mi zavolá callback, tak můžu vyhodit celý záznam z hashmapy,
    protože to znamená, že nikdo už nedrží referenci na entitu.
    - když se mi někdo relogne, undeletne, nebo tak, tak se prostě dá nový
      záznam do hasmapy

================================================

Využití proxy:
  - Entita je proxy, která defaultně jen předává přístupy zapouzdřené entitě.
  - Když na Entitu zavolám delete, tak se v proxy změní metody get() a set()
    a místo předávání vnitřní entitě budou reportovat přístup na smazanou
    entitu.

- Teoreticky takhle půjde odchytávat i pokus o přístup na neexistující property
  (takže program nespadne - respektive nespadne na volání neexistující metody
   entity, ale může pořád spadnout, když přistoupím na to, co mi ta
   neexistující metoda "vrátí").

ÚVAHA: Využití Proxy k ošetřetní relogu bez nutnosti počítat reference:

    Lognu se

    Někdo si na mě vezme referenci

    Odlognu (save)

    Dotyčný zkusí na referenci přistoupit
    - Proxy checkne hashmapu a zakáže mu to

    (load )Znova se lognu
    - Vytvoří se nový objekt. Dotyčný má stále referenci na ten smazaný

    Dotyčný zkusí na referenci přistoupit
    - Proxy checkne hashmapu, zjistí, že objekt byl znovu vytvořený, takže
      přesměruje interní referenci na nový objekt
      (pro dotyčného se to tváří, jako kdyby objekt stále žil)




================================================

TODO:

- Domyslet novou strukturu dat
- Přejít na novou strukturu dat

- Líp vymyslet dynamicClasses
- Implementovat to

- otestovat node-weak


- Přejít z Idček na reference na entity


- otestovat Proxy


================================================

Game.createWorld()
{
- chci nové idčko

  // Tohle je asi ok
  this.world = SaveableObject.createInstance
    ({ className: param.prototype, typeCast: World });
}

Game.load()
{
  - potřebuju idčko loadnout ze souboru
    (world má unikátní save name, takze nepotrebuju znat id, abych vedel,
    z jakeho souboru se mam loadnout)

  /// Tady by melo byt: createInvalidReference();
  /// PS: Na to nemusim ani znat typ - respektive ano, musim ho zapsat do
  ///    handleru.
  this.world = SaveableObject.createInstance
    ({ className: 'BrutusWorld', typeCast: World });

  // Load current state of world from file.
  await this.world.load();
}

SaveableObject.loadFromJson()
{
  - tady se loaduje invalid reference, to uz mam napsane.
    (a dělá to EntityManager - to je důležité)
}

Tzn. asi bych nikde neměl sám volat SaveableObject.createInstance(),
měl bych volat EntityManager.createInvalidReference()
- proč rovnou invalid? Však klidně může být i valid, když zadám platné
  idčko a entita už bude v EntityManageru...
nebo EntityManager.loadReferenceFromJsonObject()
- to už se děje, ze SaveableObjectu
nebo EntityManager.createEntity()
- to ještě neexistuje. Místo toho tam je metoda add(), která přidá už
  existující referenci. Mělo by to asi být tak, že add() bude private
  a zavolá se automaticky.

[ok, už by snad měl jít zavolat load() na invalid referenci (ostatně i na
 valid) a mělo by to entitu loadnout a přidat do EntityManageru]

 IMPORTANT:
 - bude existovat jen jedna funkce na vyrábění nových entit (tedy s novým
   idčkem), a to EntityManager.createEntity().
   - nikde jinde nemusím vyrábění nového idčka řešit.

===============================================================================
===============================================================================

Ještě jednou proxies and references
------------------------------------

Jedna mapa (weak?):
- to nejde, protože do weak mapy se dá dát jen object
Entity ----------------> Proxy 

Proxy  --------------->  Entity

- Reference, kterou dávám k dispozici
  - ta ukazuje na proxy, za kterou je další proxy reference, kterou nedávám
    k dispozici
    - ta ukazuje na entitu

Id - potřebuju najít unikátní proxy

- Nic, asi to nemá řešení.

Plyne z toho:
--------------
- class EntityList nesmí interně držet přímo reference, protože by se pak
mohlo stát, že tam nějaká entita bude dvakrát (dvě různé reference na proxy
budou ukazovat na stejnou entitu).
  To samé platí pro všechny ostantní classy, které by chtěly držet reference
  na entity (ContainerEntity, Admins, atd.)

- ve skriptu se nebude smět porovnávat reference na entitu, tj. něco
  ve stylu if (actor === ch)...
Tohle je dost průšvih, budou z toho určitě vznikat chyby, které se budou
extrémně špatně hledat...
  Jediná útěcha může být, že časem do Javascriptu přibude nějaká featura, která
  to celé umožní udělat líp:

  [16:56] Rahman       : potreboval bych bud moznost predefinovat porovnavaci
                        operatory (abych mohl rict, ze jsou si dve entity
                        rovne, i kdyz maji ruznou referenci),
  [16:57] Rahman       : nebo mit moznost pouzivat weak reference (abych mohl
                        vratit existujici referenci a negenerovalo to
                        memoryleaky),
  [16:57] Rahman       : nebo mit moznost predefinovat assignment operator,
                        abych mohl pocitat, kolik referenci existuje.

===============================================================================

Ještě by šlo zvážit, že by se invalid entity reference nevalidovaly
automaticky. Tzn. že jakýkoliv přístup na invlid entity by byl chybný,
a to i v případě, že někdo jiný mezi tím znovu instancioval entitu stejného
idčka.
- nevyřeší to problém s porovnáním, protože to nemám jak trapnout.
  Pořád mi to řekne, že mám jinou entitu.
- nevyřeší to asi ani idlisty, protože mrtvá entita se z nich automaticky
  nevyhodí.
  - entita by si musela pamatovat, ve kterých listech je uložena (a stejně by
    to nevyřešilo proměnné s referencí.
- na druhou stranu to pomůže najít chyby, které by automatická revalidace
  reference zamaskovala.

===============================================================================

IDEA: Admin rights by se ještě daly udělat přes WeakMapu - savovat je
  jako info mimo objekt. Asi to ale není moc praktické