TODO: Zkontrolovat, že všude, kde něco dereferencuju, je to oifované
  (zejména v SaveableObjectu).

TODO: V SaveableObjectu sjednotit jména parametrů, aby to nebylo jednou
  'myProperty' a podruhé 'variable', když obojí znamená totéž.

TODO: Ještě jednou se zamyslet nad tím, jestli má smysl chybový výpis v apply()
  handleru InvalidValueProxyHandleru.
  - pravděpodobně nemá, navíc to pak spamuje při systémových voláních (výpis
  do konzole, util.inspect, apod..
[Asi tam fakt být nemá. Okomentováno]

TODO: V SaveableObjectu
  - operátor 'in' nefunguje na proxy, je třeba ho volat nad entitou.
  - to se týká i případu if ('saveIdToJsonObject' in variable)
[done] 

TODO: Vyzkoumat, proč se mi savujou skoro prázdný entity
[snad done]

TODO: TrimType.PROXY_HANDLER uvnitr get() by se mel trimovat jen o 4
[Snad done]

TODO: Přesunout EntityRecord do samostatného souboru

TODO: Jit trochu jinak na error messages:
  - Vsemu rikat ACCESS_VIOLATION a o co presne jde upresnit v doplnujicim
    message.
[done]


TODO: Poresit zacykleni pri vypisu stack trace pri invalid property accessu.
- a asi taky trimovani o jiny pocet radku nez pri ERRORu
[tak to uz zrejme necykli, nejspis jsem to necim opravil]

TODO: V abbrevSeachList.ts::170 se nejak divne maze z hashmapy.
[opraveno]

TODO: metodu dynamicCast() asi přesunout z EntityManageru do Entity.
[je presunuta do EntityProxyHandleru]

TODO: Otestovat, že prirazeni this opravdu priradi proxy
[Zda se, ze opravdu ano, uff!]

TODO: Úplně se mi nelíbí, že fci entityManager.createUniqueEntity()
 (a asi i createEntity()) dávám jako parametr stringovou reprezentaci
 typu a za ní ještě typ.
 - asi by bylo lepší udělat dvojice fcí, jedna (createDynamicEntity()?)
   co dostane i string a druhá, která si vystačí s konstruktorem classy.
   - nebo možná dát string jako volitelný parametr (kontrolovat to uvnitř
     funkce).
Jo a při tý příležitosti bych asi mohl udělat statické fce, abych nemusel
chodit přes Server.entityManager....
  (a nebo se na to vyprdnout a dělat to naopak vždycky, tj. zrušit tu
  existující statickou zkratku)

TODO: Sjednotit návratové hodnoty: Když něco není nalezeno, tak nevracet
  null, ale undefined


TODO: Zrušit z entity proměnné SAVE_DIRECTORY

TODO: createSystemRealm() a všechno uvnitř.
[done]

ÚVAHA: Monžná se přece jen vrátím k classe Id (- nakonec ne)
  - ne proto, že bych se chtěl zbavit přímých referencí, ale proto, že když
    si někdo říká o entitu na základě stringového idčka, tak musí dodat i typ,
    aby šla vrátit invalid entity se správně nastaveným typem v handleru (aby
    pak podle něj šla vytvořit správná instance).
Na druhou stranu ale kdy by se tahle classa použila?
- jako dočasná proměnná při savování
- jako dočasná proměnná při loadování
Držet si ji nikdo nebude, protož držej se reference a tyhle informace jsou
  schované v handleru.
S tím souvisí:
- kdo bude potřebovat volat entityManager.get()?
  - asi to samé, pouze SaveableObject.loadReferenceFromJsonObject().
  nebo ještě někdo?
  - z nejěkých důvodů jsem tam chtěl ošetřit, když je "id" null
[Tak nakonec ne]


TODO: EntityManager by neměl vyčítat data z JSON objectu - to má dělat
  SaveableObject.
[přesunuto do SaveableObjectu]

TODO: Classu EntityRecord asi vyhodit z EntityManageru do samostatného
  modulu.

TODO: metoda createInstance() by neměla být v SaveableObjectu.
  - místo toho by měla existovat Server.classFactory a na ní by měla
    být metoda createInstance().
TODO: Při té příležitosti do ní přeshnout i dynamicClasses, ať nestrašej
  v global objectu.


TODO: V SaveableObjectu (a možná i jinde) předávám do vnořených volání
 hromadu stejných parametrů.
 - zabalit je do objektu 'param', dost se tím ten kód zpřehlední.

TODO: EntityManager.proxyHandler by mozna nemuselo bejt pole (ale mapa).
  - nakonec to bude Set
[done]

TODO: Vytvořit modul EntityManager (again ;-))
TODO: Konstruktor Entity by měl vracet Proxy.
  IDEA: Konstruktor Entity bude vracet 'new Proxy()', takže nejpůjde mít
    nezaproxynovanou entitu.
TODO: Sebrat IdProvideru funkcionalitu na trackování idček.
  [done]
TODO: Předělat IdListy na EntityListy.
TODO: Ošetřit savování referencí na entity v SaveableObjectu.
  - musí se savnout Id záznam místo entity.
  - při loadu se zase jen načte Id záznam
    - možná to bude znamenat, že entity proxy musí umět ještě jeden stav
      (kromě entity = null). Nebo možná prostě jen pamatovat si idčko
      (protože EntityProxyHandler teď vlastně slouží jako původní class Id).
TODO: Přetypovat idčka z Id na string.

TODO: Odchytavat pristup na neexistujici property.
[done]


TODO: Při loadu game entity kontrolovat, že savnutá 'location' (její stringové
  idčko) odpovídá tomu, do čeho entitu loaduju (stejné stringové idčko).
  - pokud neodpovídá, tak odmítnout entitu přiřadit
    (Tohle ošetřuje situaci, kdy se jeden player savne, dá item druhému
    playerovi, ten se savne a následně spadne mud. Tomu prvnímu to při loadu
    item nedá, protože nebude sedět location. Tomu druhému load projde.
    - to samé platí i pro restorování ze zálohy.)


Pozn.: Accounty se mi savují postaru do /Accounts/Rahman.json, což je nakonec
  asi dobře. Každopádně to chce zkontrolovat.

TODO: Odstraněním saveTree z PrototypeManageru jsem přišel o informaci, jaké
  prototypy se mají načíst při startu hry.
  - nějak to pořešit.
Jedna možnost je, prostě prolézt celý adresář /Prototypes

TODO: Opravit savovani entit.

TODO: Opravit AttributableClass
  - protože super.metoda dělá něco trochu jiného, než jsem si myslel
    (nevolá metodu přímého předka, ale toho předka, který ji jako první
    má jinou. Tzn. to může přeskočit několik stupňů dědění. A já je
    v AttributableClass potřebuju projít všechny).
  - toť otázka. Není to náhodou tak, že se mi ta statická proměnná
    automaticky zdědí, takže ji prostě uvidím na this.constructor, ať
    je deklarovaná na jakémkoliv předkovi?
    - v tom případě tam naopak šaškuju zbytečně složitě...
[Hmm, tak zjevně jsem to dělal zbytečně složitě.]


TODO: Opravdu to udělat, zní to rozumně.
BIG IDEA: Zuršit ASSERTY.
  Místo toho používat:

  if (condition === false)
  {
    ERROR
    (
      "message"
    );
  }

  - Ve skutečnosti stejně ty asserty píšu vždycky do podmínek a navíc ten
    zápis if (!ASSERT(condition, "message")) není moc intuitivní.
  - vyřeší to problém s tím, že se mi provádí kód na skládání stringu,
    přestože string není potřeba.



TODO: Korektne vycistit SaveableObject od pozustatku EntityId.
  (protože EntityId nemůže být includnuté v SaveableObjectu, byl
   by to křížový include (nebo je z něj zděděné). On to sice typescript
   compiler povolí, ale zuchne to pak v runtimu).

TODO: Nad AdminLevels by asi fakt byl lepsi enum.

TODO: Typescript používat inline místo linkem.

TODO: Asi se fakt vrátnit k Id místo EntityId.

IDEA: Přesunout fci getTrimmedStackTrace do modulu Mudlog a zrušit UTILS.

TODO: Specialni kod na loadovani idcek musi byt primo v SaveableObjectu,
  ne az v Entity. Sice jen Entity muze mit idcko, ale to neznamena, ze si
  nekdo nemuze vytvorit SaveableObject, do ktereho si da idcko na JINOU entitu.
[done]

TODO: Zavest pocitadlo rozdanych referenci v IdManageru
  - kdyz klesne na 0, tak je mozne idcko vyhodit z manageru.
- Tak jinak, misto toho idProvider drzi idcka ve WeakMape
[done]

IDEA: Idcko se automaticky zaregistruje v IdManageru, pokud jsou parametry
  konstruktoru definovane.
  - diky tomu se mi nestane, ze by si nekdo vytvoril idcko (pres new EntityId)
    a nevlozil ho do IdManageru (jako se mi povedlo s WorldId).
  - ono se mu to teda asi nepovede ani tak, kdyz bude idProvider schovany
    uvnitr IdManageru. Ale takhle aspon usetrim kod, ktery se stejne musi
    vzdycky provest.
[asi done]

TODO: protected -> private v EntityId
[done]

TODO: Nastavovat idčkům status.
[snad done]

TODO: V SaveableObjectu sjednotit fce isPrimitiveObject, isDate, atd.
      - pokud bude fungovat .constructor.name, tak používat to.
{nahozeno, je to treba otestovat}

TODO: Všude po volání entityId.getEntity() dát check na to, že result
      není null.
      (entityId.getEntity() může vrátit null. Dereference by pak shodila hru)

IDEA: Sloučit AbbrevSeachList a IdSearch list do jedné classy
      (AbbrevSearchList prostě bude zděděnej z IdListu)
      Přidat classu NameSearchList (zděděnou z IdListu)
[done]

TODO: PlayerConnection přejmenovat na Connection
      a Server.playerConnections na Server.connections
[done]

TODO: V Server a Game oddělit managery od idListu a dát k tomu komentáře,
      čím se to liší.
[done]

TODO: IdList přesunout do /shared
      (IdSeachList asi taky)
[done]

TODO: Všechny XXXManager přejmenovat na XXXList a zdědit je z IdList nebo
      IdSearchList
      - nebo ještě druhá možnost, místo AccountList prostě Accounts
      (ale asi raději AccountList, Accounts je divné jméno pro classu)
TODO: Všechny xxxList přesmenovat na xxxs (characterList na characters).
TODO: EntityContainer přejmenovat na EntityManager
      (bude z toho jasnější že je jen jeden)
TODO: Container přejmenovat na ContainerEntity
TODO: CommandInterpretter přejmenovat na CommandInterprettingEntity?
      nebo CommandEntity? CommandProcessingEntity? - to zní nejlíp.
      - hmm, to možná ne, to zní divně...
      [necham CommandInterpretter]
[done]

Obecně se držet schématu:
- Manager obsahuje přímo instance
  - EntityManager obsahuje entity (což jsou instance)
  - FlagNamesManager obsahuje instance FlagNames objektů
  - PrototypeManager obsahuje instance Prototypů

- List obsahuje idčka
-------------

TODO: Přidat classu IdSearchList a přesunout do ni abbrevSearchList z IdListu.
[done]

TODO: game/EntityContainer přejmenovat na něco jiného
      - buď EntityIdContainer
      - nebo GameEntityContainer
      - nebo prostě Container?
Nebo možná raději přejmenovat /shared/EntityContainer na EntityManager?
[done]

TODO: Pokud budu managery dědit z idListu, tak to udělat
      i s PlayerCharacterManagerem
[done]

TODO: Přesunout NamedEntity do shared
  (a možná i další classy).
[done]

TODO: Id přejmenovat na EntityId (a classu EntityId zrušit).
  - tohle si asi ještě rozmyslím... I když...
[done]

TODO: Ještě jednou zvážit typescriptové enumy (Entity.satus, atpod.).

TODO: Výhledově dát 'dynamicClasses' někam jinam než do global objectu.
  - asi do serveru
TODO: Výhledově nějak líp pořešit dynamické classy než přes dynamicClasses.ts
  (možná všechny moduly requirovat místo importovat?)

TODO: S loadováním/savováním hashmap jsem se, zdá se, radoval předčasně
  - opravit loadování SaveableObjectů uložených v hashmapě.
[snad už ok]

TODO: Asi všude zrušit property deklarované jako parametry konstruktorů
  (ne vždy se konstruktor volá se všemi parametry a pak se stane to, že
  property není inicializovaná. Kromě toho to znepřehledňuje kód - hůř
  se hledá, co je nějaká property zač.)

TOFIX:
ARGH - directReference v Idckach je udelana spatne :\
  - dokud vsichni odkazuji na Idcko, ktere si drzi samotna entita,
  tak je to asi ok. Ale muze se stat, ze si nekdo vytvori vlastni
  instanci Id - třeba po loadu ze souboru. V ten moment se to rozbije,
  protože neexistuje jediná instance Idčka pro danou entitu...
Jak to spravit?
  - instance Idček asi budou muset být v příslušném containeru spolu
    s entitama. Takže (i při loadu) si nebudu nikdy vytvářet vlastní Idčko,
    vždycky si budu muset říct containeru, aby mi Idčko vyrobilo
    (já mu dám stringId a on mi buď vrátí referenci na existující instanci Id,
    nebo si ji vyrobí...)
[zatím netestováno]

TODO: Zkontrolovat všechny komentáře v modulu Script

TODO: Kontrola, že skript dostal správné parametry.
  - A to ve fci Script.scriptFunction (deklarovane v constuctoru classy Script)

TODO: Nastavitelný Lock proti opakovanému spouštění běžícího skriptu.

TODO: script.recompile

TODO: script.rename (nebo možná Prototype.renameScript)

TODO: co se stane, když mi umře entita, na které běží async skript?



TODO: Checkovatko na memoryleaky


TODO: entity.stopScript(scriptName);
TODO: entity.stopAllScripts();
- musí to vycházet z entity, ne ze Skriptu
[idea has been dropped. attachovat/detachovat scripty na entity nebude možné]



TODO: Casem odstranit consoli ze skriptoveho sandboxu.

TODO: Immlevely ukladat nekam jinam nez k charu
- (asi do AccountManageru?)

TODO: Skripty v Prototypu dávat do hashmapy místo do pole (protože bude třeba
  umět skript najít například při 'edit TutorialRoom.onLoad');
[done]

TODO: Do Script.code dávat jen tělo funkce. Hlavičku funkce a {} tam přilepí
  engine.
[done]

TODO: Změnit odkaz na prototyp ve Scriptu na jméno prototypu.
[done]

TODO: Otestovat skripty
  - ukládání do souboru [done]
  - zkompilovat a pustit dva různé skripty [done]
  - rekompilace běžícího skriptu [done]
[done]

TODO: Naucit SaveableObject savovat a loadovat obycejne objekty.
- ono by to v zásadě mohlo být ok, pokud je to dynamická classa a má
   className, tzn. by ji bylo možné instanciovat. Ale to už rovnou můžu
   trvat na tom, aby to byl SaveableObject.
[Aha, on už to umí. Odmítá savovat jen classy, které nejsou obyč Object
 a nejsou zděděné ze SaveableObjectu, což je asi dobře.]

TODO: Nahackovat savovani staticke property 'className'
[done]

TODO: Ještě přece jen zvážit, jestli nepoužívat nepojmenované classy
  (tj. že Class.constructor.name bude "") a nedávat jim className jako
  moji vlastní property.
  - ono to celkem dává smysl, protože to prostě nejsou statické classy.
[budu používat nepojmenované classy]

TODO: Změnit NamedClass, aby className nebyla property na instanci,
  ale statická property (tj. na constructoru).
[done]


TODO: Velmi výhledově se zamyslet nad lepším formátem savutých skriptů
  (hjson? samostatný soubor?), protože je to přece jen kód a bude se
  například diffovat v gitu (co na něm který immortal změnil?)

TODO: Zjistit, jestli by classDeclarationScript nemohl byt zkompilovany
  jen jednou (a brat si parametry ze sandboxu).
[pokud mi bude fungovat vyrábění class bez skriptu, tak tohle nebude potřeba]

TODO: Ucesat Prototype.setMethods()
[done]

TODO: assert na internalFunction !== null
[done]

TODO: Testnout, jestli můžu z jednoho sandboxu vyrobit dvě skriptové funkce,
  které budou mít různé skriptName.
[done, nemůžu]

IMPORTANT TODO: U prototypu savovat jen přetížené properties, ne ty
  z prototypu.

TODO: Instance savovat do /data/instances

TODO: Charactery savovat na disk v lowercasu
  - ze dvou duvodu:
    1) aby neslo vytvorit soucasne char Zuzka a zuzka
    2) aby se slo prihlasit case-insensitive verzi
  - nebo se na to vykaslat a enforcovet Prvnivelke pismeno ve jmene charu?
    (Asi prece jen bude hezci, kdyz na disku budou chary savnute s velkym)
  - kazdopadne to case-insensitive prihlaseni by fungovat melo.

TODO: Zkontrolovat, ze jsem Flags-related classy prejmenoval spravne
[snad jo]

TODO: Presunout flagNamesManager ze Serveru do Game
 - asi to nebyl dobrej nápad, protože když bych chtěl mít account flagy,
   tak nebudou fungovat bez toho, aby existovala hra.
   - nejspíš to budu muset přesunout zpět.
[done (přesunuto zpět)]

TODO: Optimalizovat savovani prototypu, kdyz se zmeni jen jeden prototyp
  (takze neni treba savovat uplne vsechny prototypy)
  - mozna metodou Prototype::save(), ktera zavola save prototypeManageru
    na konkretni prototyp?

TODO: Pokusit se sjendotit dynamic typecast (metodou z UTILS?)
  - ideálně ji přesunout někam jinam (někam do entity inheritance chainu)

TODO: Projít všechny FATAL asserty a zkontrolovat, jestli musí být FATAL.

TODO: Projít nově vytvořená data a opravit všechny chyby

TODO: Při savu Map objectu je vždycky první prvek 'undefined'
[fixed]

TODO: Přejmenovat FlagsData na FlagData a FlagsDataManager na FlagDataManager
[done]

TODO: Zkontrolovat, že dobře loguje BAD PW attempt

TODO: Promyslet a zkontrolovat, jak SaveableObject pracuje s null hodnotama
- nejspíš je tam navíc ten ASSERT, kterej to kontroluje, null už by to mělo
  zvládat (buď se vytvoří objekt správného typu, nebo se přímo přiřadí hodnota
  loadnutá z JSONu)

TODO: Možná mám někde zbytečně metody save() a load()
  - jsou v IdableSaveableObjectu (takže pokud je něco zděděné přímo ze
    saveableObjectu, tak to tyhle metody nemá.)

TODO: Zacina bitvector od nuly nebo od jednicky? Zjistit.
[zjevne od nuly, takze to mam spravne]

TODO: Loadovani/savovani classy 'Map' v SaveableObjectu
[snad]


TODO: Adresářová struktura prototypů (a asi i v rámci PrototypeDataManageru)
[snad done]

TODO: Když neexistuje adresář /data, tak vytvořit defaultní flagsData
  a prototypeData
  - respektive možná bude stačit ve flagsDataManageru hodit loaded flagu
    na true, aby se flagy vytvářely samy...
[asi ok]

TODO: Nekam naimplementovat metody setPrototypeData() a setMethods() :-)
- nekam do GameEntity chainu, asi na urovni /shared.
 (Nakonec jsou v PrototypeData, protože je to potřeba setovat zvenku do 
  class_constructor.prototype)
[Zatím je jen setPrototypeData()]
TODO: setMethods()
TODO: Skripty


TODO: V PrototypeData doplnit typ k predavanym typum (ja vim, zni to divne...)
[Jakz takz, nekde jsem neprisel na to, jak na to]

TODO: Hodit ASSERT_FATAL do samostatneho modulu (a fci getTrimmedStackTrace()
  taky, aby se dala includnout z obou assertu).
[done]

TODO: PrototypeData a PrototypeDataManager presunout do /shared
[done]

TODO: Zvážit, jestli nedávat dynamické classy (repsketive jejich konstruktory)
někam jinam než přímo do global objectu (asi do global.dynamicClasses ?).
[done]
TODO: Popravdě možná spíš pod server, nebo tak něco... Těžko říct.


TODO: Zrušit prefixy z flagů.
[done]

TODO: vsechna createNew asi prejmenovat jen na create (když něco vytvářím,
  tak je jasné, že to bude nové).
[done]

TODO: Zvážit, jestli nepřejmenovat všechny proměnné typu newArray (zrušit new).

TODO: Přidat do SaveableObjectu savovani classy Map.
  (Ono to možná funguje samo, chce to každopádně zkontrolovat.)
  - tak samo to opravdu nefunguje
[done]

TODO: implementovat flagy (bitvector engine).
[done]

TODO: Přidat do accountu seznam charů, které mají admin práva (nebo možná na
  char flagu, že má admin práva - checkne se this.playerConnection, přes ni
  account a na něm je adminLevel).

TODO: Udělat vlastní FS modul, ať jsou všechny souborové fce na jednom místě.
[done]

TODO: Když se zakládá první character, udělat z něj implementora a dát ho do
  SystemRoom.
  - možná se bude hodit držet si systemRoomId ve Worldu jako proměnnou.
[jakz takz]
- Zatim spis nejakztakz
TODO (stále)

TODO: Nastavovat entity.location (kdyz entitu vkladam do nejake jine).
[Snad done (mozna ne vsude)]

TODO: Všude, kde se to hodí, předělat předávání parmetrů. Předávání objektem
  dělá kód mnohem čitelnější .

TODO: Používat 'new Map' místo 'new Object' (hlavně proto, že dynamicky
  generované klíče mohou kolidovat s existujícíma properties na objektu).
  - vyzkoušeno a přidáno do Saveableobjectu
TODO: Udělat to všude

IDEA: Udělat z IDčka generic - id.getObject() pak vždycky vrátí správný typ.
[Tohle nepůjde]
- místo toho id.getEntity() dělá dynamický typeCasting.
[done]

TODO: predelat vsechna idcka v savech na EntityId
- to asi pořeším tím, že vyrobím celý svět znovu.

TODO: Pri vytvareni noveho sveta generovat mistnostem nejake defaultni
  RoomInfo.
  (A to asi tak, ze se pri vytvareni nove rommy vytvori automaticky, pokud
  konstruktor nedostane jako parametr template - nebo mozna dve funkce, jedna
  na vytvoreni templatove roomy a druha na vytvoreni odvozene roomy?)
/* Predelavam cely koncept prototypu, takze tohle bude cele jinak */

TODO: Zprovoznit prikaz look (zatim asi jen do roomy)
[kostra by snad byla]

TODO: Loadovat chary do konkrétní roomy.
[To je tak napul. Rahman ma nastavenou 'location', Zuzka ne a nove zalozene
chary taky ne]

TODO: Zprovoznit příkaz na založení nové entity (na Brutusu se tohle děje,
  když dám editovat dosud neexistující objekt)


TODO (hodně výhledově): Zajistit, aby se ze skriptů nedal nastavovat
  Account::adminLevel a nedaly dělat věci, na které je třeba adminLevel > 0.
  (viz ./documentation/code_architecture/admins)

-------------

TODO: Idcka dostala přímou referenci na odkazovaný objekt
  - při vytváření objektu je třeba tuhle referenci v idčku inicializovat
    (je to parametr constructoru)
  - a při mazání objektu (odebírání ze seznamu objektů) ji zase invalidovat.
[snad done]

TODO: V AbbrevSearchListu nahradit prime odkazy na GameEntity Idckama (idcko
  ma ted v sobe primy odkaz, takze to nebude vyrazne pomalejsi).
[snad done]

TODO: Otestovat AbbrevSearchList
  - pridat do nějakého roomu pár characterů
  - implementovat příkaz tell (globální search)
  - implementovat nějaký social do roomu (search v roomu)

Úvahy o hot reloadu
  - nakonec asi bude nejjednodušší udělat si to růčo, podobně jako
    save/load. Nejspíš tak, že se po reloadu modulu vytvoří instance
    příslušné entity a všechny existující entity v game entity containeru
    si vždycky najdou svůj nový "prototyp" (nejspíše podle className),
    projdou všechny svoje properties (jdou projít i metody?), metody si
    přiřadí ty z nového "prototypu", existující property si nechají
    (možná zruší ty, které na novém "prototypu" nejsou) a přidají ty, co
    má nový "prototyp" navíc - zkopírováním, takže budou inicializované
    podle nového kódu.
  - reload proběhne automaticky, protože poběží watch na změny příslušných
    souborů.

TODO: Zprovoznit resolvování aliasů složených z více klíčových slov
   v AbbrevSearchListu:
   - Dám do něj jednotlivě všechna klíčová slova z alias listu.
   - Při heldání je všechna matchnu, čímž dostanu n polí se seznamem entit
    "slyšících" na dané jméno. Ty následně projdu a vytvořím seznam idček,
    které se nachází ve všech těchto polích.
[snad done, zatím netestováno]

TODO (výhledově): Dodělat do AbbrevSearchListu funkčnost, že dokud je v něm
  málo záznamů, tak se vůbec nebude konstruovat vyhledávací struktura, prostě
  se lineárně projde pole aliasů (to proto, aby se zbytečně nezabírala paměť
  vyhledávací strukturou pro pár mobů v roomě, pát itemů v inventáři, atp.)

TODO: Vsude doplnit metodu getErrorIdString() a dusledne ji pouzivat v
  chybovych hlaskach.


TODO: OLC




TODO: Checkovat, ze loadnute id odpovida idcku, podle ktereho jsem
  entitu naloadoval.
  (a taky ze id odpovida nazvu souboru, pokud entita neni unikatni)


TODO: Zautomatizovat protopyování - asi by to měly umět všechny gameEntity
minimálně do té míry, že si budou držet odkaz na prototyp (idčko) a budou
automaticky prototypovat 'name'.

TODO: Do zahlavi souboru nakreslit stromy dedicnosti.

TODO: Udelat tridu Command, do ktere se vrazi cely command string, a ktera
  s nim bude umet pracovat (parsovat argumenty, atd.)
- Tohle je otazka. Koukal jsem na to a mozna to neni az tak dobry napad,
  v ruznych situacich se command parsuje ruzne (kazdy skill to muze delat
  jinak, napr.)

TODO: Zkontrolovat, ze datove properties, ktere maji get i set a pri
getu a setu se s nima nedela nic vic nez prirazeni a cteni, jsou rovnou
public.

TODO: Ve vsech classach hodit protected data na konec.
- mozna spis vsechna data k sobe a treba ten blok s deklaraci dat jeste nejak
  graficky odlisit, treba odsazenim


---------------------------------------

TODO: Upravit LobbyProcessor, aby prompt posilal pres generatePrompt()
[done]
- Pro AuthProcessor to neni dobrej napad, vedlo by to ke spouste internich
  stavu

TODO: v metode PlayerConnection::generatePrompt()
/// TODO: switch na stage lobby processoru by mel byt v LobbyProcessoru
[done]

TOFIX: Asserty pri connecteni z ruznych terminalu
[Co jsem vedel tak fixed]

TOFIX: Stalo se mi, ze jsem se pripojil, jeste nez se neco zinicializovalo,
  takze jsem nedostal menu.
  - a uz asi i vim, jak se mi to stalo: Nalogoval jsem az do hry a zabil
    putty (zavrel connection), nasledne jsem se pokusil znovu prihlasit.
  - bude to nejspis tim, ze zatim nemam implementovane korektni zavreni
    connection, kdyz player shodi connection, zatimco je ve hre.
    (viz PlayerConnection::close(), prvni vetev ifu)
[nejspis fixed]

TOFIX: Kdyz naloguju, vlezu do hry, quitnu a zatimco jsem v menu, tak se
  priloguju pres novou connection, tak to do logu vypise:
  "Player Rahman [::1] closed connection before logging in" 
  - zrejme se pri quitu ze hry neco nenastavi spravne.
- asi je spatne jen hlaska. Je spravne, ze je account null - byl setnuty
  na null proto, aby ho connection neodlogovala (protoze jde o reconnect)
  Ve fci PlayerConnection::onSocketClose() by mel byt switch podle
  stage lobbyProcessoru, ne jen test na to, jestli je je account null.
Pozn.: stage lobbyProcessoru bych nemel switchovat v metode PlayerConnection,
  mel bych na to udelat metodu v lobbyProcessoru.
[fixed]

TOFIX: Kdyz si uzurpnu connection, tak se nezavre
[fixed]

TODO: stage ve vsech managerech predelat z intu na stringy, at je pri
  debugovani videt, co je to za stage.
[done]


TODO: fixnout SYSTEM ERRORY, ktere vznikaji tim, ze se spusti 'onError'
event po zavreni connection
- mozna se to vyresi, kdyz pri zavirani socketu odstranim listenery
  na data:
    socket.removeAllListeners('data');
- tak ne.
[snad fixed]

TODO: Zprovoznit start z neexistujicich dat
(musi se vytvorit world, v nem 1 realm, v nem 1 zona, v ni 1 room)
[done]


TODO: Opravit barvy
[done]


TODO: loadovani a savovani obyc objektu (nezdedenych ze SaveableObject)
- kdyz objekt nema loadFromJsonObject, tak do nej proste priradit to, co se
  loadnulo z jsonu.
- tohle je potreba kvuli loadovani Date objektu.
- nebo mozna rozpoznavat, ze jde o Date object, tezko rict. Tohle prirazeni
  by mohlo vest k tomu, ze objekt nebude mit vsechny properties, ktere by mel
  mit.
  - asi by bylo lepsi detekovat, ze to je Date object...
[done]

TODO: Misto this.isSaved pri loadu/savu checkovat
  ClassAttributes.getAttribute(className, property, attribute);
[done]

TODO: Poresit radkovani pri posilani menu
/*
  Kdy se vypisuje menu:
  - pri nalogovani do hry
      (to jde tesne po prikazu a musi byt odradkovane)
      - tady by ve skutecnosti melo byt nejdriv MOTD a po nem "Pres return"
  - pri quitu ze hry
      (to jde po bloku textu, nema byt odradkovane, protoze odradkovani zaridi
      engine)
  - invalid option v menu (vypise se znovu jako prompt)
      (odradkovane ma byt v tomhle pripade "That's not a menu choice, takze
      menu jde opet po bloku jako prompt)
*/
[snad done]

TOFIX: Ponastavovat isSaved = false vsude, kde je to potreba
[snad done]

TOFIX: abbrevSearchList by nemel byt case sensitive
[done]

TOFIX: Do abbrevSearchListu se ocividne nedava posledni prvek
- a naopak se tam dava i prazdny string
[done, fixed]

TOFIX: Prvky v poli ocividne savuji saveRequests property
[tak prvky v poli se savovaly spravne, chyba byla v hashmape, coz je obyc
 Object]

TODO: Za prompt pridavat mezeru (aby byl player input od promptu oddeleny)
[done]

TODO: Fixnout "Invalid prompt >" pri "That's not a menu choice!"
[fixed]

TODO: Nejspis budu muset zrusit zrani newlinu na konci inputu, holt si to
  koderi budou muset hlidat sami. Bude to potreba na to, abych na patricnych
  mistech vyrobil vicenasobne odradkovani.
/*
  - mozna by se to mohlo kontrolovat v ramci sendAsBlock(), tj. kdyz to konci
  promptem. Tam se mezi prompt a blok automaticky prida mezera (pokud player
  nema brief mode) a asi nikdy nebude hrozit, ze by tam mely byt dve.
  - tohle by asi mohlo i stacit, btw. Drtiva vetsina herniho outputu bude
  rozhodne posilana jako blok (urcite sendToChar(), urcite act()).
*/
/*
  Tak ne, je to blbost. Po bloku bez promptu stejne nasleduje newline a po
  promptu naopak logicky byt nesmi, jinak by hrac psal na novou radku misto
  na stejnou.

  Ve skutecnosti je nekde potreba newline pred outputem, protoze je treba
  odradkovat po odeslani prikazu, a to se jinak udelat neda.
*/
[rozhodnuto: Newliny na konci outputu se zerou, je povolena newline pred
outputem - pouziva se na oddeleni outputu od player commandu]

TODO: Vyzkoumat, jak je to udelane, ze v putty neni pri zadavani videt heslo

TODO: Poresit barvu player inputu
/*
  Zjevne se pise barvou, kterou naposledy poslal mud.
  - tj. asi by to chtelo na konec kazdeho stringu prilepit &w.
*/
[done]

TODO: Poresit automaticke radkovani prikazu.
/*
  Uvaha: Za odradkovavani VZDYCKY zodpovida engine, tj. zadny send_cosi() prikaz
  nesmi koncit enterem
  - tohle mozna enfocnout v kodu - ASSERTEM a tim, ze se pripadny enter
    automaticky odstrani.
  - povolene jsou pouze entery uvnitr stringu, pokud ma byt viceradkovy

  TODO: Zajistit, aby to takhle opravdu bylo, i v prubehu logovani do hry.

  TODO: Sjednotit, jak se budou entery psat - asi vzdycky '\n' s tim, ze
    se to pripadne tesne pred odeslanim hromadne preklopi na '\r\n'

  Pozn: Matne si vzpominam, ze pri posilani progressbaru bylo potreba
    rozlisovat mezi sendem, ktery se ma odradkovat, a ktery se odradkovat nema
    - respektive mozna to bylo jeste jinak, ze se zapnul mod "ted posilam
    updaty progressbaru", pri kterem se neodradkovava nic.
*/
/*
  Je to trochu jinak:
  - za promptem nikdy neni newline, takze se prikaz pise rovnou za nej. Promt
    jsou i vsechny prikazy v menu a tak.
  To znamena, ze je treba rozlisovat, jestli se posila prompt, nebo neco
  jinyho.
*/
[snad done]

Zrusit savovani IdProvideru, misto toho k idcku prilepovat boot timestamp.
[done]

Zrusit prvni parametr z IdProvider.generateId()
[done]

TOFIX: Po quitu nebo reconnectu je nejspis nastaveno provazani
  s playerConnection, opakovany quit nezabere (respektive pak vubec nefungujou
  prikazy)
  [done]

TOFIX: qui spusti doQuit() misto doQui()
[Fixed]

---------------------------------------------
---------------------------------------------
---------------------------------------------
---------------------------------------------

Important TODO: Saving request buffer na savovani lastIssuedId
[Done - IdProvider ted vyuziva mnohem vic funkcnosti ze SaveableObjectu,
 vcetne bufferovani save requestu]

---------------------------------------------

TODO: Zrusit pevne idcko worldu. Bude se loadovat ze souboru
world.json, kde je ulozene.
[Done]

---------------------------------------------

TODO: accountName prejmenovat na name, at se savuje na zacatek souboru.
[Done]

---------------------------------------------

TODO: Udelat hack do SaveableObjectu, ze kdyz ma entita property 'name',
  tak se savne jako prvni (jestli to teda pujde).
[done]

---------------------------------------------

GameEntity by mel byt IdContainer<Id>
- tedy container Idcek
[Done - obsahuje IdList]

Staci mi, ze se idcka davaji do hashmapy?
- nestaci, protoze potrebuju pevne poradi
[Done - IdList ma Array idcek]

V cem se lisi:
EntityManager, IdContainer, EntityContainer?

IdContainer
/* Mel by se jmenovat asi spis IdableItemsContainer */
- neni z niceho zdedeny
- je to template (IdContainer<T extends IdableSaveableObject>)
- itemy jsou v hashmape
Umi:
  - pridat item pod existujicim idckem
  - vygenerovat itemu idcko a pod nim ho pridat
  - odebrat item z containeru
  - odpovedet, jestli je item daneho idcka v containeru
  - vratit item podle idcka (pres hashmapu)
IMPORTANT: IdContainer nedrzi idcka, ale primo itemy!

EntityManager
- neni z niceho zdedeny
- je to template (EntityManager<T extends GameEntity>)
- vubec si nedrzi idcka ani itemy, drzi si pouze abbrevSeachList a uniqueNames
Umi:
  - pridat item pod existujicim idckem
  - pridat novy item do Game.entities (tam se mu vygeneruje idcko)
  - checknout, jestli je entita v Game.entities (nikoliv jestli je v manageru)
  - vratit entitu (vezme ji z Game.entities, necheckuje, jestli mu idcko patri - nema jak)
  - odebrat entitu z manageru
- jestli ma entita unikatni jmeno nebo ne je vlastnost entity, manager ji podle toho zaradi do
  seznamu unikatnich jmen nebo ne

EntityContainer
- je zdedeny z predka GameEntity (EntityContainer extends CommandInterpretter)
- zatim nema nic, ale mel by mit SaveableArray idcek
- mel by asi umet so same, co EntityManager (ale unikatni jmena ho asi nezajimaji)
[Done - jmenuje se to IdList]

save() a load() by mel automaticky savnout/loadnout i vsechny obsazene entity,
aby se nestalo, ze loadnu container, ale ne to, co je v nem.
[Done]

Zaver: GameEntity by v sobe proste mela mit entity manager
[Done - je to tochu jinak, misto manageru je ted classa IdList, ktera v sobe
 drzi seznam idcek a umi v nem vyhledavat.]

------------------------------------------------------------------------

Ke zvážení: Dávat před string idčko nějakou předponu, třeba e jako entity, a jako account?
- teoreticky by se pak dala generovat "spotřební" idčka (třeba timery) s jinou předponou zase
od začátku
[Zatim na to kaslat]

Nesavovat playerConnectionId
[done]

Load/save entityContainerů
[asi done]

Check, že existují adresáře, do kterých se mám savnout (možná je automaticky
vyrobit, pokud neexistují?).
[done]



-----------------------------------------------------

TODO: Implementovat binarni vyhledavaci pole na hledani abbreviationu.
[nahrubo asi done. Je to hashmapa]

TODO: Pridelat do entity manageru trackovani neunikatnich jmen.
[snad done]

TODO: Z protected metod zrusit predponu 'my', stejne ji vetsinou nepouzivam.
(u dat zustane)
[zruseno i u dat]

------------------------------------------------------

Hodne vyhledove:

[23:49] Huan         : jiste ze muzou vracet. promise.resolve(navratovahodnota)
[23:50] Huan         : a presne tohle streamline resi
[23:50] Huan         : a resi i ty exception

[exceptiony jsou jakz takz poresene tim, ze se odchyti a vyhodi znova, takze
to vypise stack]

------------------------------------------------------

Vyhledove rozbehat tslint





===============================================================
Uvahy k prototypovani, skriptovani, hot reloadu, etc.
-------------------------------------------------------


    /*
    // TEST:
    let script = "return 'Changed function!'";
    this.location.getEntity().printContents =
      <() => string>new Function(script);

      - Tohle funguje. Znamena to, ze skript muze byt ulozenej
      jako string a muzu ho v runtime povesit jako metodu na nejaky
      objekt (novou nebo existujici).

      - otazka je, jak udelat wait

      - chybi odolnost proti zacykleni (ale to zas neni tak zasadni, to
      se stava malokdy)

      - neni videt this, musi se predat jako parametr (coz je ale asi ok,
      tak se chovaji i brutusi skripty).

      - nejde volat jine funkce, pouze metody toho, co se preda jako
      parametr (nemam to ozkousene, ale snad jo). Coz je ale asi spravne,
      aspon je to odolne proti zneuziti.

      - musi to byt javascript (nemuze to byt typescript). Dalo by se ale asi
      udelat nejake externi volani typescript compileru
      vol
    */



    Asi by taky šel použít node.js modul 'vm':
    https://nodejs.org/api/vm.html

    - to bohužel pořád funguje jen na úrovni javascriptu...



    Když bych chtěl prototypovat nativní javascriptovou prototype inheritancí
    (jako že bych určitě chtěl), tak by každý brutusí vnum musel odpovídat
    samostatné class. Pak by prostě javascriptový prototyp té classy fungoval
    jako mudový prototyp.
      Editace prototypu v runtime by pak vypadala takhle:
        Mob82003.prototype.maxHitPoints = 20;



  ------------

  Jak na dynamické generování nových typů (prototypů)?

  - Musím to samozřejmě načíst z nějakého souboru v rozumném (tj. JSON) formátu
  - Co všechno dávat do jednoho souboru? Po zónách to asi organizované mít
    nechci... (respektive určitě by mělo jít vypsat, jací mobové jsou použiti
    v dané zóně, ale neměli by se vyrábat mobové (roomy, atd.) přímo do zón).

    Každopádně zatím můžu začít jednou entitou v jednom souboru, pak to kdyžtak
    rozšířím.

Takže:

class PrototypeData
{
  type: string;
    /* Jaky typ se má dynamicky vytvořit */
    - ten by se asi měl generovat automaticky
    ("Mob"/"Obj"/"Room" etc. - nebo možná 'mOrc21') + jméno + případně číslo?
    - je podstatné si uvědomit, že prototypy se nedávají do zón a že od každého
    prototypu může existovat víc instancí (i od prototypu roomy). Takže když
    budu chtít ve skriptu projít 10 room v zóně, tak budu ty roomy odkazovat
    přes jejich stringová idčka (nebo nějaký logický dns-like ekvivalent),
    nikoliv přes jméno prototypu.
    - na druhou stranu loadovat budu z prototypu, takže 'load mOrc21' se
    používat bude

  ancestor: string;
    /* Z čeho se má zdědit */

  data: Array<any>;
    /* Jaké property a s jakými hodnotami se mají nasetovat prototypu
      (tedy do Type.prototype) */

  scripts: Array<Script>;
    /* kusy kodu, ze kterych se maji vyrobit metody a povesit na prototyp */
}

class ScriptData
{
  methodName: string;
    /* Pod jakym jmenem se ma funkce povesit na prototyp */

  code: string;
    /* Tohle není přímo tělo funkce. Při navěšování na prototyp se ještě
       obalí nastavením sandboxu a voláním s timeoutem. */
}
    


Pozn (Globální skriptové funkce):
  Pokud budu chtít mít nějaké skriptové fce, tak je asi nahážu do nějakého
  objektu, který automaticky přihodím do každého sandboxu (tedy do každého
  nového prototypového typu, protože sandbox bude nejspíš vždycky celá
  entita).
  - to by znamenalo, že by se volaly přes nějakou dot notation, nejspíš
  se.doSomething(); // 'se' jako ScriptEngine
  (nebo možná utils.doSomething()?)
- on možná sandbox objekt funguje jako 'global', takže půjdou funkce volat
  přímo. Chce to vyzkoušet.


TODO: pořešit 2 death scripty na mobovi (obecně víc skriptů na stejném triggeru
  jedné entity)


===============================================================
Bitmapy
-------------------------------------------------------

IDEA: Zkombinovat moznost deklarovat flagy v kodu a deklarovat je dynamicky.
- Když je flaga v kódu i v soboru (a sedí value), tak to tak
  zůstane. Když je v kódu a není v souboru, tak se dosavuje do souboru.
  (Tj. vždycky budou všechny flag values v souboru, včetně těch deklarovaných
   v kódu, ale ne všechny flagy musí být deklarované v kódu).
- když to při loadování hry nesedí (v kódu je stejná flaga jako v souboru ale
  s jinou hodnotou), tak to sprostě zařve FATAL_ASSERTEM

Jinak řečeno (a i jianak implementováno): V kódu budou deklarovány jen
  symbolické konstanty (bez hodnoty), hodnota bude jen v souboru (repsketive
  v hashmapě).

/*
 Jinak: FlagValue nepotřebuju, tu si vyrobím interně při indexaci.
   (a vlastně ani to ne, budu přece přistupovat na Flags object konkrétního
   typu a ten mi řekne, že value "PLAYER_DISCONNECTED" v RoomFlags není).

 - možná by stálo za to vyžadovat, aby všechny flagy mělo globálně unikátní
   názvy (možná formou prefixů).
   (Prefixy by fungovaly tak, ze každý FlagData by si svůj prefix pamatoval
   a kontroloval by, že jím nově vytvářená flaga začíná (neměl by se připojovat
   automaticky, jen kontrolovat)).
*/


- flagy by měly jít přidávat za běhu, což znamená, že se musí umět savovat
  na disk (do kódu se za běhu zapisovat nedá).
  (Naprd je, že pak nebude napovídat visualko...)

Hodnota (konkrétní flaga) by měla být objekt, který v sobě má:
- vlastní číslo flagy
- jméno typu
(Díky tomu půjde za běhu kontrolovat, že RoomFlags indexuju opravdu room flagou
 a ne třeba PLR flagou se stejným číslem).


class RoomFlags extends Flags
{
  public static get ROOM_HOT() { return ROOM_HOT; };

  /*
     Not all existing room flags are necessarily defined here.
     Some of them may be declared dynamically - in that case the flag
     exists in files but doesn't have symbolic name here.
       Feel free to add symbolic names for such flags here if you want
     to use from the code.
     
     Note also that only the name of the flag is declared here, not its
     integer value. The value is still saved to file.

     You can also add a new flag here that doesn't yet exist in the file.
     It will be added there automatically on the next reboot (when the
     game loads itself from file) and an unused numeric value will
     automatically be assigned to it.

     If you really want to delete a flag (maybe because you addes some by
     mistake or it becomes obsolete), the only way to do it is to edit
     the file with respective FlagData (///TODO: cesta k souboru).
   */
}

--------------------

Automatický update flaglistů:
------------------------------

- FlagsDataManager má flagu this.loaded, díky které lze assertovat,
  když se někdo pokusí hrabat na FlagData před tím, než jsou poprvé
  loadnuta ze souboru.

- instance Flags objektů (třeba new CharacterFlags()) mají referenci
  na příslušný FlagsData object inicializovaný na false.
  Až když ho někdo bude chtít poprvé použít, tak se na FlagsDataManageru
  checkne, že takový FlagsData objekt existuje (a že už je loadnuto).
  Pokud ne, tak ho vytvoří a savne.
  - tohle se pochopitelně provede jen jednou za boot, proože při příštím
    accessu už existovat bude.

- Když si konkrétní instance Flags objektu žádá o referenci na svůj FlagsData
  object, tak se taky provede update seznamu flag podle statických proměnných
  na Flags objektu, které začínají příslušným prefixem.
  - FlagsData object má flagu this.flagsAutoUpdated, která zaručí, že se tohle
    provede jen jedno, i když instancí příslušného FlagsObjectu bude více
    (každá z nich si při prvním použití vyžádá referenci na svůj FlagsData
    object)


===============================================================
Multiple characters and connections per account
------------------------------------------------

0) Exit BrutusNext
1) Enter game as Rahman
nebo
1) Reconnect as Rahman
// Pokud už char ve hře je

2) Create new character.
3) Delete a character.


  // Player can be connected to her account multiple times - for example
  // When immortal wants to play her mortal character on one session and
  // here immortal on another.
  /* Pozn: Mortalove by mohli mit omezeni na jedinou connection soucasne. */
  pendingConnections = new Array<PlayerConnection>();


Reconnect:
- Zahodi se existujici connection navazana na character (pokud je jeste ziva)
  a misto ni se setne pending connection, od ktere prisel request.


===============================================================

Scripting
----------

Každý skript je deklarace funkce
- jméno skriptu je totožné se jménem funkce (obalovací kód musí umět vytáhnout
  ze sandbox objectu proměnnou s danou funkcí - což bude dělat kód, který se
  přilepí na konec skriptu. A ten samozřejmě musí vědět, jak se má ta fce
  jmenovat).
- díky tomu, že skript deklaruje funkci, je možné v ní použít i return.
- script editor by při editaci nového scriptu měl automaticky vložit hlavičku
  funkce + prázdné tělo. Může to být šedivé, tj. uvnitř editace skriptu edituju
  jen obsah a když chci změnit jméno fce nebo parametry, tak musím vyskočit
  ven (nebo si to prostě naparsuju, ono to zas tak těžké nebude - prostě první
  vnější {})

'stopscript'
- Už v zásadě vím jak na to: Nechám doběhnout timer a místo resolve() zavolám
  reject(). Tím vyhodím výjimku, kterou pak následně odchytím (jako všechny
  výjimky z async funkcí přímo v BrutusNext.ts, akorát musím odflitrovat,
  že jde o stopscript exception - nejspíš podle err.message).

  Otázka je, jak v kódu, kterej se zavolá po skončení timeoutu, zjistit, že
  patří ke skriptu, kterej někdo stopnul.
  - nestačí na to jméno funkce, protože mezi tím se ten skript mohl pustit
    znova a kdyby novému spuštění dřív doběhnul timeout, tak bych umřel to nové
    místo starého. Takže musím přesně identifikovat každé jednotlivé spuštění
    timeoutu (možná přes ten timeout id?)

Související problém: Rušení skriptů běžících na entitě, kterou někdo zabil.
  - když bych ty skripty nestopnul, tak budou sahat na neexistující this
  - to znamená, že údaje o spuštěných skriptech (do kterých se bude
    poznamenávat, které skripty se mají stopnout, nemůžou bejt přímo na entitě.
    Po smazání entity bude timeout stále čekat.)
    - teoreticky by to mohlo být na classe (jako static proměnná). To ostatně
      asi i dává smysl, protože skripty jsou vlastnost prototypu (můžu v zásadě
      přiřadit na instanci nějakej skript, ale definovat se budou na prototypu.
      Takže budu psát něco jako 'stopscript PrototypeRoom::onLoad()', což by
      mělo stopnout všechny běžící instance tohohle kusu kódu, včetně těch,
      které jsem připojil na nějakou jinou entitu než odvozenou
      z PrototypeRoom.)
      - ok, takže na classe PrototypeRoom budu mít něco jako 'runningScripts',
        což bude hashmapa indexovaná jmény skriptových fcí (třeba 'onLoad').
        A pro každou běžící instanci tohohle skriptu tam bude záznam.
        (díky tomu půjde vypisovat i statistiky, kolik instancí nějakého
        skriptu mi běží, na jakých běží entitách, atd.)

  Ok. Otázka teda je, jak do PrototypeRoom.runningScripts přidám info o právě
  spuštěném skriptu.
  - jediné možné místo je asi kód funkce delay(). A musím do ní nějak
    propašovat informaci Prototype::scriptName - s tím, že Prorotype nemusí
    nutně být this.prototype, protože metodu SystemRoom.doCosi() můžu klidně
    pustit i na nějaké jiné entitě (s jiným prorotypem).

  Jak to udělat?
  - když buildím skript, tak vytvořím funkci. Může ta funkce mít vlastní
    funkci delay? (Která zavolá funkci performDelay() s parametry 'Prototype'
    a 'ScriptName'?).

/*
TOHLE NEBUDU IMPLEMENTOVAT
- nepůjde attachovat/detachovat skripty na instance (entity), to je antipattern.

Stopování běžících skriptů
- ideálně bych měl do běžícího skriptu propašovat odkaz na 'script' object
  a odkaz na internalFunction(). Když bude při doběhnutí timeru
  internalFunction uvnitř funkce delay() jiná než ve script.internalFunction(),
  tak to znamená, že se má skript stonout.
- alternativně můžu předávat compilationCounter a incrementovat ho na 'scriptu'
  (když má delay() menší compilationCounter, tak to znamená, že se má stopnout)
*/
-----------------------------------------------------

Přejmenování skriptu
- Pokud je script jen na prototypu, tak to je relativně jednoduché, na
  prototype se ze Scriptu dostanu (a prostě assignu undefined místo původního
  jména a novou scriptFunction na nové jméno)

/*
TOHLE NEBUDU IMPLEMENTOVAT
- nepůjde attachovat/detachovat skripty na instance (entity), to je antipattern.

- Pokud jsem script attachnul na entitu, tak to bude těžší.
  IDEA: Při attachnutí skriptu na entitu se nesetne rovnou scriptFunction,
  ale nejdřív nově vytvořená interFunction, která bude vědět, (přes jaké jméno
  byla zavolána. Ta se následně může podívat, jestli skript s takovým jménem
  ještě existuje (jak?))...
*/

---------------------------

IDEA:
Deklarovat fci delay() uvnitr skriptu místo uvnitř compile().
- díky tomu uvidí na 'me' predane do skriptu jako parametr
Nevyhoda: Vsechny skriptove fce budou muset mit explicitni parametr 'me'.


IDEA:
- 'script' můžu pořád dostat do delay() přes closure metody compile(),
  jen musí přidat ještě jedno volání, které ji zavolá.

  (tj. delay() bude deklarovaný ve skriptu a uvidí na 'me' a na funkci
  interDelay, která je deklarovaná v closure metody compile() a nastavená
  jako parametr sandboxu - což je problém, protože sandbox je jen jeden
  pro všechny skripty....
  - může být interDelay() deklarovaný v closure scriptFunction()?
    - to mi asi k ničemu nepomůže. Leda že by...

  - může být interDelay() předaný jako parametr do skriptové fce? Asi může...


  IDEA: Script.internalFunction prejmenovat na Script.run


======================================================

  Úvahy nad idčky a entitami
  ---------------------------

  - IdableObject přejmenovat na IdableEntity (nebo jen Entity)
    (protože idčka mají funkci getEntity, tak ať to dává smysl)
    (pořád bude rozdíl mezi Entity a GameEntity)

  - IdableObjectContainer přejmenovat na EntityContainer

  - V celé aplikaci mít jen jeden Entity Container
    (tzn. budou v něm accounty, game entity, atd.)

  - Sloučit IdProvider s EntityContainerem (nejspíš ho dát do entityContaineru)


Validita idček
  Když idčko loaduju z disku
  - checknu, jestli už není zaregistrované v IdProvideru
    - pokud ano, vezmu si referenci (a už má validitu zjištěnou)
    - pokud ne, přidám ho do IdProvideru - a asi bych měl ověřit validitu
      (a nastavit ji do interní proměnné)

  Hmm, validita může znamenat různé věci
  - valid entita, ale není loadnutá
  - smazaná entita

  public status = Entity.STATUS.UNKNOWN;
  
  public static STATUS =
  {
    // Initial value - we don't know yet.
    UNKNOWN:                  "UNKNOWN",
    // Entity is valid and loaded.
    VALID:                    "VALID",
    // Entity is valid (not deleted) and loaded from disk.
    NOT_LOADED:               "NOT_LOADED",
    // Entity has been deleted, you should not access it anymore.
    DELETED:                  "NOT_LOADED"
  }

  // internalReference jde zcela nezavisle. Entita muze byt loadnuta
  // a validni a pritom internalReference null
  // - nebo ne?
  //   Co mi brani updatnout internalReference hned?

  TODO: Zrušit classu EntityId
  TODO Id.getEntity<T>() bude generic a bude dynamicky přetypovávat
    na requestnutý typ T.


=======================================================================
Úvahy o idčkách, weakmapách, atd...
=======================================================================


Počáteční stav
---------------

IdProvider
"a-skh2swe" : id->zlyMob

Zuzka
 id->zlyMob




delete zlyMob
--------------

id.entity = null;	// entity se smaže z paměti
id.entityDeleted = true;

/* ----------- */

aktuální IdProvider:
"a-skh2swe" : id->zlyMob

Zuzka
 id->zlyMob

Potřebuju vědět, že:
- můžu smazat stringový klíč
- můžu smazat id


stringKey můžu smazat až ve chvíli, kdy zmizí poslední reference na idčko
- protože do té doby potřebuju být schopen dohledat idčko podle jeho stringKey


================================================

Idea: Zrušit class Id, používat přímé reference

- když SaveableObject narazí na Entitu, tak zavolá entity.saveReference(), což vytvoří
  podobný záznam, jaký teď má idčko.

- při loadování se z tohohle záznamu vezme stringId a checkne se, jestli je odpovídající
  entita loadnutá. Když ne, tak se reference nastaví na null (nebo místo toho na Id object?).

- při pokusu dereferencovat odkazovanou entitu se znova zkusí najít entita podle stringId
  (respektive byla by to možnost. "Už je online?" "A teď?")

No jo, jenže...
  Kam se savne to stringId, když bude reference null? To by se musela automaticky vytvořit
  nová promměná ve stylu "jméno_proměnné" + "stringId" a do ní by se hodilo to string idčko...
  - a nebo se tam místo entity hodí ten object Id a dereferencování jeho metod bude holt
    crashovat... (dereference null by crashnula taky)

Proč přece jen používat idčka?

- protože o tom, že je problém, se dozvím už ve chvíli, kdy použiju
  id.getEntity()


- problém je se skriptama, protože tam si dám do proměnné entitu a pak
  dám wait... a entitu může mezi tím někdo smazat.

Proč raději používat přímé reference?
- protože když nenapíšu if (id.getEnity() !== null) ..., tak mi to spadne
  při pokusu na entitě cokoliv zavolat
Když místo toho neoifuju referenci, tak mi na ní metoda zavolat půjde - sice
  se bude volat na invalid entitě, ale nespadne na tom celá hra.
- zato můžu do nativních metod entit psát checky typu:
  if (!this.valid)
  {
    ERROR(message);
    return;
  }
  Takže se dozvím, že se snažím manipulovat se smazanou entitou (a přitom to
  nic neudělá a neshodí to hru).




================================================

1. Dejme tomu, že dokážu checknout, jestli je entita s daným idčkem savnutá
   na disku.
   - Jak na to?
     - musím umět získat fullSavePath od každé entity, ideálně bez toho,
       aby ta entita musela existovat (static metoda? Jenže jak zavolám static
       metodu, když nemám entitu? Přes dynamicClasses?
       - jo, to by asi šlo).



2. Při smazání entity:
   - nastaví se jí flaga deleted
   - smaže se z disku
   - smaže se záznam z idProvideru

Dokud je záznam v idProvideru, tak určitě existuje alespoň jedna reference
na entitu. Tzn. nemusí být reference nikde jinde.

IMPORTANT: V metodě Entity.save() zkontrolovat flagu deleted.
  - takže se smazaná entita nesavne.

Co se stane, když si za běhu vezmu referenci na entitu a někdo tu entitu smaže?
- Entita pořád existuje v paměti (já se na ni odkazuju), ale má flagu deleted.
- Už není záznam v idProvideru
  - když se teď někdo zeptá idProvideru, jestli je entita smazaná, dozví se, že
    ano.
  - když se loadne někdo s referencí na entitu:
    - Zeptá se idProvideru a dozví se, že záznam nemá.
    - Checkne, jestli existuje save. Pokud ne, znamená to, že je entita
      smazaná.


Úvaha bokem: Hráčské postavy a unikátní jména
- hráčské postavy se nemažou (tj. delete nesmaže záznam z disku, pouze nastaví
  flagu deleted), ale může se teoreticky smazat jméno.
- přitom bych ale asi potřeboval možnost zjistit čistě dotazem na existenci
  souboru, jestli je entita smazaná. To nejspíš znamená, savovat hráčský char
  na dvě místa - pod stringIdčkem a pod unikátnímJménem.



Struktura dat:
---------------

  ./data
       /Account
         1-imt2xk99.json
       /Character
         4-imt2xk99.json
     /entities
       /Account
         6-imt2xk99.json
       /World
       /Room
       /Character
     /prototypes
       /World
       /Room
       /Character
          7-imt2xk99.json
          /Orc
            8-imt2xk99.json
     /unique_names
       /*
         Pro každé unikátní jméno jeden prázdný soubor. Podle jejich
         existence se zjišťuje, jestli je jméno volné.
         (teoreticky tu mohou být podadresáře, pokud bych chtěl mít víc
         nezávislých kategorií unikátních jmen)
       */
       Zuzka
       Rahman

- hmm, asi bych chtěl, aby se všechno, co patří k Accountu, savovalo
  do /Accoounts/Rahman, včetně všech charů na accountu, lodí, základen, atd.
  - i když je to otázka, dost značně to všechno zkomplikuje.
  - navíc počítám s tím, že "hráčovy" assety mohou žít svým vlastním životem,
    takže pak nejsou až tak úplně 100% hráčovy...
    (což znamená, že by se u některých entit měnilo, komu patří, takže by se
     pak savovaly na různá místa na disku... Asi na to spíš kašlat a savovat
     všechny entity stejně.)

PS: Smazání entity, která má být obnovitelná, ji prostě přejmenuje na
.json.deleted, není třeba ji přesouvat do jiného adresáře.

---------------------------
Co by bylo potřeba, aby se daly savovat playerovy entity do /Acccounts?

- každý savnutý odkaz na entitu by si musel pamatovat, jakému Characteru
  a jakému accountu to patří.
  - co když hráčova věc zůstane ve hře a vezme si ji někdo jiný?
    - měl by ji vůbec mít savnutou hráč, když je stále ve hře?
      Očividně se to může stát, když hráč napíše 'save' a následně věc někomu
      dá. V ten moment je má savnutou u sebe a dotyčný si ji může savnout taky.
      Tím se nevynutí save prvního hráče, takže ji nyní mají savnutou oba,
      pokud dejme tomu crashne mud.
    - když by každý z nich měl savnuté jen idčko, tak se pořád může stát, že si
      to idčko savnou oba. Pak se při loadu stane co? Budou mít oba dva
      referenci na stejný item?
    - když se budou s hráčem savovat jen reference, tak to půjde pořešit přes
      to, že item samotný má u sebe savnutou 'location'. Když při loadu
      location entity nebude odpovídat tomu, do čeho se loaduje, tak se může
      zase zahodit - znamená to, že o ni hráč po svém savu přišel a savnul ji
      někdo jiný.


[09:51] Rahman       : <64> Zacinam si cim dal vic klonit k tomu, nesavovat itemy do player filu ale do /Objects
[09:51] Rahman       : <64> Hlavnim duvodem je obrana proti duplikovani itemu
[09:52] Rahman       : <64> Kdyz jeden player napise 'save', da item druhemu playerovi, ten napise 'save' a nasledne spadne mud bez savu, tak je ten item savnuty ve dvou pfilech
[09:52] Rahman       : <64> a kazdy z nich ma jako ownera jineho playera
[09:54] Rahman       : <64> zatimco kdyz bude u playera savnute jen stringove idcko itemu a item bude jinde, tak timhle vznikne stav, kdy item je savnuty dvakrat na stejne misto a dva ruzni playeri maji na nej odkaz (tvari se, ze je item jejich)
[09:55] Rahman       : <64> jenze item ma u sebe savnutou 'location', takze kdyz se logne ten prvni player, tak mu muzu rict 'sorry, tenhle item uz ma nekdo jiny'
[09:56] Rahman       : <64> samozrejme to znamena, ze bude peklo rucne vytahnout playera ze zalohy, protoze jeho itemy budou rozstrkane vsude mozne
[09:56] Rahman       : <64> na druhou stranu to pujde celkem jednoduse zautomatizovat, takze ho budes moct restornout za behu primo ze hry
[09:57] Rahman       : <64> proste si vytahnes prislusnou verzi z gitu do jineho adresare (protoze v gitu bude ulne vsechno) a forcnes playera, at se loadne ze /zaloha/data misto z /mud/data
[09:58] Rahman       : <64> a pri te prilezitosti to muze item po itemu kontrolovat, jestli nahodou neexistuji v ostre verzi a nema je nekdo jiny, takze se zabrani duplicitam


Ad unique names
- možná bude lepší držet je v paměti, ono jich zas až tak strašně moc
  nebude. Takže asi vytvořit nějaký UniqueNamesManager.
  - v něm budou kategorie accounts a characters

Class inheritance tree
-----------------

NamedClass
- AttributableClass
  - SaveableObject
    - AutoSaveableObject
      - Entity
        - NamedEntity
          - Account
          - CommandInterpretter
            - ContainerEntity
              - GameEntity
                - Sector
                  - Area
                - Dimension
                - Realm
                - Room
                - World
                - Character

Ok, co jsou kořeny adresářového stromu?
- Account (respektive NamedEntity) (protože ./data/entities/Account)
- GameEnity (protože ./data/entities/Realm apod.)

Tzn při volání getSavePath():
- NamedEntity by měla vracet ./data/entities
- GameEntity by měla vracet ./data/entities
- Entity by asi taky měla vracet ./data/entities
- Account by měl vracet className + super.getSavePath()
  // A navíc to nebude moct bejt super. protože se to nebude volat na instanci,
  // ale na prototype chainu.



================================================

IDEA: Rozlišovat:
  - Adresář, kam se savne celá hra se vším všudy před bootem
    (a po bootu se z něj zase celá se vším všudy loadne)
  - A adresář, kam se savují player data v průběhu bootu...

Asi spíš jinak: Mít dvě gitové repository. Do jedné se budou
  commitovat změny v kódu (samozřejmě i s aktuálním stavem dat),
  do druhé zálohy dat (samozřejmě i s aktuálním stavem kódu.
- restore dat ze zálohy se bude provádět z běžícího mudu, prostě se ty
  entity natáhnou z /backup/data místo z /mud/data
Důvodem pro dvě repository je, že nechci, aby do programátorské nespamovaly
commity se zálohama...
(Možná to takhle jednoduše nepůjde, uvidíme...)


================================================

Undelete
---------

Problém: Někdo si schová referenci na char, který smažu.
  - v ten moment se maže záznam z hashmapy (stringId->entita).
  Následně provedu undelete (ve stejném bootu). Znova loaduju entitu
  z disku a měl bych ji napojit na už existující, protože si ji někdo
  stále pamatuje - jenže na tu už se nemám jak dostat, protože už není
  záznam v hasmapě.

Řešení: undeletnutelné entity nemazat z hashmapy.
  - Týkat se to bude asi jen player charů (lodí, designů a tak)

Problém: Někdo qitne s charem a pak se zas naconnectí
  - to je vlastně stejnej problém jako s tím undeletem: Nemůžu vyhodit
  záznam z hashmapy, protože bych se pak nedokázal napojit na instanci,
  na kterou si někdo stále drží referenci.

  Tzn. quitnutý char bude zůstávat v paměti
  - teoreticky na něj můžu držet jen weak link (dát ho do WeakMapy),
    takže se pak z paměti vyhodí aspoň entita - jo, to zní hezky, ale jak
    to udělat? Já potřebuju držet tu referenci na entitu

================================================

Použití node-weak:

Když vyrábím novou entitu, tak si do hashmapy dám strong referenci a současně
weak referenci. Vrátím weak referenci, která se bude přiřazovat ve zbytku kódu.

Když budu chtít entitu zahodit z paměti, tak:
- do strong reference v hasmapě zapíšu null
  - v ten moment můžu dokonce rovnou checknout, jestli weakRef.isDead() a pokud
    ano, tak zahodit celý záznam v hashmapě (protože nikdo jiný nemá referenci).
    Pokud není dead, tak si nechám weakRef, protože mě možná časem někdo bude
    chtít oživit.

- využití callbacku:
    Když se mi zavolá callback, tak můžu vyhodit celý záznam z hashmapy,
    protože to znamená, že nikdo už nedrží referenci na entitu.
    - když se mi někdo relogne, undeletne, nebo tak, tak se prostě dá nový
      záznam do hasmapy

================================================

Využití proxy:
  - Entita je proxy, která defaultně jen předává přístupy zapouzdřené entitě.
  - Když na Entitu zavolám delete, tak se v proxy změní metody get() a set()
    a místo předávání vnitřní entitě budou reportovat přístup na smazanou
    entitu.

- Teoreticky takhle půjde odchytávat i pokus o přístup na neexistující property
  (takže program nespadne - respektive nespadne na volání neexistující metody
   entity, ale může pořád spadnout, když přistoupím na to, co mi ta
   neexistující metoda "vrátí").

ÚVAHA: Využití Proxy k ošetřetní relogu bez nutnosti počítat reference:

    Lognu se

    Někdo si na mě vezme referenci

    Odlognu (save)

    Dotyčný zkusí na referenci přistoupit
    - Proxy checkne hashmapu a zakáže mu to

    (load )Znova se lognu
    - Vytvoří se nový objekt. Dotyčný má stále referenci na ten smazaný

    Dotyčný zkusí na referenci přistoupit
    - Proxy checkne hashmapu, zjistí, že objekt byl znovu vytvořený, takže
      přesměruje interní referenci na nový objekt
      (pro dotyčného se to tváří, jako kdyby objekt stále žil)




================================================

TODO:

- Domyslet novou strukturu dat
- Přejít na novou strukturu dat

- Líp vymyslet dynamicClasses
- Implementovat to

- otestovat node-weak


- Přejít z Idček na reference na entity


- otestovat Proxy


================================================

Game.createWorld()
{
- chci nové idčko

  // Tohle je asi ok
  this.world = SaveableObject.createInstance
    ({ className: param.prototype, typeCast: World });
}

Game.load()
{
  - potřebuju idčko loadnout ze souboru
    (world má unikátní save name, takze nepotrebuju znat id, abych vedel,
    z jakeho souboru se mam loadnout)

  /// Tady by melo byt: createInvalidReference();
  /// PS: Na to nemusim ani znat typ - respektive ano, musim ho zapsat do
  ///    handleru.
  this.world = SaveableObject.createInstance
    ({ className: 'BrutusWorld', typeCast: World });

  // Load current state of world from file.
  await this.world.load();
}

SaveableObject.loadFromJson()
{
  - tady se loaduje invalid reference, to uz mam napsane.
    (a dělá to EntityManager - to je důležité)
}

Tzn. asi bych nikde neměl sám volat SaveableObject.createInstance(),
měl bych volat EntityManager.createInvalidReference()
- proč rovnou invalid? Však klidně může být i valid, když zadám platné
  idčko a entita už bude v EntityManageru...
nebo EntityManager.loadReferenceFromJsonObject()
- to už se děje, ze SaveableObjectu
nebo EntityManager.createEntity()
- to ještě neexistuje. Místo toho tam je metoda add(), která přidá už
  existující referenci. Mělo by to asi být tak, že add() bude private
  a zavolá se automaticky.

[ok, už by snad měl jít zavolat load() na invalid referenci (ostatně i na
 valid) a mělo by to entitu loadnout a přidat do EntityManageru]

 IMPORTANT:
 - bude existovat jen jedna funkce na vyrábění nových entit (tedy s novým
   idčkem), a to EntityManager.createEntity().
   - nikde jinde nemusím vyrábění nového idčka řešit.