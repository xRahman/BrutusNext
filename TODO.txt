TODO, TODO, TO DO TO DO TO DO, todotodooooooo.... todotodo...
---------------------------------------------------------------

TODO: Nejspíš ve spoustě filů zbytečně importuju JQuery.

TODO: Do Character plate dát dva labely
(velké písmo - jméno, malé písmo - popisek)

TODO: Char plate by měl mít vždycky 2x border (ať to neskáče).

---------------------------------------------------------------

Jaká mám vlastně okna?

StandaloneWindow
- velký titlebar
- centered
    CharlistWindow
    ChargenWindow
    LoginWindow
    RegisterWindow
    - automaticky roztahovací na výšku
      (Tohle by chtělo dědit, páč to je
       stejné css pro všehchny.)

    TermsWindow
    - fixní výška
      (to je sice default, ale každé z těhle oken si ji stejně potřebuje
       nastavit podle sebe, takže každé potřebuje WINDOW_CONTENT).

GameWindow
- malý titlebar
    ScrollWindow
    MapWindow
  
=> Takže to mám dobře. Standalone okna s fixní výškou by sice uživila
   kus nastavení contents defaultního okna, ale stejně si ten contents
   musí předefinovat, protože mají jinak výšku. Takže správné řešení
   je skutečně css pro contents předefinovat a reusnout příslušný kus
   css uvnitř stylesheetu.
- tak neeee, špatně. Výška okna se neurčuje v contents css, ale ve window css.
- Na druhou stranu Charlist okno nemá výšku fixní, ale dynamickou
  - sice má fixní výšku vnitřního charlistu, ale celé okno se roztáhne
    podle toho.
    - jo a padding může mít contents, nemusí ho mít komponenta charlist.
---------------------------------------------------------------

TODO: Použít "label for" na text pro "Remember me" checkbox.
(Respektive vložit checkbox do labelu, to funguje stejně.)


Ja na character select/create?
- má to vůbec smysl? Zatím stále počítám s 1 charem na mortalském
  accountu
- někde se ale musí ten jeden char vyrobit (aspoň zadat jméno).
No nic, prostě to udělám a basta.

Úzké okno, uvnitř velká tlačítka s chary a button "create new character".
- tlačítka s chary by měla být selektovatelná (možná radiobutton?)

Ještě to asi bude chtít ChargenWindow
  Nebo možná prostě jen popup v charselectu?
  - ten popup taky může bejt realizovanej jako okno (byť by v něm
    byl jen text input a tlačítka create a cancel), aspoň to budu
    mít připravený.

---------------------------------------------------------------

TODO: Nějak chytře pořešit zákaz selektování textu
 (ideálně aby se nemusely vypisovat všechny classy v css).
- Možná to v css globálně zakázat a povolovat to flagou v kódu?
  (Tj. na konkrétních komponentách, nezávisle na css classách...)

TODO: Možná by šlo z dvojice { gCssClass, sCssClass } udělat
  interface (Takže Window.create() by mělo 3 parametry místo 6...).

TODO: Strukturální css classy přejmenovat na S_Cosi
[done]

TODO: Doplnit vendor-specific řádky k backgroundům.
[done]

TODO: Nastavit klikatelným elementům:
{
   cursor: pointer;
}
- a nebo ne? Klikatelné elementy reagují na mouseover, to by mohlo stačit.

TODO: Borderům u buttonů dat border-style: outset;
- u inputů:  border-style: inset;
- zbytek vyzkoušet, ale asi bude něco lepšího než obyč border.
[done]

TODO: Terms window by mělo reagovat na escape a enter
(obojí ho zavře).

TODO: Buttony by asi měly mít trochy výraznější border.
[done]

TODO: Právě jsem nastyloval button, který je úplně stejný jako
LoginForm_SubmitButton
- sloučit to do stejné classy.

TODO: Window.create() by taky měla mít defaultní hodnoty css class.
TODO: použít createAndAdd() ve Widnows i na herní okna.

TODO: vnitřky createXXXWindow() ve Windows sloučit do procedury.
[done]

TODO: volání windows.createXXXWindow() sloučit do metody
createStandaloneWindows().
[done]

TODO: Abstraktní předkové komponent by měly v createCosi()
  metodách mít parametr cssClass s implicitní hodnotou.
  (Viz Form.)
[done]

TODO: Text s linkem celý zavřít do containeru
[done]

TODO: Button v LoginForm asi taky zavřít do containeru.
  (Cancel button tam sice není, ale ať je to stejné.)
[done]

TODO: S tím duplikováním css class jsem to trochu přehnal
- sloučit ty, které jsou konceptuelně stejné.
[done]

TODO: Projít css v SvgMap.

TODO: Title text by se měl v LoginWindow setovat do Title, ne to TitleBaru.
- nebo prostě zrušit title bary a nechat jen title...
 (i když vlastně ne, pokud budou na title baru buttonky, tak title musí být
  samostatná komponenta).
[done]

TODO: Předělat css na selector grupy
- v kódu budou mít css class přidělenou pouze komponenty, které se
  skutečně vytváří (tj. nebude existovat class .Window).
- každá komponenta bude mít jen 1 css class (protože když budou
  classy v css filu roztahané po různých místech, tak přidat k tomu
  ještě mergování css class by byl děsnej bordel).
- defaultní font asi nechám, jak je (tj. pro '*'), ať nemusím
  všechny classy přidávat do selector grupy Default text.
[done]

TODO: V css víc dědit (tj. skládat css classu z více class)
  - například všechny inputy mohou mít stejný základ css (barvy, border a tak).
[done]

TODO: Sjednotit max account length a ostatní kód na constraints
  jména accountu a hesla.

TODO: Vrátit se k setování atributů přes JQuery
(mělo by stačí v Component).
- udělal jsem to s text contentem, kde jsou zřejmé nekompatibility browseru.
  Těžko říct, jestli to má smysl udělat se vším... (asi jo)

TODO: Zkontrolovat disablování všemožných vymožeností v input boxech.
- zatím, je to pro text input (a možná by šlo sloučit login a register)
TODO: dodělat to pro password a email input.
[done]

TODO: Nevracet vytvořenou komponentu, když se návratová hodnota na nic
  nepoužívá.
  (zejména když se komponenta rovnou přiřadila do this.$cosi).
[snad]

TODO: Přidat všem input elementům ve formu atribut name.
[done]

TODO: Zrušit idčka z komponent, které si někde pamatuju
(k čemu pak mám to idčko?)
- tj. nejspíš prakticky všechna kromě těch v svg mapě.
[done]

TODO: Metody na vyrábění jquery elementů by asi mohly (a měly) být
statické - nebudou se pak tlouct s vlastními metodami kompponent.
[na tohle asi kašlat]

TODO: podadresáře v rámci /gui/component
- nakonec jsem celé /component zrušil (což je dobře) a podadresáře
  udělal rovnou v /gui
[done]


TODO: Zrušit css pro specializované WindowContent
(protože si vystačí s defaultním).
[done]

TODO: Metody v Component by měly rovnou vracet jquery element.
  (a stačí createDiv() místo createDivElement()).
[done]

---------------------------------------------------------------

TODO: MudColorComponent by neměla být komponenta, ale statická
  classa MudColors (a taky je třeba se podívat, jestli se něco
  z toho nebude hodit i na serveru).

---------------------------------------------------------------

TODO: Zkusit upravit build task, aby přeložil server i clienta najednou.
[nepovedlo se, stále by to chtělo]

---------------------------------------------------------------

TODO: connection.connect (a stahování dat ze serveru a tak)
asi přesunout do onDocumentReady().
- a nebo taky ne. Otázka je, jestli vůbec onDocumentReady() k něčemu
  potřebuju. Někde jsem tuším četl, že když je script uvnitř <body>
  (což je), tak se určitě pustí až ve chvíli, kdy existuje document
  a v něm <body> - což je všechno, co potřebuju ke štěstí.


TODO: V ServerSocket se neinicializuje this.connection ale používá se.

TODO: TelnetServer, WebSocketServer a HttpServer by mohly mít
  společného předka.

---------------------------------------------------------------

Jak na mapper-editor:
----------------------

Základ by měl být stažení aktuální render oblasti ze serveru
s tím, že když na dané pozici na serveru rooma není a client
je v edit módu, vyrobí si dummy (nonexistent) roomu.

---------------------------------------------------------------

Connection-per-char, connection-per-account nebo connection-per-tab?

- ideálně by to mělo fungovat i přes telnet.

Vzato kolem a kolem je to asi jedno, protože i s per-char connection
se pořád player musí nejdřív přilogovat na account. Čili když webclient
bude mít možnost přes jednu connection posílat data z více charů, tak
je to funkčnost navíc, která nebrání tomu mít connection per-char.

V browseru každopádně dává zdaleka největší smysl mít jednu connection
na každou záložku - tedy 1 connection per klient (protože nová záložka
je nová instance celého klienta).
  Zatím asi bude rozumné pracovat s tím, že se přes tuhle jednu connection
připojí právě jeden char, časem to můžu rozšířit na víc.

TODO: Na serveru rozdělit TelnetConnection a WebConnection

TODO: Na clientu by pod Connection měly být Charactery (obecně ingame entity?)
  (IngameEntity)
  - zatím je asi nejlepší InGame, ale moc nedává smysl, že InGamů může být víc.
  - GameEntity to být nemůže
- connection je obecně pro celou app
- ScrollView

Avatar!

TODO (Tohle asi stále stojí za zvážení - classu Game mám možná opravdu navíc):
Místo stávající classy Game by asi šel použít World
(obsahuje realms, areas, characters a tak - to by klidně mohlo všechno být
 uvnitř světa.)
- doteď jsem ale rozlišoval /game/world (coby fyzické lokace) a třeba
  game/characters, etc. Tahle struktura by se musela změnit.

TODO: ingameEntity (v telnet Connection) by se možná daky dala přejmenovat
  na avatar (i když spíš ne, to bude něco jiného).
  - ve skutečnosti bych měl avatar říkat té ingame entitě a pro IngameProcessor
    vymyslet ještě jinej název...
(Na druhou stranu pokud bych ingameEntitě říkal avatar, tak nikdy nebudu
 mít 'public avatar: Avatar' - protože typem bude GameEntity).

MapWindow asi stačí jedno per client (obsah se změní při přepnutí charů)
(to samé platí pro GroupWindow, PlayerFrame, TargetFrame, etc.)
- když by hráč (imm) nutně chtěl vidět tyhle věci pro víc charů současně,
  může si prostě otevřít víc tabů v browseru (ty asi vedle sebe nedá, takže
  spíš víc browserů).

---------------------------------------------------------------

Přejmenování SocketDescriptoru...

- nejde to přejmenovat na Socket, WebSocket, TelnetSocket,
  protože WebSocket je build-in classa browseru

TODO: Možná MudSocket, MudWebSocket, MudTelnetSocket?
(asi furt lepší než SocketDescriptor...)
- nebo ClientWebSocket, ServerWebSocket
  (to je asi lepší).

---------------------------------------------------------------

Zatracené exity...

Problém: Exit je vnořená datová struktura...

- teoreticky to můžu udělat metodou:
  SharedExit
    - Exit (client)
    - Exit (server)
s tím, že client a server si zaregistrujů svuj Exit v Classes.
(Tohle bude fungovat jen díky tomu, že se to nijak dál nedědí. Kdybych chtěl
 z Exitu na Serveru něco dědit, fungovat by to asi přestalo (respektive sdílená
 data by všechny musela být v SharedExitu))

Hmm, problém je s pojmenováním. Zatím jsem se držel stylu
Entity
  -> ServerEntity
  -> ClientEntity
To ale tady nemůžu, protože ta classa se musí na clientu a serveru jmenovat
stejně.

Asi bude nejlepší držet se stejného přístupu jako u entit, tj.

/shared/ExitData
/client/Exit
  data: ExitData;
/server/Exit
  data: ExitData;

Hmm. Že by Exit byla entita?
To se zas vracím k tomu, co exit reprezentuje...
- na klientu se podle ExitRenderData vykresluje. Mají své htmlId
  a odkud kam vedou. Asi by dávalo smysl, aby Exit na clientu představoval
  ExitRenderData stejně jako Room na clientu představuje RoomRenderData.


Kromě toho - kam se budou savovat informace specifické pro exit?
(Pokud nějaké budou).
- buď to musí být jak v circlu, tj. že exity jsou popsané jen v roomách,
  nebo Exit musí být entita, aby se mohla savovat samostatně (jinak bych
  informace musel buď savnout do obou room, nebo nevím kam).
=> Exity by asi fakt měly bý entity.


Pozn: Když budou mít exity idčka, tak se asi na clientu obejdu
bez htmlId - idčko roomy z coords získám přes room grid.

---------------------------------------------------------------

Otázka: Co s 'dummy' objektama na klientu, jako jsou třeba zatím
neexistující roomy?

- V zásadě si asi klient může vyrábět vlastní entity s tím, že
  až se rooma vyrobí na serveru, tak to celé přepíše novými
  daty (včetně nového idčka).


TODO: Roomy se na klienta asi budou muset posílat v několika módech:
- všechno
- jen jméno roomu (a idčko)
  (to když je rooma "unexplored": mám do ní zatím jen exit, ale ještě
   jsem nenakouknul dovnitř - ať už skillem, nebo tím, že jsem tam vešel).
Tzn. PropertyAttribites by mohly vypadat nějak takhle:
{
  saved,
  edited,
  sentBrief,  // Sent to client in brief mode.
  sentFull,   // Sent to client in full mode.
  received    // Received from client.
}

QUESTION: Co s exity, o kterých zatím player neví?
- neměly by se posílat.
(otázka je, jestli by se měly posílat (a renderovat), když už je player
 jednou objeví - tj. jestli by se měly mapovat)
(stejná otázka platí pro extra descriptiony).
- možná je to škoda a lepší bude dát hráči možnost psát si poznámky
  do mapy.
Každopádně ale bude potřeba oddělit secret exity od obyč exitů co se
serializace týče.
(to se dál komplikuje tím, že secret exit může být otevřený - pak ho vidí
 každý).

Jak na to?
TODO:
Při serializaci mapy/pole/setu (obecně containerových datových struktur)
by měla existovat možnost flagnout itemy jako neserializované.
(možná u pole ne, pak by tam asi musely být díry... - což ale klidně mohou být)
- a tohle nebude statická flaga, ale property každého objektu
  (celý objekt se podle ní do struktury dá nebo nedá).

---------------------------------------------------------------

ÚVAHA k tomu, co má být v /server části entity a co v /shared:
- obecně to, co se v clientu zobrazuje pořád, má být v XxxData
  v /shared (tj. třeba description, terrain flagy, podle kterých
  se vykresluje barva roomy, atd.)
- to, co klient vykresluje pouze při requestu, nebo o tom vůbec neví,
  naopak má být jen v /server části (extra description, systémové flagy).

Zrada, 'name' by asi mělo být v .data (protože se na klientovi zobrazuje
  furt...)
 - tak asi ne, to by tam muselo být i idčko a to už vůbec
   nedává smysl. Nejspíš to bude tak, že properties zděděné
   z Entity se posílat budou (což je ok, client-side entity
   je má určitě taky).
TODO: Tzn. budu muset nějak zařídit, aby se propertes z Game entity
  na klienta defaultně neposílala (zatímco properties z EntityData
  by se defaultně posílat měly, abych to nemusel ke každé vypisovat).
- možná přidat možnost definovat:
    protected static defaultAttributes: PropertyAttributes = {}
  kde to půjde nastavit pro celou classu?

Prozatím budu předpokládat, že:
- data z Entity (tj. ze shared předka) se defaultně posílají
- data z EntityData se defaultně posílají
- data z GameEntity se defaultně neposílají.

---------------------------------------------------------------

TODO: Rozlišit Entity.setName() a Entity.changeName()

setName() by nemělo entitu přidávat do name listů (protože když později
zavolám addToLists() tak se do name listů přidá znova).

---------------------------------------------------------------

Ok, co dál?
------------

1. momentální cíl je, tahat roomy ze serveru (updatovat si výřez).

2. cíl je editor properties entit

3. cíl je editor světa (vyrábět roomy kliknutím, exity dragnutím myši...)

TODO:
- vyzkoušet, jestli funguje zakládání acocuntů a logování do hry.
  (i když to teď asi až tak moc nepotřebuju)
- vyzkoušet, jestli klient funguje tak, jak fungoval.
- zprovoznit strukturu Room (na serveru) - RoomData - Room (na klientu).
- zprovoznit posílání Roomy ze serveru na klienta.

---------------------------------------------------------------

TODO: Symbolická konstanta pro 'version' v Serializable
- už existuje, jen ji použít.
[done]

---------------------------------------------------------------

TODO: nějak lépe pořešit kopírování modulů do client files
(asi nějaký build tool?)
- stačí to dělat po instalaci (nebo updatu) modulu, není to nutné
  při každém buildu.
- ještě by byla možnost použít soft link na úrovni filesystému
  (tj. že adresář v /build/client/js by vedl do /node_modules,
   ale to by asi nepožral git a nefungovalo by to dobře na klientu
   a současně serveru. Navíc to asi ani nejde použít, protože
   například modul fastbitset je třeba pro klienta upravit pomocí
   r.js z instalace reuqirejs, jinak nejde loadnout. A na serveru
   naopak upravený být nesmí).

---------------------------------------------------------------

TODO: Tohle by asi neměl být error:
[WEBSOCKET_SERVER] Websocket ERROR: Socket / (::ffff:84.47.65.112) closed normally

(Obdobně když někdo zavře okno v browseru, tak to hlásí unknown error)

---------------------------------------------------------------

createRootPrototype()
{
  najdi prototypový objekt;
  createPrototypeEntity();
}
createDecendantPrototype()
{
  najdi prototypový objekt;
  createPrototypeEntity();
}

   createPrototypeEntity()
   {
     generateId();
     requestPrototypeName();
     createNewEntity();
     save();
   }

createInstanceEntity()
{
    createNewEntity();
}

---------------------------------------------------------------

TODO: Assert, že nesetuju unikátní jméno pototypové entitě
(a smazat ty zaremované hlášky ze ServerEntities)
    /*
    if (isPrototype)
    {
      ERROR("Attempt to request unique name '" + name + "' in"
        + " cathegory '" + Entity.NameCathegory[cathegory] + "'"
        + " for a prototype entity. That's not allowed - name will"
        + " be inherited (and thus duplicated) when an instance or"
        + " a descendant prototype is created from this prototype"
        + " entity so it's not possible to ensure that it's name"
        + " will stay unique. Name is not set");
      return false;
    }
    */
[done]

TODO: Savovat name lock fily.

TODO: index.ts asi nepůjde použít, importy pak nefungují, jak mají.
(takže zrušit ten testovací v /shared/lib).

TODO: setPrototypeEntity() by asi měla mít jen ServerEntity
  (a tudíž pak půjde volat ServerEntities.save() místo Entities.save()).

TODO (ServerEtity.setName()):
/// TODO: Před setnutím jména je třeba vyhodit entitu z NameListů
/// přes this.removeFromNameLists() a pokud je to prototyp, tak taky
/// z Prototypes. Po setnutí ji tam zase přidat.

---------------------------------------------------------------

Statování "skriptů" ze hry:
- Tohle vypíše kód funkce (závorky tam nejsou schválně):
   console.log("" + funkce);
- Tzn. takhle by asi šlo snadno statovat ze hry libovolné metody na herních
  entitách.

---------------------------------------------------------------

TODO: Vyrobit class Time, která si bude datum interně držet jako number.

---------------------------------------------------------------

Prototype inheritance Map a Set
--------------------------------
- zatím jsem to hacknul, že místo Object.create() se vytvoří new Map()
  nebo new Set()
  - tzn. nepřepisuje se prototyp, ale nedědí se.
Teoreticky by to šlo vyřešit tak, že bych si vytvořil vlastní
classy Map a Set a přetížil jim metody (set, has, atd.), takže by koukaly
na prototyp, když by byly prázdné a zkopírovaly itemy z prototypu do instance,
když by do toho někdo chtěl zapisovat....
(Znamenalo by to v instantiateProperties vytvořit instanci téhle nové classy
 - MyMap, MySet a dát jí odkaz na originální Map nebo Set na prototypu, páč
 později už by se k němu nedostala.)
(Zatím na to kašlu.)

- asi lepší varianta, než hackovat protypovou dědičnost, by byla napsat
  si vlastní Map a Set, které interně budou používat properties objektu.
Nevýhoda: Uměly by jen stringové klíče.

---------------------------------------------------------------

TODO: Zrušit Entity Proxy.
- Entity už umí invalidate().
  TODO: Měla by na ní zbýt metoda isValid();
  [done]
TODO: Zkontrolovat, že se mažou i metody.

TODO: Invalid entity reference (vznikne loadem jiné entity, která má
  referenci na zatím neexistující entitu) by měl být jiný objekt než
  smazaná entita (ať se to neplete).
Ona se vlastně moc lišit nebude.
- Bude mít idčko (to potřebuje, aby se dala napojit po loadnutí správné entity)
- Bude mít isValid() { return false; }
- Bude mít getId()
- Bude mít getErrorIdString()
  {
    return "Invalid (not yet loaded) etity (id: 'xxx')";
  }

TODO: Zrušit Proxy při serializaci.
- bacha, jsou i v Entity
[done]

IDEA:
- nesavovat Set a Map, pokud jsou prázdné
  (ono to asi moc nepomůže, protože se stejně v instantiate() vyrobí
    nové prázdné...)
[done]
TODO: necheckovat jen Array (a own property 'length'), ale prostě přítomnost
  libovolné own property.
  - ta own property navíc musí mít v sobě nějakou savovatelnou value, jinak
    nemá smysl ji savovat.
[done]


TODO: Savovat prototypy, když z nich udělám instanci nebo ancestora.
[done]

TODO: Serializovat jen own properties.
[done]

---------------------------------------------------------------

TODO: Admins by měla být Entity class a měla by se savovat.

TODO: Přesunout server-side kód z Entity do ServerEntity.

TODO: V Serializable (a asi i v Entity a možná ještě někde) přesunout
private metody do modulu, ať je s sebou netahají všechny zděděné objekty.

---------------------------------------------------------------

BIG TODO: Vyzkoušet, co se stane, když chyba typu dereference 'null'
  vyhodí výjimku
  (Mělo by se to odchytit a zalogovat, ale otázka je, jeslti to crashne
   program nebo ne).

IDEA: Možná bych se pak obešel bez EntityProxyHandleru, když bych po smazání
  entity deletnul všechny properties (možná s výjimkou ička, aby v případě
  exceptionu šlo poznat, na kterou entitu se snažím přistupovat).

---------------------------------------------------------------

TODO: Ještě přece jen zvážit zavedení ServerEntity a ClientEntity (zděděno
  nejspíš z ContainerEntity). Pak by šlo většinu metod z Entities přesunout
  čistě do server-side kódu.
[done]

- Má být Account zděděný z ContainerEntity?
  - nemá. Sice by lákalo dát do account.contents charactery, ale to není
    dobrý nápad, protože chary mají vlastní location. Tzn. musí to být
    extra informace.
- Potřebuju ContainerEntity na Klientu?
  - asi ne. A kdybych někdy náhodou potřeboval, tak holt prohodím
    dědičnost a bude z ní zděděné i něco, co container být nemusí.

---------------------------------------------------------------

TODO: XXXSocketDescriptor Přejmenovat na XXXSocket
- tohle bude složitější, metody tam mají parametr socket typu buď
  net.socket (pro telnet) nebo WebSocket (pro websockety). Tzn.
  stávající typ WebSocket (z modulu 'ws') bude třeba přejmenovat
  (asi na ws), a ten parametr změnit buď na 'ws', nebo raději
  předávat celou classu Socket (to dává asi i větší smysl).
  - respektive TelnetSocket či WebSocket podle typu.

TODO:
AuthProcessor přejmenovat na Authentication
ChargenProcessor přejmenovat na Chargen
atd.
[done]

TODO: CommandInterpretter přejmenovat na Commands
[done]

TODO: V CommandListu nahradit hasmapu classou Map.
- a možná ho mergnout s Commands...

TODO: Ve static classách typu Game, Characters, Entities a podobně by
  asi mohl být celý kód ve static metodách (nemusí se ze static metody
  volat nonstatic metoda stejného jména).
- neplatí to pro App, protože tam potřebuju polymorfismus.

TODO: AdminList přejmenovat na Admins.
[done]
TODO: Property v Admins hodit do closure v constructoru, ať jsou
  opravdu private (otázka teda je, jak pak půjdou savovat...)

TODO: V Accountu by místo seznamu jmen charů měl být EntityList.


TODO: Connection nemůže být Entity
- protože se vyrábí i na clientu (respektive mohla by být na serveru zděděná
  z Entity a na Clientu ne, ale je to asi divné).
[done]

Ad loadování contents:
- nejlepší by asi bylo do referencí rovnou loadovat patřičné entity.
  (Ale vytvořit při loadu invalid reference a pak je v postLoadu
   reloadnout je asi taky ok.)
   [done]

Characters
- měly by mít NameList (online unikátní jména)
- měly by mít AbbrevList (vyhledávání ve všech charach)
Potřebuju na něco seznam všech charů bez čehokoliv dalšího?

---------------------------------------------------------------

TODO: Zprovoznit save/load ContainerEntity.
- možná by se ContainerEntity mohla jmenovat prostě Container.

Chci, aby po loadu byly správně nastavené reference v .contents
- Řešení: Loadnout nejdřív contents, pak až container
 (To bych ale musel hacknout, protože na loadnutí vložených entit potřebuju
  znát jejich idčka - a ta jsou uložena v container.contents)
- Druhá možnost: Umožnit loadnout entitu z invalid reference (tak jsme to měl
  původně).


TODO: zavést metodu getClassName()
[done]

Jak je to s různými listy?
-------------------------

EntityList
  (Map<id, Entity>)
- NameSearchList
    (Map<name, Entity>)
    (Tady mají smysl jen unikátní entity)
  - AbbrevSearchList
    - CharacterList

- jediný NameSearchList je zatím AccountList

contents v EntityContaineru by asi rovnou mohlo být AbbrevSearchList
(Což je problém, protože k čemu mít tuhle funkcionalitu na clientu?)

TODO: Přejmenovat AbbrevSearchList na AbbrevList.
- možná dokonce rovnou na Abbrevs.
TODO: Přejmenovat NameSearchList na NameList.
- možná dokonce rovnou na Names.

AbbrevSearchList by asi nemusel být NameSearchList
(a ostatně asi ani EntityList, jsou to nesouvisející věci).
- asi by ale mohl existovat EntityAbbrevList, což bude EntityList
  s vnořeným AbbrevListem

NameSearchList by měl mít proměnnou cathegory, podle které bude
enforcovat kategorii vložených jmen.

TODO: Když je entita v NameListu, tak je ji potřeba při přejmenování
reinsertnout.

TODO: Když je entita v AbbrevListu, tak je ji potřeba při změně aliasů
reinsertnout.

TODO: AccountList přejmenovat na Accounts, CharacterList na Characters.
[done]

---------------------------------------------------------------

Kdy se volá Entities.createInstance()?
  // Tady by se mi hodilo předávat jméno prototypu, abych ho nemusel
  // pokaždé hledat v Prototypes.
- při zakládání nových instancí

Kdy se volá Entities.createPrototype?
  // Tady musím předávat idčko předka, protože předkem je root object,
  // a to se zjistí tak, že hodnotou 'ancestorId' je className.
- ServerPrototypes.initRootPrototype()
  // Tady by se asi taky hodilo předávat jméno předka...
- Při zakládání nového prototypu

=> Možná by nakonec bylo nejlepší mít 2 metody na vyrábění prototypu
   v Entities:
   // Je dobrý nápad vyrábět prototypy (a ostatně i instance) ze shared kódu?
   Entities.createPrototype(ancetorName: string)
   // Tohle určitě může být jen v ServerEntities, root prototypy
   // se vyrábí na jediném místě.
   ServerEntities.createRootPrototype(className: string)

TODO:
- createInstance() a createPrototype() přesunout do ServerEntities.
  Obojí bude mít jako parametr jméno prototypu (respektive předka).
- přidělat createRootPrototype()
[done]
requestName() taky hodit jen do ServerEntitites.
- tak ne, používá se to v Entity.setName(), takže to musí být v /shared


TODO - promyslet:
Může mít prototyp unikátní jméno entity?
- zdědí ho všechny instance a potomci, takže nemůže.
[done]
TODO: v setName() kontrolovat, že nesetuju unikátní jméno prototypové entitě.

TODO: V Entities oddělit protected abstract metody od obyč protected metod.

TODO: Funkce z FileManageru na loadování/savování entit přesunout
  do ServerEntities.
[done]

TODO: Funkci z FileManager na loadování/savování name lock filů
  přesunout někam jinam (Možná nová classa Names?)
  - tak NameLock
[done]

TODO: deserialize() a createEntityInstance() vyhodit ze Serializable
 - přesunout to do ServerEntities, možná to jinak pojmenovat.
[done]

-----------------------------

TODO: Asi bude nakonec nejlepší držet v Class factory zvlášť Entity
a neentity classy (zjednoduší to typování, atd).

TODO: Root objecty neměly být entity, aby si je někdo omylem
  nevyžádal z EntityManageru a nepoužil je.
- měly by se accessovat pouze při hledání prototype objectu pro
  novou entitu.

TODO:
EntityManager se může jmenovat prostě Entities
PrototypeManager se může jmenovat prostě Prototypes
ClassFactory se může jmenovat prostě Classes (nebo DynamicClasses).
- co FileManager?

Řešení jmen prototypů:

class Entity
{
  // Root prototypes use class name as prototypeName.
  // Dynamically created prototypes override this value
  // with a new name.
  public prototypeName = this.constructor.name;
}
Problém je při deserializaci:
- prototypeName se musí savovat, protože jinak by si prototypy
  nepamatovaly své jméno. Tzn. když změním jméno classy v kódu
  a pak loadnu prototypovou entitu, tak se mi prototypeName přepíše
  tím, co přečtu ze souboru.
- navíc je problém s tím, že prototypy mají name lock file
  v /data/names/prototypes, který při přejmenování classy v kódu
  zůstane name lock file viset (odkazuje se na něj právě jen to jméno).


IMPORTANT:
Používat na jméno prototypu entity.name a NameCathegory.PROTOTYPE je
asi chyba:
- Jméno entity dědí potomci a instance, takže když budu chtít mít 30
  instancí 'Sandy Road', tak do prototypu setnu name 'Sandy Road'
  a jsem done.
  - Mít jména prototypových entit uníktní ale znamená, že když bych
    chtěl jinde roomu s názvem 'Sandy Road', tak bych musel prototyp
    pojmenovat jinak a jméno setnout do všech insatncí.
=> Jméno prototypu by nemělo být v entity.name.
   - Může být v PrototypeManageru, ale pak bych musel PrototypeManager
     savovat, což nechci.
   - když ho dám do entity.prototypeName, tak by asi měla fungovat
     i dědičnost, tj. entita si ve své .prototypeName může přímo přečíst
     jméno svého prototypu.
Asi bych chtěl, aby se hardcoded prototypy jmenovaly stejně jako classa
- ideálně by se v tom případě jméno mělo číst přímo z Class.name.
Jak na to?
  Entity.type: EntityType
  {
    HARDCODED_PROTOTYPE,
    DYNAMIC_PROTOTYPE,
    INSTANCE
  }  
- když je typ HARDCODED_PROTOTYPE, tak se jméno prototypu čte z Class.name
- když je typ DYNAMIC_PROTOTYPE, ta se jméno prototypu čte
  z entity.prototypeName
Hmm...
Jména prototypů se klindě mohou dál savovat do /data/names, ale nemělo
  by se to řídit NameCathegorií.
Hmm, možná jsem neměl mazat Nameable :-)



TODO: V loadEntityById() checkovat, že jméno uvnitř entity odpovídá
  jménu name lock filu.

TODO: Ošetřit změnu jména z a do kategorie PROTOTYPE
  - nestačí změnit jméno a přesavovat name lock file, je tak třeba
    z entity udělat prototyp/instanci.

TODO: Asi by bylo lepší vyrábět nové entity nikoliv z prototypeId
  ale z prototypeName - abych nemusel ručně hledat v PrototypeManageru.
(podhazovat prototypeId má smysl při deserializaci, páč v JSONu je idčko).
[done]

---------------------------------------------------------------

Kdy a jak se vytváří nové/existující entity:
1) při loadu/deserializaci
  - podle id, nebo podle unique name (jen na serveru).
  - do prototypu se nic nezapisuje, už to tam je.
EntityManager.createInstance()

2)
- createNewPrototype (ten je vždycky unique)
- createNewInstance
- createNewUniqueInstance

/*
Bordel s terminologií:
instance znamená
- instanci classy (tj. i prototypová entita je instance)
- instanci prototypu
  - tomu bych mohl říkat descendant (na druhou stranu
    v descendantIds držím descendant prototypy.

Mohl bych tomu říkat:
  .descendantPrototypeIds
  .descendantInstanceIds

// Mám idčko
EntityManager.createEntityById()
// Generuju nové idčko
EntityManager.createNewEntity()

- Aha tak ne, já jsem to sloučil a idčko je prostě nepovinný parametr.
  Makes sense.

- co jsem ale nesloučil je vytvoření prototypeEntity vs instanceEntity.
  Což je asi chyba, to dělá problémy.
*/

Jak to bude:
-------------

Podstatné je, jestli vyrábím novou nebo existující entitu.

EntityManager.createExistingEntity(prototypeId: string, id: string);
- tady je id povinné (protože vyrábím existující entitu) a nemusím
  řešit, jestli vyrábím prototyp nebo instanci (protože je to už
  v prototypu zapsané).
[done]

EntityManager.createNewInstanceEntity(prototypeId: string,
                                      name: string,
                                      cathegory: Entity.NameCathegory = null);
EntityManager.createNewPrototypeEntity(prototypeId: string,
                                      name: string,
                                      cathegory: Entity.NameCathegory = null);
- tady idčko nepředávám, bude se vyrábět nové.
- rozlišuju, jestli vyrábím instanceEntity nebo prototypeEntity.
-- rozlišuju setování unikátního a neunikátního jména
   (díky tomu můžu nejdřív vyrobit idčko, pak zkusit, jestli je jméno volné
    a když ne, tak stačí zahodit jen idčko, netřeba zahazovat celou entitu).
TODO: Použít tohle i při vytváření root prototype entit.
[done]

TODO: Oassertovat, že se instanceEntity nepoužívají jako prototyp.
[done]

---------------------------------------------------------------


TODO: Name lock fily by se měly savovat lowercasovaně
(protože na linuxu jsou soubory case sensitive).
=> Nepůjde mít současně Excalibur a excalibur
   - to je asi dobře.
[done]

---------------------------------------------------------------

Zpátky na stromy (nebo taky ne)
--------------------------------
- když bych loadoval prototype entity on-demand (tj. při loadování jiné
  entity), tak bych se asi zbavil všech problémů s rozlišováním prototypových
  a neprototypových entit.

- Problém by byl s přiřazováním prototypů - mohla by nastat situace,
  že by některé prototypy nebyly loandnuté v paměti.
- současně by taky byl problém rozlišit, které entity mají jít
  přiřadit jako prototypy (v principu sice jakákoliv entita může
  sloužit jako prototype, ale vylistovat v seznamu prototyů všech
  150 instancí pixie soldierů by bylo extrémně matoucí).

- asi by to šlo vyřešit nějakou externí informací, třeba zrovna
  přítomností v PrototypeManageru. To by ale znamenalo, že se tahle
  externí informace musí savovat (tj. savovat PrototypeManager).

  - když bych savoval PrototypeManager, tak bych ani nepotřeboval
    on-demand loadování prototypů (stačilo by loadnout to, co je
    uvedeno v prototypeManageru).
  - asi by dávalo smysl držet tam spíš jména prototypů než idčka,
    protože idčko můžu loadnout z name lock filu.
BTW prototypovou entitu poznám podle nameCathegory...
  - další věc je, že pokud bude seznam prototypů v prototypeManageru,
    tak to nemusí být entity s unikátním jménem (páč manager zajistí
    unikátnost jmen prototypů).
  - manager by taky mohlo řešit on-demand loadování prototypů (i když,
    pokud by držel jen jména prototypů, tak asi ani ne).

- hmm, ještě je tu jeden související problém - hardcoded dědičnost.
  V zásadě bych asi chtěl umět rozdělit prototypy podle toho, jestli
  jsou zděděné z Characteru nebo Roomu - a na to bych potřeboval znát
  interní strukturu dědičnosti hardcoded entit, kterou nepřečtu
  z property 'prototype'...
  - měl bych ji ale být schopen přečíst z javascriptového prototype chainu

Pozn: Možná není až tak dobrý nápad nazývat property 'prototype'.
  (i když to je asi ok, javascriptová 'prototype' je property constructoru,
   jinak řečeno static property).
 - i tak by to ale asi bylo lepší nezvat 'prototypeEntity'.
TODO: Přejmenovat property 'prototype' na 'prototypeEntity'.

Když budu v prototypeManageru držet reference, jak se to pak bude loadovat?
- standardně se při loadu reference na neexistující entitu vyrobí invalid
  reference.
  - tj. buď by to muselo mít výjimku, nebo bych pak posléze ty invalid
    reference prošel a ručně naloadoval (to by znamenalo spoustu zbytečných
    dotazů na EntityManager, jeslti náhodou takovou entitu nemá a vyrábění
    zbytečných invalid referencí, které se následně přepíšou validními
    referencemi při loadu, ale co už...).

- pořád bych asi měl vytvářet root prototype entity (aby se do nich
  dalo savnout, co mají za instance. Což chci dělat, proto, abych
  mohl ve hře vypsat, co je z entity zděděno).

- jo, tak přece jen asi musím rozlišovat nameCathegory u prototypů,
  protože když budu přes PrototypeManager zjišťovat, zda je entita
  prototypem, tak musím nějak odflitrovat neunikátní enetity, které
  se shodou okolností mohou jmenovat stejně jako prototyp.

Prolézání celého prototype chainu:
  - rekurzivně přes 'prototypeEntity', dokud se nedostanu na root entitu.
  - pak rekurzivně přes constructor.prototype (nebo možná
    Object.getPrototypeOf()) dokud se nedostanu na GameEntity.
- tuhle hierarchii by asi stálo za to rekonstruovat v PrototypeManageru,
  abych mohl jednoduše vypisovat subtree a tak.
  - ale nejspíš tak, že se všechny entity classy budou registrovat, tj.
    včetně GameEntity a tak, byť některé z nich jako abstraktní.
    Při téhle registraci (nebo možná dodatečně) se vyrobí abstract ancestor
    tree v PrototypeManageru.
  - dynamic prototype tree nemusím rekonstruovat, páč ten si drží entity
    v sobě (v 'instanceIds' a 'prototypeEntity').
  (tohle teda asi nemusím dělat hned)

Nevýhoda řešení přes PrototypeManager je, že se pak manager bude muset
savovat při každé změně...

-----
Závěry:
- Jména prototypů musím nutně všechna držet v paměti, protože s nimi
  potřebuju pracovat (vybírat z nich při přiřazování prototypu novým
  entitám).
  => Můžu zrušit nameCathegory PROTOTYPE
     (ono by bylo vůbec divné, kdyby se z nameCathegory poznávalo, jestli
      je entita prototypem)
   - PrototypeManager bude zajišťovat unikátnost jmen prototypů.
  => PrototypeManager si bude pmatovat jména prototypů.
   - měl by mít zároveň i reference na prototypové entity
     (protože při přidělování prototypu entitě je třeba znát
      referenci - 'prototypeEntity' je refrence).


Ještě pár úvah k původní variantě, tj. rekurzivní loadování prototypů
podle informace uložené u entit:
---------------------------------------

Problém je při loadování prototypů.
- initRootPrototypeEntity()
  - přečte se idčko z name lock filu
  - zavolá se EntityManager.loadEntityById(id)
    - zavolá Serializable.deserialize(id)
    (při loadu se vytvoří instance entity, nikoliv prototype entity).
Hmm, ono je to celé divné
- při loadu mi přece může bejt jedno, jako co tu instanci vytvářím, protože
  do descendantIds ani do isntanceIds prototypu nic zapisovat nebudu, to už
  tam zapsané je.

TODO: Musím si promyslet, jak je to s unikátností jmen prototypů.
- teoreticky by nemusely být absolutně unikátní, protože mají stromovou
  strukturu. Na druhou stranu pak by nešlo přiřadit prototyp podle jména
  bez toho, abych tu strukturu vypsal....
- pokud chci mít všechny prototypy v abbrevSearchListu, tak asi nemusí být
  unikátní (mohou se vyhledávat přes 3.desert ...)
- každopádně ale asi nevadí, že mají prototypy jména v samostatné kategorii.

IDEA: Udělat z nameCathegory prostě Cathegory.
- tj. by nebylo divné, že se podle toho poznává, jeslti je entita
  prototyp
- a taky by dávalo větší smysl, že když chci z instance udělat prototyp
  nebo naopak z prototypu instanci, tak musím změnit Cathegory.
Na druhou stranu...

Určitě dávají smysl kategorie
- prototyp
- account
- unique character
Těžko říct, jestli nutně potřebuju World (zóny budou mít unikátní jména
  díky prototypům)
  - spíš ne

---------------------------------------------------------------

ÚVAHA (o potřebě savování className)
- className je jméno podslední hardcoded classy v chainu
  (dále za ním jsou už jen dynamické prototypy). Je to tedy
  typ, podle kterého by se měl řídit TypeScript.
- při loadu entity bych tedy asi měl z ClassFactory vytáhnout Class
  podle loadnutého className a použít ji jako typ návratové hodnoty
  - je to vůbec možné? Ten typ zjistím až v runtimu...

TODO: PrototypeManager by asi měl být search list,
  aby se v něm dalo vyhledávat podle abbreviationů.
  (to ale nemusím nutně řešit hned).

ÚVAHA (vyrábění unikátních entit):
- nejde nejdřív zkusit vyrobit name lock file a až pak si říct
  o nové idčko, protože idčko se zapisuje do name lock file, tj.
  musím ho znát před tím, než zavolám setName.
- teoreticky bych ale nemusel vyrábět entitu, mohlo by stačit
  vygenerovat si idčko (pak si říct o name lock file a až když
  to projde, tak vyrobit entitu s tímhle idčkem).

PROBLÉM: Při loadování prototypů se volá standardní
  Serializable.deserialize(), kteréžto vyrobí instanceEntity, nikoliv
  prototypeEntity.

---------------------------------------------------------------

Ještě jednou k vyrábění instancí:
----------------------------------

Object.create() a instantiateProperties() by asi měla dělat ClassFactory,
protože takhle vyrobeným instancím se v javascriptu říká factory classes.
- asi to půjde, protože instantiateProperties() se volá nad obecným objectem.

---------------------------------------------------------------

IDEA: Shared classy nenazývat SharedClass ale prostě jen Class

TODO: Ještě přece jen zvážit, jestli je nutné mít dvě paralelní
  struktury stromu entit (nakonec je to asi fakt nejlepší řešení).
- Možná by to šlo naopak udělat tak, že např. Room by byl společný
  základ (tzn. jedna classa, jen v /shared) a na serveru by na sobě
  měl navěšený modul s přidanou funkcionalitou (třeba commandProcessor).
  - otázka teda je, kdo by ho tam při vytváření instance pověsil...


TODO: věci ze /shared/type možná hodit do /shared/utils

---------------------------------------------------------------

shared GameEntity
{
  shared name
}
-> shared Room extends GameEntity
   {
     client exists;
     shared description;
     shared exits;
     shared affects;
   }
-> shared Mob extends GameEntity
   {
     // Tohle jsou reference na entitu (class Spec), na clientu
     // mohou být prostě invalid.
     // (Na druhou stranu asi by se hodilo vědět, jaký spec ten mob má
     //  .. i když asi jen v editoru a ten by měl umět editovat i specy.)
     combatSpec: Entity
     workingSpec: Entity
     holidaySpec: Entity
   }


shared Affects
{
  shared affectList;
  server addAffect(); // Musí to být nutně server-only?
}

shared Spec
{
  /// Tohle fakt client nepotřebuje.
  /// Na druhou stranu potřebuje umět ty specy editovat
  /// (i když, pokud se vykašlu na skripty obecně, tak vlastně proč?
  ///  prostě by se editovaly ve visualku).
  server onEnterCombat();
  server onLeaveCombat();
  server onNearbyCombat();
}
-> shared CombatSpec extends Spec
   {
     resource: number;
   }

   server SorcererCombat extends CombatSpec
   {
     server resourceName = 'Arcane Power';
   }

---------------------------------------------------------------

Prototypy: Jak te teda nakonec bude (snad):
-------------------------------------------

ClassFactory.createRootEntities() vytvoří kořeny prototypových stromů
s id = className.
  Tohle se stane na serveru i na klientu.
  (Tyhle entity nebudou uvedené v prototypeManageru, tudíž se z nich nebude
   dědit. Dědit se bude až z entit vytvořených v následujícím kroku.)
  (Tyhle entity se taky nebudou nikdy savovat).
Ke zvážení: Možná by se nemusely ani vytváře přes Object.create(), stačilo
  by new Class. (Určitě ano - TODO [done]).

Server pak zavolá prototypeManager.initPrototypes(), který ke každé této
  entitě vyrobí instanci s nově vygenerovaným idčkem a name = className.
  (Protože jako jméno prototypu slouží jméno entity.)
Tzn. když si někdo z PrototypeManageru vyžádá prototype 'Room', tak nedostane
  root entitu s idčkem 'Room', ale prototyp jménem 'Room' s náhodně
  vygenerovaným idčkem.
- tyhle entity budou mít ve svém .descendantPrototypes seznam zděděných
  prototypů, přes které to pak půjde rekurzivně loadnout.

Při posílání entity ze serveru na klient se pošlou všechny prototypy
v chainu až na 'root entitu' - tu má client vlastní (vyrobil si ji při
startu stejně jako server) a idčko má 'className', takže stejné jako server
(tj. není třeba posílat na client idčka root entit).

---------------------------------------------------------------

TODO:
V ServerApp.run() volá ClassFactory.createRootEntities();
- což je správně, to zůstane (vyrobí se tím entity s className coby idčkem)
- tohle udělá client i server, takže kořeny prototypových stromů není třeba
  posílat (klient má stejné classy jako server).
Pak se na serveru zavolá PrototypeManager.initPrototypes();
- což rekurzivně loadne ostatní prototypové entity podle descendantPrototypes.
(Hmm, to by znamenalo, že PrototypeManager nemůže být v /shared, což je asi
 chyba - v klientovi budu potřebovat umět vybírat prototypy)
Takže udělat SharedPrototypeManager, ClientPrototypeManager
  a ServerPrototypeManager?

Argh...
- hardcoded prototype entity s random idčky mají problém v tom, že pak ta
  idčka nezná klient (zatímco když použiju className, tak je klient zná taky,
  páč má ty samé classy).
Ok, takže asi zpět k původnímu konceptu:
- ClassFactory vytvoří hardcoded prototype entity s className coby idčky.
- Server si pak vyrobí (nebo loadne) root prototypy založené na těchle
  entitách.
  - root prototypy budou mít unique name (cathegory: prototype), ičko
    a budou se ve svých descendantPrototypes odkazovat na ostatní prototypy.

---------------------------------------------------------------

Závěr z úvah o instancování zón (a entit s unikátním jménem), struktuře
savů, atd:
- na obojí se teď vykašlu. Není to potřeba k tomu, abych vytvořil funkční
  (a hlavně hratelný) prototyp.
- Entity.load() musí být abstraktní.

Hmm, co s uložením globálních prototypů?
- pokud se chci vyhnout one-demand loadování prototypů (jako že chci,
  zas mi to teď trochu zjendoduší práci), tak musím všechny prototypy
  držet v paměti (a všechny je loadnout při startu hry).
  - zpět k prototypeManageru?
    Nebo si je bude držet sám World?

- stejně ten seznam prototypů někde mít musím, aby v nich šlo rozumně
  vyhledávat.

World (coby kontejner pro prototypy) by měl výhodu v tom, že bych
fakt loadovat jedinou entitu.
- ostatně kdyby ty prototypové entity měl ve svých contents, tak bych
  ani nemusel psát žádný kód navíc (teda možná jo, pořád by záleželo na
  pořadí dědění).


Ještě jsem měl nápad, že bych na loadování z disku udělal metodu paralelní
k Serializable.deserialize(). Ta by řešila on-demand loadování prototypů.
  Tím bych zároveň odstranil nutnost cpát do deserialize() idčko a path
  jako nepovinné parametry.
- ta by asi měla být v Entity - hmm, možná přímo Entity.load()?

IDEA: Rekurzivní loadování prototypů
- musím si někde pamatovat kořeny prototypových stromů
  (tzn. musel bych savovat hardcoced prototypové entity z ClassFactory).
- musím umět rozlišit mezi prototypem a instancí, a to už na úrovni
  prototype.instanceIds.
  (tzn. by to nebylo instanceIds, ale instances a byla by to struktura
  obsahující idčko instance a bool: isPrototype)
  - a nebo jinak, udělat z toho dvě struktury:
    .descendants
    .instances
    - descendants by se loadovali rekurzivně (a vypisovali při sekeci
      prototypu)

Měly by mít prototypy location?
- Pokud má někdy být prototypem celá zóna, tak asi budou muset.
  Ale to je asi ok, při loadnutí instance se location pochopitelně změní.

Něco musí umět loadnout/savnout hardoced entity prototypy
(btw když už je budu savovat, proč se nevrátit k tomu, že mají stejné idčko
 jako všechny ostatní entity?)

Co je jasný:
- určitě nedávat prototypy do world.contents
- musí ale existovat entita, která bude umět savnout kořenové prototypy
  (a možná by mohla umět rekurzivně savnout všechny...)
- nemusím ručně vyrábět prototyp Worldu, protože World je hardcoded entita,
  tudíž se pro něj prototypová entita vyrobí automaticky
- musím rozlišovat mezi vyráběním prototypu a instance.
  Tzn.:
    Entity.createInstance()
    Entity.createPrototype()

Tak asi přece jen návrat k PrototypeManageru?
  (zděděného z Entity)
   - asi ale ne z Container entity, protože prototypy potřebují umět mít
     locationId
   (I když tady se bavíme o hardcoded prototype entitách, ty klidně můžou
    mít jako svou location PrototypeManager)


TODO
Entita by měla mít referenci na prototyp, ne jen prototypeId
 (bude se přes ni často na prototyp sahat).

---------------------------------------------------------------

NamedEntity a client/server architektura
-----------------------------------------

Client v zásadě potřebuje znát jen property 'name'
- nepotřebuje ani unique kategorii, protože ta má význam pouze při setování
  jména.
- nepotřebuje jméno setovat, to se dělá vždycky na serveru.

Name property by asi mohly mít všechny entity - pak bych mohl celou classu
přesunout do server-side kódu.

- enum NameCathegory asi bude muset být v Entity, aby mohla mít metodu
    setName(name: string, cathegory: NameCathegory)
  - bez toho asi nepůjde přetížit v UniqueEntity.


Řešení:

static isNameTaken() může být v EntityManageru
- client řekne, že se na tohle nemáš ptát, server checkne
  nameLockFile.

Entity.setName() se zeptá EntityManageru, jestli je možné jméno setnout.

if (EntityManager.requestUniqueName())
  ...

---------------------------------------------------------------

Entity class hierarchy
=======================

shared/Nameable
-> shared/Attributable
  -> shared/Serializable
 /*   -> shared/Saveable  */ (Deprecated, Entity is the only saveable object)
    -> shared/Entity
        -> shared/ContainerEntity
          -> shared/SharedGameEntity
             (tohle možná nebude potřeba)
              -> server/UniqueEntity   (TODO: Add this)
                -> server/ServerGameEntity
            -> client/ClientGameEntity

Na klientu a na severu budu muset mít paralelně stejnou strukturu
herních entity (World, Area, Room, etc.).
- v tomhle případě budou mít stejná jména (/server/World, /client/World),
  protože className se používá jako idčko prototypu při deserializaci.

- nemělo by jít o duplikaci kódu, protože sdílená data a funčknost budou
  v EntityData. Tj. na clientu bude jen něco jako:

  class World
  {
    data: WorldData;
  }


Entity data class hierarchy
----------------------------

shared/Serializable
-> shared/EntityData
  -> shared/RoomData

---------------------------------------------------------------

Save/load
----------

IMPORTANT: Savovat a loadovat se budou jen entity!
(tj. žádný SaveableObject, který nemusí být entitou)

=> Nepotřebuju vůbec Saveable, protože savovat se bude
   externí metodou.
=> Nepotřebuju metody na SaveFileName a SaveDirectory,
   protože to zkonstruuju z idčka (entity.getId())
   a případně z prototype chainu.

Co kontejnery?
- ty pořeší stávající návrh, tj. metoda save() a load() uvntiř entity.

TODO:
- zrušit Saveable
- přesunout save() a load() do Entity
- konstruovat saveLocation() z prototypové entity
  (protože ta musí při loadu existovat, takže z ní vždycky můžu lokaci přečíst)
  - jen hardcoded hierarchii
    (jak tohle udělat? Jak poznám, co je hardcoded prototyp?
     - zeptám se ClassFactory?)
- při vytváření saveLocation() nebude třeba se ptát ClassFactory, protože
  jen hardcoded classy budou mít className.

Výhledově:
- savovat instance někam jinam (asi pod zónu).
  IDEA: adresář by se mohl jmenovat jménem zóny
        - a pod ním by byla stejná struktura jako v /prototypes,
          tj. /Room, /Character, etc.
    (ta struktura by se vytvářela automaticky, což je fajn)

Pořád nevím, jak při loadu zjistit, jakou entitu loaduju (a tedy odkud ji
mám loadnout).
- v containeru může být všehochuť, takže bych si musel u každé reference
  pamatovat, co je zač.
- stejně tak u prototypů (nestačilo by prototypeId, musel bych vědět i typ).
To by znamenalo, že bych měl className rozlezlé všude možně po savech...
A taky že by se blbě měnil typ třeba z Moba na Object, protože pak by se to
jednak muselo savnout jinam a za druhé by to bylo špatně ve všech savnutých
referencích...
=> Kašlat na strukturu, savovat všechny entity do jednoho adresáře.

TODO:
Při loadu entity podle idčka:
- otestovat, jestli to id je v EntityManageru. Pokud ano, hodit error.
- bude asi potřeba rekurzivně loadovat prototypy.
- zjevně nebudu potřebovat číst save location z entity
  (páč to bude pro všechny entity stejné)

-----------------------
Celé jinak:

- zóny bych měl umět instancovat.
- asi má smysl uvažovat o loadování/savování po celých zónách.

Tzn. když zóna bude vědět, co jsou mobové, co jsou objekty, atd.,
může si to savnout do příslušných podadresářů.

- pak je ještě možnost brát to podle toho, co je do čeho vnořené.
  Tj. rooma si savne/loadne svůj obsah (a zóna vlastně taky).
  - a může si ho loadnout/savnout do příslušného podadresáře.

Čili bych měl adresářovou strukturu podle vložení...

Ideálně by to mělo být tak, že adresář je jedna ContainerEntita,
tz. nemělo by to být:
  id.json (file)
  ID.JSON (dir)
    ...

Ale
  ID.JSON (dir)
    id.json(main entita)
    ... (adresáře vložených entit)

ZÁVĚR
Ok, tohle by šlo (tedy za předpokladu, že se budou savovat celé containery,
 což ale asi budou).
- co s prototypama?


Universe structure
---------------------

Universe (neinstancuje se)
- globalPrototypes
    (tohle by byly asi jen seznamy a byly by tu v podstatě jen kvůli savování)
  - globalWorldPrototypes
  - globalRealmPrototypes
  - globalAreaPrototypes
  - globalCharacterPrototypes
  - globalRoomPrototypes
  - globalObjectPrototypes
- instances
  - worldInstance (má nějakej globalWorldPrototype)
    - realmInstance (má nějakej globalRealmPrototype)
      - zoneInstance
        - roomInstance
           - objectInstance
           - objectInstance
           - mobInstance
             - objectInstance (bágl v inventory)
               - objecInstance (item v báglu v inventory)

Jak bude probíhat editování nové zóny:
---------------------------------------

1) create area 'New Area'
  - zeptá se to na prototyp (nebo se dosadí rovnou Area? Asi jo.)
  -> vyrobí se nová entita a přidá se do globalAreaPrototypes
2) create room 'First Room'
  - zeptá se to na prototyp
- v tenhle moment by se asi zóna mohla automaticky instanciovat, instance
  se přidá do Universe.instances


Výběr prototypu (v editoru) by měl bejt kontextovej
 - jednak by to měl bejt strom (aby se šlo doklikat)
 - a mělo by to filtrovat výběr podle substringu
- kromě toho by to mělo být samo o sobě kontextové, tj. když vyrábím novou
  roomu, mělo by mi to vyfiltrovat jen prototypy room.
Stejnou komponentou se bude vybírat prototyp k editaci.


Úvahy k instancování zón...
- mělo by být možné dát goto do prototypu roomy?
  - určitě ano (proč ne).
  - neměl by se tam ale dostat mortal
    (ale to můžu ošetřit dodatečně, tím se teď nemusím trápit)

Co se stane, když dám 'load object <prototyp>'?
- musí se samozřejmě vytvořit nová instance. Tohle je tak nějak self-evident.
(není to self-evident v případě zóny, nebo obecně libovolného containeru,
 ale v principu by to mělo fungovat stejně, jen rekurzivně)
- loadnutý objekt se musí do něčeho dát (do inventáře imma, který ho loadnul).
  - u zóny je to stejné, jen se samozřejmě nemůže dát immovi do inventáře
    (i když, proč ne?)


---------------------------------------------------------------

Úvahy o className, jménech prototypů, atd.
-------------------------------------------

- jako jméno prototypu by mohlo sloužit jméno entity
  - otázka je, co kdyz je prototypem hardcoded entity
    Řešení: Při vyrábění hardcoded prototype entit v ClassFactory
      jim setovat className do name.

TODO: Zrušit z Nameable šaškování s className prototypů
  (možná zrušit celé Nameable).

---------------------------------------------------------------

TODO: Rozlousknout pojmenování EntityManageru
(pokud jich bude víc, tak by se asi měly jmenovat SharedEntityManager,
 ServerEntityManager, ClientEntityManager).

IDEA: App, ServerApp a ClientApp dát do /lib/app

TODO: Zavást entity classu Config, kam půjdou uložit věci
  jako motd
  (bude to normální entity classa, defaultní hodnoty classy budou prostě
   defaultní hodnoty těch nastavení).

TERMINOLOGIE:
- remove() odstraňuje z daného seznamu
- release() odstraňuje z daného seznamu a z EntityManageru (tedy i z paměti)
- delete() odstraňuje ze seznamu, z EntityManageru a maže i z disku.

TODO: Zbavit se metody getInstance()
(App.instance může být prostě property a přistupovat na ni budou statické
 metody.)
- getInstance() pořád potřebuju (hlásí error, když instance neexistuje),
  ale je z ní protected metoda.
[done]

TODO: SeverUtils a SharedUtils asi přece jen dávají větší smysl, než mergnutý
  namespace Utils (bude pak jasnější, k čemu se ta utility metoda vztahuje).
[done]

TODO: V Entity a EntityManager přerovnat private a public metody.


TODO:
- ContainerEntity.setLocation() by měla automaticky vyndat entitu z původní
  lokace
[done]
- přidělat protected trigger metodu, která se zavolá při změně lokace.
[na to zatím kašlu. Udělám to, až to budu na něco potřebovat]

---------------------------------------------------------------

Úvahy o prototypech ještě jednou
---------------------------------

- Potřebuju savovat hardcoded prototype entity, protože ty v sobě budou mít
  seznam z nich zděděných prototypů (bez toho bych neuměl prototypy rekurzivně
  loadnout).
- Teoreticky můžu dál nechat ClassFactory vyrábět kořenové entity s idčkem
  rovným className - ty se nebudou savovat - a na jejich základě pro každou
  hardcoded classu vyrobit jednu instanci, která se savovat bude. Z ní by
  pak měly být zděděné další prototypové entity.
  - to je blbost, budu mít zbytečně v každém prototype chainu o krok navíc
To znamená, že musím umět speciálně loadnout/savnout root prototype entity.


- Možná přece jen k něčemu bude, když u hardcoded prototype entit použiju
  className jako id - nebudu si ta idčka muset pamatovat, budu moct příslušné
  entity loadnout "naslepo" (jejich idčka znám).
- Pak je tu ještě možnost udělat z nich unique entity. Potom budou mít
  nameLockFile, který půjde přečíst čistě se znalostí className a z něj se
  přečte idčko (čili opět nebude potřeba idčka savovat separátně)
  - tohle je asi nejlepší řešení.

- Prototypové entity by se při loadu nebo vytvoření měly vkládat do
  prototypeManageru (aby šly vyhledávat podle jména).
  - čili prototypeManager bude vlastně searchList prototypových entit.

(PrototypeManager nemusí být entita, nebude se savovat ani loadovat).

---------------------------------------------------------------

Serializace entity vs neentity
- entita by měla serializovat jen own properties, a to včetně
  podstruktur.
- neentita serializuje všehny properties
TODO: Každopádně je to asi třeba rozlišit.
Jak?
- nejspíš parametrem (protože to to potřeba propašovat i do podstruktur.
- Entity by asi mohly mít přetíženou metodu serialize() a předávat jí
  parametr onlyOwnProperties = true;
  - ani to vlastně asi není třeba přetěžovat, protože:
ZÁVĚR:
Závisí to na existenci property 'prototype'
- pokud existuje, serializují se jen own properties
- když ne, serializuje se všechno.

Deserializace entity vs neentity
- V obou případech je třeba nejdřív vytvořit JsonObject a z něj přečíst,
  jestli se má prototypovat.
- vzato kolem a kolem to není ani nutně výsadní vlastnost entit, prototypovat
  by mohlo jít cokoliv.
Tudíž:
- pokud je v Jsonu property 'prototype', použije se Object.create(prototype)
- jinak se použije new (className)
Na to asi není třeba nic přetěžovat...
  (teda vlastně možná jo, ale při savování, respektive při vyrábění nové
   entity - když bude savovat property 'prototype', tak se pak při
   deserializaci automaticky zprototypuje)
TODO: Prototypování neřeší Serializable, ale ten, kdo deserializaci iniciuje
I když, wait, to přece může dělat deserialize()
- z Json stringu vyrobí Json object
- přečte z něj 'prototype' případně 'className'
- řekne si classFactory o prototypový objekt
- vytvoří instanci
... aha, ne. Musím nedjřív mít instanci, abych na ní mohl zavolat
  deserialize(). Tj. jedině, že by deserialize() byla statická metoda.
  (ale to by asi mohla být - JSON.stringify() a JSON.parse() statické jsou).


IDEA: Přejmenovat Instantiable na Prototypable
- dát do ní PROTOTYPE_PROPERTY
  (to udělám tak jako tak).
(tak asi nepřejmenovávat, ono se tam nic neprototypuje. Pouze se instaciují
 properties)
 - nebo že by se tam přece jen prototypovalo? Ať je to pohromadě?
   Tj. byla by tam nejspíš statická metoda:
     public static createInstance(prototypeObject)

Pozn: ClassFactory by měla mít instance prototypových objektů pro
  všechny dynamické hardcoded classy.

IDEA: 'className' u hardcoded class považovat za 'id'
- tj. pro neentity by getId() vracelo 'className'
- a pro entity by to vracelo 'id'
+ Dát hardoced prototypové instance do EntityManageru
(To by znamenalo, že už classa Prototypable bude mít metodu getId())
... Hmm, to asi nepůjde, protože od některých nenetitových class budu
  chtít mít víc instancí (třeba když Connection nebude entita).
  - pak bych jim asi musel ta idčka přidělovat (a otázka v tom případě je,
    k čemu jim bude dobré).

Každopádně dává smysl, aby classa, kterou lze prototypovat, měla:
- public static PROTOTYPE_PROPERTY
- protected prototype: string;
- public static createInstance()
- private instantiateProperties()


Classa, kterou lze použít jako prototypeObject, by měla mít:
- getId()
A měla by se dávat do entityManageru pod tímhle idčkem
  (tj. dává smysl, aby prototypové instance hardcoded class měly
   'className' jako své id)

Že classu lze prototypovat asi nutně neznamená, že je ji potřeba
prototypovat. Tj. asi to může být jako doposud, že Prototypable
je předkem Serializable (takže všechny Serializable lze v principu
prototypovat), ale jako prototypeObjecty mohou sloužit jen entity.

Závěr: prototypeObject je vždy typu Entity.

Pak je ještě možnost udělat to tak, že Serializable nebude umět
prototypovat a bude z něj zděděné Prototypable, které přetíží
příslušné metody Serializable, aby prototypy dělaly.

Otázka je: Mají to být dvě classy (Prototypable a Entity), nebo
prostě jen Entity?
- Entita by měla mít id.
- Entita by měla mít prototyp.
Asi ničemu neuškodí, když to rozdělím do dvou class - bude to aspoň
sémanticky oddělené...
(Každopádně je fakt, že nemá smysl mít metodu instantiateProperties()
 v něčem, co se nebude prototypovat).
... hmm, tak nakonec asi ne. Id by mělo být v Entitě....
(a věci jako sName by asi mohly být až v nějakém potomkovi
 - symbolicEntity?)
 

Takže:

TODO:
Serializable
 -> Entity
    - ID_PROPERTY
    - PROTOTYPE_PROPERTY
    - id
    - prototypeId
    - public static createInstance(prototype: Entity)
    - private instantiateProperties()

OTÁZKA: Kde vyrábět instance entit?
  - v Entity to má smysl kvůli tomu, že je třeba zavolat
    instantiateProperties() a to musí mít přímo entita.
    Zároveň by byly všechny Object.create() na jednom místě.
  - Na druhou stranu entitu je třeba proxifikovat a přidat do
    EntityManageru. Ale to by v zásadě asi šlo udělat z toho
    Entity.createInstance(), ne?


TODO:
EntityManager by měl mít metody:
 - createEntity()               // Vyrobí entitu s generovaným id.
 - createClassPrototypeEntity() // Vyrobi entitu kde id = className.

TODO:
Serializable by mělo mít
  public serialize()
  public static deserialize()

TODO: Entita přetíží deserialize()
(respektive něco, co se z něj volá, asi deserializeToJsonObject())
- a to tak, že se bude z jsonObjectu číst 'prototype' a instance
   se bude vyrábět přes Entity.createInstance()
TODO: Entita přetíží serialize()
- a to proto, aby se serializovaly jen own properties.

TODO: Entita má property instanceIds - zapisovat do ní při
  vytvoření a deletu entity.
  (asi jen na Serveru)
Proč jsou to idčka a ne přímo reference?
- v paměti by se to drželo jako reference na entity proxy, respektive
  na invalid entity proxy (pokud to není loadnuté). To by ve výsledku
  asi šetřilo paměť (idčka jsou delší).
- na disku by se to savnulo jako normální reference na entitu. Což by
  teda naopak zabralo místa trochu víc, ale místo na disku není limitující
  faktor.
- EntityProxyHandler v sobě idčko má, i když je entita nevalidní.
Otázka je, jak bych v tom seznamu hledal, když by se chtěla třeba zrušit
instance. 
IMPORTANT TODO: Mazání z a zapisování do instanceIds se musí dělat jen
  na serveru, nikoliv na Clientovi.

TODO: Entita nesmí jít smazat, dokud nemá prázdné 'instanceIds'.



ÚVAHA: Musí si EntityManager držet EntityRecord místo referencí na entity?
- asi nemusí, stačí, když bude EntityProxyHandler odchytávat invalidate(),
  aby šlo zrušit interní referenci.
TODO: Odchytávat v EntityProxyHandleru invalidate()
TODO: Dát do EntityManageru přímo seznam Entit místo EntityRecordů


ÚVAHY k referencím na entity
------------------------------
- chci, aby šly porovnávat reference na entity
  (je otázka, jestli to vůbec půjde - když mám starou, nevalidní referenci,
   tak nebude rovná novější referenci. Porovnání půjde jedině po
   updateReference())

IDEA: Proxyfikaci by možná mohla dělat rovnou Entity.createInstance().
  (Protože proxyfikují se entity)
  - díky tomu nebude muset existovat možnost přidat do EntityManageru
    neproxyfikovanou entitu.
- Tohle by ostatně mělo bejt i jediné místo, kde se entity proxifikují.

---------------------------------------------------------------

IMPORTANT: Dávat idčka hardcoded classám (coby prototypům) je blbost - stejně
  nedávám idčka classám, které se instancují bez prototypování.
- navíc když to chci přejmenovat v kódu, tak to můžu hromadně přejmenovat
  i v save filech (prostě budu vyhledávat 'className: ""' a 'prototype: ""').


TODO: Entity musí mít společného předka v /Shared
(aby se na něj mohly odkazovat shared classy)

TODO: ClassFactory by mohla být v /class

TODO: Raději ještě jednou zvážit defaultní hodnoty statických atributů
  - 'saved' jsem měl defaultně 'true', protože drtivá většina proměnných
    se savuje. Je to tak i u ostatních atributů?
    - 'edited = true' samo o sobě asi nemá smysl, potřebuju další editační
      parametry. Na druhou stranu když se bude uvádět pouze 'edited = false',
      tak u editovatelných proměnných nemusím tohle vůbec psát a rovnou
      můžu uvést editační rozsahy a tak.
- prozatím budu nadále předpokládat, že 'saved' má default 'true', zbytek
  se uvidí.
Závěr: Default musí být u všeho 'true', jinak se nebudou savovat plain
  objecty.

TODO: symbName (a podobně) asi zkrátit na sName, sLocation, apod.

IDEA: Serverové entity pojmenovat ServerEntity (nebo SrvEntity?),
  clientové ClientEntity (ClnEntity?)
- asi by neměly existovat tři classy se jménem 'Entity' - nebo je to fuk?

IDEA: Místo class Saveable udělat class Saver, která dostane
  jako parametr, co má savnout.
- Teoreticky může být pořád class Saveable, která udělá:
  App.getSaver().save(this);
  (App je různá na Serveru a na Clientovi, takže to vyvolá různý kód)

TODO: Možná by bylo lepší udělat singletony (Client, Server) jako static classy
  místo trapčení s getInstance().


TODO: Přejmenvoat Server/Utils na Server/ServerUtils
[done]

TODO: V JsonLoader ve fci readEntityReference() se volá
  App.entityManager.createReference(id);
- Dát do App entityManager.

TODO: Fce JsonLoader.getPrototypeId() není dodělaná a nepoužívá se
  (nevolá se při vytváření instancí entit).

TODO: Opravit loadování Map, Setů a Arrayů
  - nestačí udělat Mapu (nebo set) z Arraye v Jsonu, je třeba nejdřív
  naloadovat prvky toho vnitřního arraye a až pak z něj udělat mapu.

TODO: Ve Funkce typu 'isBitvector' používají stringové názvy dummy typů
  - nahradit symbolickými konstantami

TODO: Při deserializaci nonprimitive properties kontrolovat, že
  - buď má sourceProperty metodu 'deserialize'
  - nebo je to plain javascript Object
  [done]
- pokud je targetProperty 'null' a v JSONu neni className,
  tak se vytvori plain javascript Object (tj. je mozna savnout
  plain Object property a loadnout ji do 'null' value)
- jinak se vytvori instance prislusneho typu.

TODO: Když v JSONU není className, tak budu loadovat do {}
  - zkontrolovat, že nebude vadit, že tam nejsou příslušné properties.

ÚVAHA: Když nějaké existující property nastavím, že se nemá
  savovat/posílat/whatever, tak se sice nebude savovat, ale při loadu se mi
  přepíše - což možná nebudu chtít.
- Aby se tomu dalo zabránit, tak by deserialize() muselo dostávat jako
  parametr metodu, kterou se deserializuje (load ze savu, přijem dat
  z editoru, atd.)
  - zatím to dělat nebudu, ale možná to bude potřeba.

TODO: Kód na savování bitvectoru (číst ho umím, savovat asi ne).
[done]

TODO: Ještě jednou pořádně projít celý serializovací kód (včetně JsonSaveru).
- a vyčistit zbytky ze Serializable

TODO: EntityProxyHandler by měl být v /shared
 (nebo miminálně EntityProxyHandler.INTERNAL_ENTITY_PROPERTY by měla
  být dostupná pro shared classy (konkrétně Serializable))

--------------------------------------------------------------

Jak se loaduje/deserializuje entita:
-------------------------------------

Při loadu z disku:
1) loadne se JSON string
  - Tohle udělá App (tj. Server nebo Client)
    - otázka je jestli přímo, tj. App.loadFromFile(), nebo přes nějakej saver.
    Na serveru:
      await FileSystem.readFile(path)
2) vyrobí se z něj JSON object
   - 
   Serializable.parseJsonString()
3) Přečte se z něj prototypeId (nebo jiná identifikace prototype objectu)
   -
   readPrototypeId()
4) Vyrobí se instance přes Object.create()
   - to by měla dělat ClassFactory
   ClassFactory.createInstance()
   {
     prototypeObject = ...
     return Object.create(prototypeObject);
   }
5) Na instanci se zavolá instance.loadFromJSONString()

Při deserializaci z packetu:
1) receivne se JSON string
2) vyrobí se z něj JSON object
3) Přečte se z něj prototypeId (nebo jiná identifikace prototype objectu)
4) Vyrobí se instance přes Object.create() - to by měla dělat ClassFactory
5) Na instanci se zavolá instance.loadFromJSONString()

Pozn: Save je jednoduchej, ten rovnou vyplivne JSON string

Public interface by měl vypadat nějak takhle:
-----------------------------------------------

class JsonObject
{
  public static stringify(jsonObject: Object): string;
  public static parse(string): Object;

  public static getPrototypeId(): string;

  + type conversion functions
}

class Serializable
{
  public deserialize(jsonObject: Object);
  public serialize(): string;
}

class Saveable
{
  public save();
  public load();
}

Pozn: Mít volně dostupnou metodu deserialize() znamená, že
  půjde ze skriptu nastavit libovolné entitě úplně cokoliv
  - a je vcelku jedno, jestli bude public nebo ne, to hraje
    roli jen v compile time


TODO: Flags savují bitvector jako Array čísel
- přesunout to do JsonSaveru k ostatním podobným typům.

--------------------------------------------------------------

Zajímavá class-design idea:
----------------------------

Keybind bude dělat různé věci podle toho, jaké má zrovna char nasbírané
special resourcy - když firové, bude dávat damage do fire, atd.

Půjde to i kombinovat, takže třeba 2x fire + death udělá ohnivou dotku...

=> Hráči nebudou vůbec omezeni žádným buildem. Můžou zahrát úplně cokoliv
kombinací několika keybindů (pár různých builderů)

- co budou dělat základní buildery (a tedy i následní skilly) by asi mohla
  určovat wilednutá zbraň (a tu samozřejmě jde podle potřeby rearmnout).
  - ohnivá rána mečem vyrobí fire resource a následně se z toho odpálí
    ohnivá dotka na melee.
  - ohnivý výstřel z luku vyrobí fire resouce a následně se z toho odpálí
    incendiary arrow
    ... atd.

=> Můžeš v boji dělat úplně cokoliv podle potřeby a podle toho, co se naučíš
  mačkat (hrát).

Folsové:
 - castnutí folsů sníží přímou damage charu podle počtu folsů a jejich síly.
   Podle toho, kolik folsů si char castne, bude tudíž zrovna fols-oriented.
   (A když mu pomřou, tak se mu automaticky vrátí direct power).

--------------------------------------------------------------

TODO: Na klientu se nevytváří App

TODO: Přejmenovat Server na ServerApp a Client na ClientApp
[done]

TODO: SaveableObject rozdělit na:
- Serializable (přesunout do /shared)
- Saveable (nechat v /server)

TODO: Dynamické classy registrovat v modulech místo centrálně
- Zrušit DynamicClasses.ts
- Založit místo toho ClassFactory (bude asi v App)
-- tohle musím vyzkoušet - funguje
[progress]: ClassFactory funguje, je to statická classa
  (protože se do ní zapisuje při launchi).
TODO: Výhledově by ale neměla pole s konstruktory dávat ven,
  měla by ho processit sama.
  (Možná přesunout kód z PrototypeManageru do ClassFactory? Uvidíme..)
TODO: Zrušit zmínku o DynamicClasses ze SaveableObjectu
  (respektive ji přepsat na ClassFactory).


TODO: Client i Server by měli mít každý svůj vlastní EntityManager.

----------------------------------------------------------------------------

TODO: MessageType by šlo přece jen vrátit do Modulu Message
- Může nejspíš současně existovat class Message (v server/Message.ts)
  a modul Message (v shared/Message.ts)

TODO: loadPropertyFromJSONObject() a podobne funkce v Serializable přejmenovat
  prostě na loadProperty()
- po oddělení Saveable je jasné, kam se savuje

TODO: Sjednotit výpis 'path' do error hlášek.
[done]

IDEA: IndirectValue přejmenovat na SaveHelper (nebo lépe SerializeHelper).

IMPORTANT TODO: v Serializable.createNewIfNull() se nesmí objekt vytvářet podle
  className, ale podle prototypeId.
  (className slouží pouze pro kontrolu a aby byly JSON soubory čitelnější)
Respektive asi pouze při loadu/savu na disk. Klient idčka nezná, takže
tomu asi budou muset stačit className...
(Možná to je ale tak, že prototypeIdčka se používají pouze pro entity.
 Jen nevím, jestli mi to pomůže - entity se taky budou posílat na clienta)

Tohle je vůbec dost fundamentální problém - abych mohl na klientovi
recreatnout entitu, musím tam mít ancestor entity (celý chain).

Šlo by to asi vyřešit tak, že bych při připojení poslal klientovi idčka
hardcoded entity a ClassFactory na klientovi by si z nich vyrobila vlastní
prototypy.
  Nebo druhá možnost, pokaždé poslat celý chain (hardcoded prototype entita
na klientovi ale bude jiná než na serveru...).
 - ok, ale nemusím posílat to, co už na klientovi je.
Tohle je lepší varianta, posílat to on-demand je robustnější.

Problém: Tohle pořád neřeší hardcoded prototypy, leda že bych s nima
posílal i className
- tj. když klient nenajde objekt s příslušným idčkem, vyrobí nový podle
  className (musí to být className na klientu).
- tohle je asi ok, protože jména hardcoded class se za běhu klienta nebudou
  měnit (kdyby došlo k dynamické změně, tak se prostě reloadne celý klient).

====================================
ŘEŠENÍ:
- Objekty na serveru si budou pamatovat, jestli jsou už poslané na clienta.
- Kdykoliv budu posílat jakýkoliv objekt na klienta, projdu celý prototype
  chain a pošlu současně všechny předky, které nejsou ještě flagnuté 'onClient'
- když na klienta dojde požadavek na vytvoření objektu, pro který ještě klient
  nemá idčko, tak vyrobí prototype object podle className (musí to být jméno
  classy na klientovi, ofc).
====================================

Související poznámka: Když se na serveru změní nějaký prototyp, na klienta
stačí poslat jen ten jeden konkrétní prototyp.




...(opět si připomínám, že PrototypeManager a ClassFactory by asi mělo být jedno
 a to samé... Tj. přejmenovat PrototypeManager na ClassFactory)



TODO: V Serializable.readProperty parametry sloučit do jednoho objektu,
  takže pak půjde psát:

  if (result = this.loadAsDate(param))
    return result;

----------------------------------------------------------------------------

Poznámky ke konverzi na Serializable:

- prototypový object se do JSONU ukládá jako 'prototypeId',
  tedy přímo jako idčko entity (a tuším, že klidně i neentity,
  všem potenciálně dynamickým classám se prostě přiřadí idčko).

- je otázka, jestli na něco potřebuju className
  - asi se to hodí pro lepší čitelnost souboru, když nic jiného...
- u "indirect" class se navíc tuším podle virtuálního 'className'
  pozná, jaký objekt se má vytvořit (třeba 'Set' nebo 'Map').


----------------------------------------------------------------------------

ÚVAHA (jména statických atributů):

- saved
- edited
- sentToClient
- sentToServer

----------------------------------------------------------------------------

ÚVAHA: Perith's notes
- aneb jeden hráč sebere item podstatný ke questu (nebo prostě nějaký podstatný
  hint v zóně).
   Bez zone resetu nebo server rebootu (a tudíž duplikace itemů) mají ostatní
  hráči smůlu.
Řešení: Magie umožňující koukat do minulosti. Char s nahozeným past-sightem
  uvidí "obrazy" itemů, které někdo sebral (ne všeho smetí, jen patřičně
  oflagovaných itemů). Dalším kouzlem si bude schopen vytvořit "éterický"
  duplikát.
  - tj. stále bude docházet k duplikaci důležitých itemů, ale bude to fikčně
    dávat smysl a půjde na první pohled poznat, že jde o duplikát (může se s
    tím i hůř manipulovat - třeba to nemusí jít tradovat).

ÚVAHA: Entity proxy
- proxy nejspíš nehlídá přístup dovnitř Object (tedy nonprimitive) properties
  entity (na druhou stranu pokud si na ně někdo nedrží přímou referenci, tak
   se k nim dostane jen přes properties, které proxy hlídá)
  - tohle by mohlo vadit, kdybych chtěl přes proxy updatovat timestamp při
    každé změněentity

ÚVAHA: Online editace roomy
- Nejlepší řešení asi budou timestampy. Client bude mít u svých entit
  timestamp, kdy si je vyžádal. Entity budou mít timestamp poslední změny.
    Client nikdy nezobrazuje všechny roomy najednou, vždycky jen nějakej
  výřez. Entity v tomhle výřezu by se asi měly updatovat hned, o update
  mimo výřez si klient řekne ve chvíli, kdy tam user doscrolluje (v žádosti
  stačí poslat idčka entity a jejich timestampy, což může být jeden packet
  - server to porovná s poslední změnou a pošle update jen těch změněných)
- Tohle asi není nutné řešit prioritně. Přinejhorším bude prostě klient
  zobrazovat outdated info, no big deal (vadilo by to jen při konkurenční
  editaci a i tam by to asi prošlo - prostě by si jen buildeři vzájemně
  přepisovali změny).
=========>
Tak ne, kašlat na timestampy.
- Na servetu se u každé connecion bude držet aktuální výřez mapy, na který
  se klient kouká (tedy výřez, na který se klient naposledy ptal). To je
  jen dvojice coords (dva rohy), takže zanedbatelná paměťová náročnost.
- Při editaci roomu se změna pošle všem klientům, kteří ji mají v aktuálním
  výřezu.

----------------------------------------------------------------------------

IDEA (provázání protokolu a server classy):

V /shared bude deklarace protokolu, např:
class Room
{
  description: string = "";
}

v /server bude interface extendnuty z /shared/Room, ktery bude nasledne
implementovat serverova classa:

import {SharedRoom} from '/shared/Room';

interface IRoom extends SharedRoom {}

class Room extends GameEntity implements IRoom
{
  description: string = "";
}

K čemu je to dobré?
- sice budu muset duplikovat kód, ale tenhle trik mi zkontroluje,
  že /server/Room má stejné membery jako /shared/Room



TODO: Zkusit pořešit:
- /Shared/App, Server/ServerApp, Client/ClientApp
  s tím, že Server a Client si při vytvoří příslušnou Applikaci
  (a /Shared/App bude abstraktní class)
- ERROR() zavolá konkrétní logování přes App.
- CommandProcessor musí být externí class
  (Je třeba pořešit registrování příkazů na konkrétní instance
   - ideálně jen na serveru.)
- Nějak se musí určovat, jaká classa se má vyrobit na druhé straně.
  ClassName na serveru totiž bude jméno nějakého prototypu (třeba GreyOrc),
  zatímco odpovídající ClassName na clientu bude nejspíš Mob
  (A není to jen problém prototypů, na serveru může být z Moba něco zděděného
   i v trvrdém kódu).

IDEA: Pojmenování:
/server/Server.ts (místo BrutusNextServer.ts)
/server/lib/ServerApp.ts (místo Server.ts, protože to bude zděděné
  ze /shared/lib/App.ts).


TODO: Array3d by se mohlo jmenovat spíš Grid3d nebo RoomGrid.

----------------------------------------------------------------------------

IDEA: Názvy adresářů (/shared a tak) dát CamelCasem
- umožní to víceslovné názvy bez podtržítek

TODO: SaveableObject rozdělit na:
- Serializable
- Saveable

TODO: Classu connection rozdělit (respektive z ní zdědit):
  TelnetConnection a WebSocketConnection
  - důvod: Různé vnitřní stavy.

----------------------------------------------------------------------------

Úvahy o architektuře aplikace:
-------------------------------

Při posílání mezi klientem a serverem potřebuju statické atributy
jen při odesílání. Z toho plyne, že by šlo mít:

- Ve /Shared pouze interface
- Z něj zděděnou classu na serveru a classu na clientu
  (každou zděděnou ze Serializable)
- v classe na serveru by byly statické atributy pro odesílání dat na clienta
- v classe na klientu by byly statické atributy pro odesílání dat na server

Co v případě editoru? Tam bych to potřeboval na jednom místě...
- teoreticky ne, pokud se v editoru bude s editovanými objekty pracovat
  obecně (jako s Object, respektive teda Serializable) a posílat zpět
  se bude všechno, co obsahují.

Tohle by znamenalo:
- serializační metoda by měla dostávat parametr:
  'saved'
  'sendToClient'
  'sendToServer'
  'all'
  - s tím, že 'all' prostě serializuje všechno bez ohledu na statické atributy.
    (Použije se to při odesílání zeditovaného objektu zpět na server.)

-----------------

Další úvahy:
- protokolem se posílají entity
- klient i server by měly mít vlastní EntityManager (tedy vlastní instanci).


-------------------------

Alternativně by šlo neposílat entity, ale pouze jejich datovou část.
Tj.by bylo:

Shared:

class Shared/RoomData extends Serializable
{
  description: string;
}

Client:

class Client/Room extends ClientEntity
{
  data: RoomData;
}

Server:

class Server/Room extends GameEntity
{
  data: RoomData;

  processCommand()
  {
    // zděděno z CommandInterpretteru.
  }
}

----------------------------------------------------------------------------

DESIGN: Úvahy o class specech:
===============================

Species hierarchy:
-------------------

class Mob
{
  description = 'Generic mob';
}

class Orc extends Mob
{
  description = 'Humanoid with big fangs.';
}

// Tohle je problém - rozbočka ve stromu dědičnosti.
class OrcShaman extends Orc
{
  ...
}

class GreyOrc extends Orc
{
  description = 'Grey-skinned humanoid with big fangs.';

  fightSpec = unarmedHumanoidFightSpec;
}

class GreyOrcShaman
{
  // Respektive přes equipment slot - princip je stejný.
  apparel = 'Dressed in shaggy robes.';

  fightSpec = shaman;

  builderSpell = 'Fell Bolt';
  comboSpell = 'Fell Blast';
}

class GreyOrcSlayer
{
  apparel = 'Dressed in shaggy armour.';
}


Adventuring class hierarchy:
---------------------------

class Adventurer
{
  doAction() {}
}

class Sorcerer extends Adventurer
{
  doAction()
  {
    castSpell();
  }

  castSpell() {}
}

class OrcishSorcerer extends Sorcerer
{
  castSpell() // ~ Overrides Sorcerer.castSpell();
  {
    cast('Fell Blast');
  }
}


Co chci, aby fungovalo:
-------------------------

- Mob se převlékne do jiných hadrů (maskování by mělo zahrnovat i jméno a tak).

- Mob si iluzí změní name a description (ale zůstanou mu bojové staty a tak).

- Mob se shape-changne do jiného tvora
  (získá tím úplně všechno od vzhledu po combat staty)
- Mob přezbrojí nebo změní classu (playerský multiclass)

- Mob se jinak chová v boji, jinak mimo boj, jinak ve speciálních situacích
  (svatba, slavnost ve vesnici).


Rozbor řešení:

- Fight specy by měly pracovat na objektu, který má příslušné resources
  (když castím za holy power, musím mít holy power).

- Asi bych fakt měl mít jednotlivé pluginy (specy), tj. můžu vyměnit třeba
  svůj combat spec (z OrcShaman na Crocodile, protože jsem se shapeshiftnul).

- Pluginy by měly mít prioritu (možná různou v různých situacích).
  (Když jsem v boji, combat plugin nahrazuje všechny ostatní. Když je slavnost,
   přepnu se z 'ordinary life' na 'celebration');

Jsou v zásadě dvě možnosti, jak k tomu přistoupit:
1) předek (asi mob) bude mít hromadu funkcí s jednotlivými variantami, nejspíš
  v obecné formě (tj. cast('combat spell 1') a co je 'combat spell 1' si mohou
  potomci přetížit).
  - v proměnné by pak měl nastavenou tu metodu, která se zrovna má používat
  Nevýhoda: Veškerá funkcionalita by musela být hodně vysoko v hierarchii.
  (Tudíž by se to asi nedalo rozumně skriptovat.)
2) pluginy budou typescriptové classy
  - pak bude ale třeba pořešit komunikaci mezi pluginem a entitou, která
    ho používá.
    - některé properties mohou mít pluginy v sobě (třeba holy power v combat
      pluginu paladina), na jiné ale asi budou muset hrabat přes public
      properties moba, který je vlastní.
    - každý plugin je stavový automat (drží si v sobě interní stav).


ZÁVĚR:
- Nakonec použiju metodu vložených dat:

Server entity   Client entity
        \         /
         \       /
          \     /
        Entity data

- Někde se musí do JSON packetu zapsat jméno entity classy,
  která se má vytvořit na klientu.
  - buď při konstrukci packetu
  - nebo to může bejt zadrátované někde uvnitř...
    (třeba ve formě statické proměnné, která řekne, jaká classa
     téhle classe odpovídá na druhé straně protocolu)

- Všechny tři tyhle stromy (strom serverových entit, clientových entit
  a datových částí) by měly mít stejnou adresářovou strukturu:
  /client/game/...
  /server/game/...
  /shared/game/...

  Tj. např:
  /client/game/world/Room.ts
  /server/game/world/Room.ts
  /shared/game/world/RoomData.ts

  (class na serveru a clientovi se bude jmenovat stejně, snad to nebude moc
   mást. Konec konců, přejmenovat to jde vždycky...)


Další úvahy o behaviour specech:
---------------------------------
- měly by to být entity, aby šly prototypově dědit a snadno editovat
  (a měly by být skriptovatelné).
- měly by obsahovat i data
  - například fight spec 'orc shaman' by měl mít nasetované i spelly, které
    ten shaman bude castit. Když ho pak přidělím orkovi, tak ten tím
    rovnou dostane všechny potřebné ability.
  - jake má mob skilly se zjisti sjednocenim skillu ze všech action speců,
    které má přiřazené (aby to bylo stejně jako u playera, který může znát
    úplně všechny skilly ale najednou používá jen část z nich).


DESIGN: Úvahy Expech:
======================

Každá zóna bude mít pevně daný počet expů, které z ní lze získat
  a k němu se bude gain asymptoticky blížit.
- díky tomu nebude hrát roli, kdo nastaví víc expové moby, časem se to
  vždycky srovná (a současně to mohou být globální expy).

Implementace: Každý char bude mít exp counter pro každou zónu, ten se
  vždycky prožene asymptotickou fcí a součet výsledků ze všech zón jsou
  playerovy current xp (asi by bylo dobré počítat utracené xp v samostatném
  counteru, neodečítat je přímo).


----------------------------------------------------------------------------

TODO: Mapper.

TODO pro dnešek:
- posílat commandy jako packety
- parsovat commandy na serveru
- parsovat EDITOR_CREATE_ROOM a opravdu založit roomu
- poslat zpět klientovi MAP_INFO roomy

TODO: Parsování protokolu v klientu (WebsocketDescriptor.onReceiveMessage())
 je třeba předělat - hrabu do dat naslepo (bez classy nebo interfacu), to
 rozhodně není dobře.

IDEA: Teoreticky by šlo do serverových class dát XxxData jako vložený
  objekt. Sice to nebude moct bejt SaveableObject, ale může to bejt
  zděděné ze SerializableObjectu, což umožní naučit SaveableObject
  savovat properties těchto typů.
- tohle má smysl dělat jen pokud by se tam a zpět posílal velkej kus
  properties nějaké classy.


TODO: Zrušit flagu Exists na RoomData
- RoomData bude plain object (byť s interfacem) a RoomRenderData
  bude na něj mít odkaz - tudíž ten odkaz může být null, když room
  neexistuje.

TODO: vymyslet, kam s metodama z RoomData.
-- asi zavést abstraktní classu, ze které bude dědit RoomRenderData
  (a nechat ji v /shared - možná /shared/game).

IDEA: Možná pojmenovávat interfacy INěco. Pak by mohl být IRoom (nebo RoomInterface)
- asi spíš ne

K čemu vlastně potřebuju classu PacketData?
- k ničemu?
- aha, kvůli dědění. Což je ale možná zbytečný.

IDEA: SaveableObject rozdělit na:
SerializableObject
- load/save to json
SaveableObject extends SerializableObject
- load/save to file


TODO: websockets over http server.
[done]

TODO: Zabalit mud messages do protokolu.

TODO: Založení roomy.

Prozatímní plán:
----------------
Editor bude čistě abstraktní
  (EditableObject bude strukturu vytvářet, Editor (v klientu) ji bude
   opracovávat)
- klient si bude držet rollback ve formě stavů editovatelných objektů
  (tzn. budu potřebovat umět takovej objekt naklonovat)
  Undu prostě pošle na server původní stav (nebude undo na serveru).
- commit editu pošla data na server
- server pošle update grafických dat dle svého uvážení

Komunikační protocol zatím nechám, jak je
- protocol definují classy ve shared/protocol
- server vždycky udělá něco jako new RoomData() a properties nasetuje
  ručně (nebo možná automaticky podle toho, co je označeno jako 'send = true')



IDEA:
Protokolové classy (např. RoomData) by asi měly být SaveableObjecty
- při odesílání se savnou do JSONu, při přijímání se loadnou z JSONu.

IDEA:
Když dám statické properties editovatelných objektů do /shared,
tak je nebudu muset posílat ručně.
- na druhou stranu v /shared nechci mít celý server-side kód,
  takže by tam musel být jen interface a ten asi nemůže mít statické
  properties. Nebo předek (classa), což je ale taky problém, protože
  nemám vícenásobnou dědičnost.
Takže to asi bude muset fungovat následovně:
- Serverová classa (třeba Character) je zděděná z EditableObject.
- Má nějaké statické properties, které popisují její nestatické properties
  (co se dá editovat, jaké to má rozsahy a tak).
- EditableObject musí umět vygenerovat JSON s těmito statickými parametry
  a poslat ho klientu (to by se mělo dělat při startu stránky - nebo možná
  až když chce user něco editovat, ať se to nedrží zbytečně).
- klient to buď musí zpsat do statických properties příslušné editovatelné
  klientské classy, nebo z toho číst nějak nepřímo.
Hmm, to možná znamená, že celá idea protokolových class je špatně...

class EditableObject extends SaveableObject
{
}

class Entity extends EditableObject
{
  public id: string;
}

class Room extends Entity
{
  public name: string;
  private static name = { editable: true; maxLength: 20; };
}

// Tohle vytvoří metoda getFormatJson() zděděná z EditableObjectu.
FORMAT JSON:
{
  className: 'Room',
  properties:
  {
    name:
    {
      type: 'string',
      maxLength: 20
    }
  }
}

// Tohle vytvoří metoda saveToJson() zděděná ze SaveableObjectu.
DATA JSON:
{
  className: 'Room',
  name: 'Market Square'
}

--------

client class RoomData extends SaveableObject
{
  public name: string;
}
// Je to SaveableObject, takže se umí načíst z JSONu
// - není ovšem zaručeno, že bude mít příslušné properties
//   (kromě toho ne všechny properties Roomu budu chtít posílat
//    klientovi - a taky asi jak kdy, v edit módu budu chtít
//    posílat jiné properties než v play módu)

- Chci asi pokud možno rovnou editovat RoomRenderData
  Nebo nechci?
  - chci mít undo buffer, tzn. změny musí být prováděny formou transakcí
    (i kdyby transakce nebyla rozdílová, ale prostě "použij tyto hodnoty").
  - a chci je nejdřív potvrzovat na serveru.
    Tzn. v edit boxu něco přepíšu, na server se odešle požadavek,
    vrátí se ano/ne.
    - Buď musím s dalším editováním čekat, dokud mi nepřijde odpověď,
    - Nebo to musí být reverznutelná transakce.
Asi bude lepší vždycky čekat na potvrzení ze serveru a až pak upravit
render data.

Možná by se to dalo celé zjednodušit tak, že mezi editorem a render datama
nebude žádná vazba.
- Tj. když chci editovat třeba room, tak si řeknu servevu o jeho edit data
  (dostanu šablonu + rozsahy + aktuální hodnoty, celé jako jeden JSON)
  Na tohle nepotřebuju vlastní classy, budu to prostě editovat jako abstraktní
  hodnoty.
- Na konci odešlu změny na server. Ten je zpracuje a pokud uzná za vhodné, tak
  mi pošla updatnutá data, za kterých si klient updatne své render data.

Tohle by znamenalo, že rollback musí umět server - to možná není úplně šikovné.
(i když možná ne, klient může při rollbacku prostě poslat serveru původní stav)
- 

--------

TODO: Dát roomám (jejich svg elementům) DOM idčka.

TODO: Server musí klientu dát vědět, kde jsou rozsahy zón - nesmí jít
  editovat roomy mimo prostor vymezený založenými zónami.
- client by se asi měl nejdřív serveru zeptat, jaké roomy už existují
  a případné díry pak inicializovat roomou s .exists = false.
Tohle znamená, že v edit módu bude jinak fungovat komunikace se serverem
- klient se nebude ptát jen na zmapované roomy, ale na to, jestli roomy vůbec
  existujou.

TODO: V clientu mě nemusí zajímat, že jsou exity přesměrované (nw na nwu),
o to se stará server. V RoomData je prostě exit na nwu a ten budu renderovat.
- musím nějak rozlišovat 'ground' (solid) exity a 'floating' exity (in-water,
  případně in-air). Ale asi ne nutně hned, zatím můžu předpokládat, že
  všechny exity jsou solid.
- v solid exitech platí, že v horizontálním směru může být vždy jen jeden
  exit - tj. buď je jen na n, nebo jen na nu, nebo jen na nd.
  (To bude podstatné při editování.)

TODO: RoomRenderData a ExitRenderData asi buď zrušit,
nebo aspoň sloučit do jedné classy (RenderData<T>).

TODO: Rozlišovat Exit (info o tom, že z roomy vede exit do nějakého
  směru nebo teleport někam jinam) a Connector (vlastnosti propojení
  dvou room).
  Exity by se měly odkazovat na příslušné Connectory.
=> Na clientu se renderují ConnectorData, nikoliv ExitData

TODO: Interně používat jednopísmenné zkratky exitů ('nwu' apod.)

TODO: Na detekci zoomu v browseru možná půjde použít tohle:
https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
/*
  $(window).on
  (
    'zoom',
    function()
    {
      console.log('zoom', window.devicePixelRatio);
    }
  );
*/

IDEA: Změny souřadnic standardními exity by mohla umět počítat
classa Coords (nebo Exit).
- taky je otázka, jestli by exity neměly být spíš enum než stringy...

TODO: Zrušit kosoúhlé promítání.
[done]

NOTE: Teleort by asi neměl mít destination danou souřadnicema...
  I když možná raději jo, protože ty povedou vždycky do správné instance,
  zatímco entityId cílového roomu by mohlo vést do jiné instance.


TODO: RoomData a ExitData by asi měly být client-side classy
  a dědit (implementovat) z příslušných interfaců v /shared
  (asi RoomInterface a ExitInterface).
- I klient totiž do nich něco přidává (konkrétně klient-side idčko)
  a server určitě bude taky.

ÚVAHA:
- Data budou držena v poli (respektive v "poli" implementovaném hashmapami).
- ve visibleData budou odkazy do toho master (world) pole.
Asi bude potřeba, aby si klient uměl od serveru vyžádat map data pro konkrétní
roomy (pro ty, které se zrovna snaží zobrazit).

TODO: Otestovat grafiku pro exity up, down a šikmo nahoru/dolů.
  (pokud není vidět horní nebo dolní patro, tak by se šikmé exity
   měly kreslit jen poloviční).

TODO: Drop-shadow u map elementů úplně nefunguje.
  - buď to spravit, nebo zrušit a vyhodit.
  http://bl.ocks.org/cpbotha/5200394
- Tohle by bylo ještě hezčí:
  https://www.w3.org/TR/SVG/filters.html#AnExample

TODO: Jestli je exit ONE_WAY nebo TWO_WAY se musí posílat už
  ze serveru. Mapper to nemá jak zjistit, dokud hráč nezmapuje
  cílovou roomu.

TODO:
- Při přidávání roomy rovnou přidat i všechny roomy, do kterých
  z ní vedou exity (marknout je jako unexplored).
- jednosměrné exity zapisovat do cílových room
  (asi do objektu 'entrances');
  - a to proto, aby jim ta rooma mohla updatnout grafiku, když se změní.
Hmm. Aby mohl mapper vykreslit exit do neprozkoumané roomy, tak musí znát
  její koordináty. Možnosti jsou:
- zapisovat koorináty cílové roomy do exitu (to povede k duplikaci dat)
- Flagovat nějak roomy, které jsou 'peeked in' but not 'explored' a posílat
  je taky.
A nebo cheap solution: Prostě exit do neprozkoumané roomy jen naznačit krátkou
čárkou.
- to asi použiju, je to teď nejjednodušší.
Otázka ale je, jestli to řeší problém s tím, že mi vede one-way exit zejména
zmapované roomy do roomy, kterou edituju: Neřeší.
...
Čili asi takhle:
- Nezmapovaná rooma, do které vede exit ze zmapovené roomy,
  se v mapperu vytvoří, ale bude mít prázdné koordináty.
- Exit se vyrenderuje jako krátká čárka zhruba daným směrem (nevíme ještě kam).
  (Hmm, to je asi blbý - když povede do kopce nebo s kopce, tak to bude poznat).
...
Hmm tak asi fakt nejjednodušší bude posílat cílové koordináty rovnou
s exitem.

TODO: Zrušit parametry 'i'.
[done]

Jak na mapu
------------------

- Discworld MUD style
  + exity šikmo vzhůru/dolů ('northwestup', etc).
    (takový exit by měl mít šipečku uprostřed, nebo
     se možná celý zužovat směrem nahoru - protáhlý trojúhelník).
- Všechny roomy na pevných intových souřadnicích.
- Exit jde vždycky na sousední roomu. Na vzdálenější to musí být
  teleport.

- exity do vodorovných směrů mohou být "přetížené" do směru šikmo
  nahoru nebo dolů (takže dám 'north', a hodí mě to třeba na 'northup'
  (samozřejmě jen na pevné zemi).

- Roomy nad aktuálně zobrazovaným patrem se nezobrazují
- Roomy pod ním se zobrazují, pokud není žádná "pevná"
  rooma nad nima (tj. air nebo water), ale asi hodně transparentně,
  aby se to nepletlo.

- létání ve výšce asi bude stejně jako v ufech - prostě si přepnu
  pohled do určitého patra a kurzor mi jezdí v něm).
  (se shiftem nebo tak něčím by to mohlo "snapovat" na ground,
   aby se dalo snadno "přistát" bez nutnosti šaškovat s patry).

Implementace:
- V klientovi budu určitě potřebovat grid
- neexistující roomy mohou mít hodnotu 'null' nebo
  'undefined'
  (spíš 'null', ať se to neplete s děravým polem)
- respektive 'null' přímo v poli asi ne, protože
  u roomy potřebuju znát koordináty, i když neexistuje
  (dokonce ji chci při editování i vykreslovat - sice,
   neviditelnou (nebo skoro průhlednou) ale mouseover
   ji zviditelní).
Důvod: Chci mít možnost roomy editovat přímo v editoru.

Exity nahoru a dolů
- graficky svislá šipka vlevo (dolů) nebo vpravo (nahoru)
  od roomy.
  (a to proto, aby rooma samotná mohla mít ikonku)

Transformace koordináty->pole
(nemůžu mít v javascriptu náhodou záporný souřadnice?)
- použiju hashmapy
  (pole se zápornými souřadnicemi sice může existovat,
   ale nefungují pak dobře Array metody).
- respektive by to asi mohla být classa, aby se dalo
  inteligentně indexovat metodama: grid.get(12, 13, 0).

Vzduch:
- exity (ani roomy) se nevykreslují. Letět se dá prostě
  všude, kde není pevná překážka.
- totéž pod vodou.

Na serveru:
- roomy mají koordináty v rámci zóny, zóna má transformační
  koordináty (aby se dalo se zónou snadno hejbat).
- svět by asi ideálně měl být rozdělený na kvádroidní sektory
  (tj. zóna o rozměrech 133x217x9 nebude moci existovat, vždycky
   to budou násobky rozměru kvádru).
- zone connection pointy nedávají smysl, zóny na sebe navazují celou
  plochou (a navazují prostě podle souřadnic).

- exity musí mít taky terrain (stejně jako roomy).
  (asi by si ho mohly defaultně brát z roomy s tím, že tam budou
   nějaké priority - např. 'road' má vyšší prioritu než 'field').
  - možná by to mohlo bejt podle toho, jaké roomy to spojuje.
    Tj. exit mezi dvěma 'road' roomama bude taky road.

U obyčejných exitů nemusím posílat targetRoomId - to potřebuju jen
u teleportů.
- díky tomu nebudu muset 'předrátovávat' exity, když zónu přesunu
  někam jinam (prostě se budou indexovat jiné roomy);
Co teda u exitů potřebuju?
- jestli tam vůbec je (na to by se asi hodily flagy).
- testli je přesměrovaný na šikmo nahoru/dolů (to se týká jen vodorovných).
- terén (tj. barva na mapě). To se sice bude odvozovat z terénu místností,
  ale měla by existovat možnost to přetížit.
  (na terén zatím můžu kašlat).

PS: Že je exit do nezmapované roomy jednosměrný asi client nepotřebuje
vědět - dokonce by ani neměl, protože by si to mohl někdo debuggerem přečíst.
- prostě se bude zobrazovat jako obousměrný.

---------------------------------------------------------------

TODO: Plné koordináty roomy budou mít 4 souřadnice:
[x, y, z, instance_id].
- Client tu poslední nepotřebuje.


---------------------------------------------------------------

TODO (výhledově): Seasonal popisky.
  (jak rooma vypadá v různých obdobích (jaro/léto/podzim/zima).

---------------------------------------------------------------

TODO: Struktura src:

/src
  /client
    /lib
      Client.ts
    ClientSettings.ts
    BrutusMudClient.ts
    tsconfig.json
  /server
    /game
    /lib
      Server.ts
    ServerSettings.ts
    BrutusMudServer.ts
    tsconfig.json

TODO: Předělat i strukturu buildu:

/build
  /client
    /js
  /server
    /js
    /data

---------------------------------------------------------------

TODO: Ha, možná nebude potřeba requirejs!
(viz import Window v Map.ts)
- tak asi bude, browsery neumej ES6 moduly :\

TODO: Array.push() může jako parametr dostat array.
- někde v MudColorComponent merguju pole po jednom prvku
  (nebo už ne?).

---------------------------------------------------------------
TOFIX: Dokud nevytimeoutuje pokus o connect, tak by se neměl
  pouštět reconnect (vede to k pokusu odstranit event listenery
  z null variable).
- Asi by to chtělo místo boolu 'open' mít tři stavy:
  CONNECTING (to je default, protože nově vytvořený socket se snaží connectit)
  OPEN
  CLOSED
- Tak ne, tyhle stavy už jsou uvnitř socketu (socket.readyState). Takže
  je prostě využít, netřeba to trackovat ještě jednou.
Hmm, tak možná stejně něco budu muset trackovat, protože takhle nepoznám,
co se se socketem děje.
- Tak ne, přece jsem se musel vrátit k falze.
TODO: Ještě to chce zkontrolovat, jestli ten readyState necheckuju úplně
  zbytečně.
- a odstranit logovací hlášky.

TODO: Ctrl (a ostatní řídící klávesy) by neměl focusovat input
  (bere to pak focus při vykopírovávání textu)
[done]

TODO: Při quitu se na serveru korektně nezavře connection
  (další log-in to chápe jako reconnect).

TODO: Prozkoumat, co se stane, když:
- hráč zabije záložku v browseru
- spadne server
- přeruší se připojení k netu

TODO: Pokud je connection down, tak by libovolny prikaz od klienta (i prazdny)
mel vyvolat pokus o reconnect.
[done]

TODO: V klientu (a možná i na serveru) přidat flagu, zda je socket
  otevřený - a neposílat data, pokud není.
[v clientu done]

NOTE: Test, zda je uživatel online:
  if (navigator.onLine)
  {
    alert("You are Online");
  }
  else
  {
    alert("You are Offline");
  }
(Tohle se asi bude hodit k automatickému reconnectu).

NOTE: Korektní zavírání websocketu při zavření nebo reloadu stránky:
  window.onbeforeunload = function() {
      websocket.onclose = function () {}; // disable onclose handler first
      websocket.close()
  };

NOTE: url se dá číst z websocketu přes:
  socket.upgradeReq.url
  respektive: const location = url.parse(socket.upgradeReq.url, true);
  // To první je prostě string, to druhé vytvoří 'url' object

Co by měl mít socketDescriptor:
.ipAddress
.connection
.closeSocket()
.socketClosed
.send(message)

TODO: Do konstruktoru SocketDescriptoru předávávat ip address místo
socketu.
[done]

.initSocket()?
- potřebuje to abstraktní SocketDescriptor? Asi ne
TODO: přesunout do TelnetSocketDescriptoru

-----

TODO: Výhledově předělat strukturu zdrojáků serveru - /server/server není
  moc dobrý. (a /server/server/Server.ts už vůbec ne ;-))

TODO: TelnetServer by neměl zapisovat do Server.connections.
- mělo by to být tak, že createConnection() (možná createTelnetConnection())
  by měla být funkce Serveru měla by udělat:
    this.connections.add(telnetServer.createConnection()).

TODO: Websocket client by mohl umět vytvořit a otevřít connection.
  (A mohl by si taky pamatovat server port.)

K ÚVAZE: Proč je vlastně Connection zděděná z Entity?
  Je to k něčemu dobré?

TODO:
/*
  Error handling best practices

  // If the WebSocket is closed before the following send is attempted
  ws.send('something');

  // Errors (both immediate and async write errors) can be detected in an optional
  // callback. The callback is also the only way of being notified that data has
  // actually been sent.
  ws.send('something', function ack(error) {
    // If error is not defined, the send has been completed, otherwise the error
    // object will indicate what failed.
  });

  // Immediate errors can also be handled with `try...catch`, but **note** that
  // since sends are inherently asynchronous, socket write failures will *not* be
  // captured when this technique is used.
  try { ws.send('something'); }
  catch (e) { /* handle error */ }
*/

TODO: Auto reconnect:
https://github.com/websockets/ws/wiki/Websocket-client-implementation-for-auto-reconnect


---------

TODO: Telnet server by měl '&&r' naparsovat jako '&' - a nejlépe
  to zobrazit speciální barvou (stejně jako web client).

-----------------------------------------------------------------

TODO: Používat symbolickou konstantu FileSystem.JSON_EXTENSION.

TODO: Přidávání do a odebírání z instanceIds 
  (možná už to je, tak zkontrolovat)

TODO: Při loadu entity z disku zkontrolovat, jestli existuje prototyp
  a když ne, tak ho lodnout.
[Asi done]

TODO: Zrušit EntityManager.createPrototype
[snad done]

/*
TODO: Zajistit, že se bude loadovat ve správném pořadí
  - vždycky musí být loadnutý prototyp dřív, než se z něj bude vyrábět
    instance.
To by mělo zajistit loadování po příslušných vNames hashmapách:
- nejdřív se loadnou globální prototypy (PrototypeManager).
- pak se loadne World, kterej nejdřív loadne entity ve svých vNames
  - a to asi tak, že nejdřív loadne všechny tyhle entity a pak je projde
    znova a zavolá jejich loadVNames().
- pak se dá loadovat World.contents (tj. Realmy) a bude přeskakovat to,
  co už je loadnuté
  (je otázka, jestli vůbec bude existovat něco, co nemá vName (tedy co
   není ve vNames něčeho jiného) - možná ani ne (možná dynamicky generované
   instance).
*/
- Tohle je celý blbost. Pokud si budou entity pamatovat své instance
  (instanceIds), tak to je v zásadě totéž co původní idea descendantIds,
  a tudíž můžu vpohodě všechno loadnout rekurzivně.

NOTE: Instance se od prototypu pozná tak, že má prázdné .instanceIds
- asi bych to měl checkovat například když tomu někdo dává damage
  (protože dávat damage prototypu znamená, že ji dostanou všechny
  instance, které nemají aktuální hpčka jako own property - což by teda měly
  mít všechny, ale co už)


TODO:
  Entity
    .symName (vName, symbolicName?, symNum?)
    .symLocation (vLocation, symbolicLocation?)
    .prototypeId (to už existuje)
    .symNames (vNames?) (hasmapa, vName -> id)
    ///.instanceIds

/*
- asi by chtělo rozlišovat online instance a offline instance.
  Jenže jak na to?
  - problém je, že se asi nemůže savovat, které jsou offline a které
    online, protože po loadu by to téměř učitě nesedělo - do offline
    entity se nebudou updatovat změny v jejích instancích.
    - To je vlastně blbost, prototyp nemůže být offline, když se dělá
      změna v jeho instanci, je to přece prototype object.
  - Jedna možnost je, prostě tu informaci nedržet a v případě dotazu
    holt projít všechna instanceIds a zeptat se EntityManageru, jestli
    jsou online. Je to teda dost drahá operace...
  - Druhá možnost je, dát jim flagu a nesavovat ji, takže po loadu
    bude nastavena na default (false) a s tím, jak se budou instance
    registrovat (což buodou, protože do té doby neexistoval jejich
    prototype object), se překlopí na 'online = true'.
    - flaga mi ale zase nedá rychlý přístup k počtu online instancí,
      musel bych projít seznam a spočítat to.
ZÁVĚR: Zatím to k ničemu nepotřebuju, takže to teď nebudu dělat. Až to
  potřebovat budu, tak budu mít lepší představu, co přesně to má umět.
*/

TODO:
  - Všechny entity, no matter what, savovat do ./data/entities
    (Pro zatím to fungovat bude a je to by far nejjednodušší řešení)
  

TODO:
  - Zušit setAsPrototype

TODO: Globální prototypy (Account, etc.) asi nechat v PrototypeManageru,
  ale možná přejmenovat hasmapu (na globalPrototypes?).

-------------------------------------

Problém:
- některé entity se nemají loadnout při startu mudu - třeba většina
  accountů a player charů.
  - jak to při rekurzivním loadování poznám? Musel bych tu entitu loadnout,
    abych zjistil, že nemá žádné instance (tj. že ji nemám loadovat).
Možné řešení:
TODO:
- neloadovat prototypy "preventivně", ale "on-demand". Tj. dám loadnout
  wolrd a každá entita si zkontroluje, že v je paměti její prototyp a když
  ne, tak si ho loadne (a až pak se loadne sama).

-------------------------------------

"z1"
  - name: "Newbie Zone"
  - ConnectionPoint 0 (The Entrance)
  - TileSet 0
    [
      Tile 0 extends "RoomTile"
        - "cp0" extends "ConnectionPoint"
        - "r0" exends "z1.r0" (respektive idčko)
          - exit do "z1.t0.r1" (respektive do idčka)
        - "r1" exends "z1.r1" (respektive idčko)
          - exit do "z1.t0.r0" (respektive do idčka)
      Tile 1 extends "RoomTile"
        - "cp0" extends "ConnectionPoint"
        - "r0" exends "z1.r0" (respektive idčko)
          - exit do "z1.t0.r1" (respektive do idčka)
        - "r1" exends "z1.r1" (respektive idčko)
          - exit do "z1.t0.r0" (respektive do idčka)
    ]

"r0" extends "Room"
  - name: "The Entrance"
  - popisek
"r1" extends "Room"
  - name: "A Small Room"
  - popisek

Problémy:
- jména prototypů jsou globálně unikátní, takže když udělám prototyp
  "The Entrance", tak už nikdy neudělám stejný.
  - Navíc se bude extrémně blbě hledat, k čemu to vlastně patří. Tj. tenhle
    prototyp by asi měl být zone specific.

=> Čili obecně bych asi měl mít možnost říct, v čem je entita vložena
   ve smyslu designace ("location" roomy je příslušná Tile, virtualLocation
   je třeba zóna).
=> Každá entita v sobě může mít vložené prototypy
   (hashmapa "prototypes" indexovaná jménem prototypu (což může být třeba "0")
   která bude obsahovat idčka (nebo rovnou reference prototypových entit,
   které jsou adresované v rámci této entity).
   - ať už to bude idčko nebo reference, tak asi můžu kašlat na descendantIds
     a rekurzivní loadování - propojí se to až po loadu a když prototyp nebude
     existovat, tak je to prostě chyba.
  - otázka je, co s mobama, objektama a tak - asi se taky budou vkládat do
    worldu/zóny/atd, ale tím se zamíchají mezi sebou (s roomama a tak), což
    možná není úplně dobré.
  - možná používat ty kódy v rámci "jména" prototypu? Tj. "r0" (room),
    z0 (zone), (m0) mob, rlm0 (realm), t0 (tile), atd?

- Propojení (třeba exity) bude vždycky odkazovat přes idčka.
  Takže když napíšu "connect north r12", tak to v .prototypes najde "r12",
  ale do exitu to napíše natvrdo idčko (vlastě to, které si vezme
  z .prototypes).
  - díky tomu nebude vadit, když někdo přejmenuje symbolické jméno
    prototypu v .prototypes - existující vazby budou fungovat dál,
    protože jsou přes idčka.


To znamená, že prototypy nebudou mít "jméno", podle kterého by šly globálně
identifikovat, tj. nebude se jako jméno používat "className".
- budu mít třeba entitu se symbolickým jménem "r0" a jménem entity
  "The Entrance".

=> Zpět na stromy - můžu se asi vrátit k původní myšlence, že každá entita
   může být prototypem pro jinou entitu (jen musím dávat bacha na mazání,
   abych nesmazal prototyp jiné entitě).
   - tj. každá entita by asi taky měla mít property "instances", kam
     se budou dávat idčka jejích instancí a dokud to pole není prázdné,
     tak entita nepůjde smazat.


Zajímavá myšlenka: Při editování můžeš "vejít" do libovolné entity,
  tj. můžeš stát v Tilese, Tilesetu, v mobovi, atd.


------------------------------------------------

TODO: 'Sector' přejmenovat na 'Tile'
  - protože zóna se bude skládat z malých kousků - tilesů
Tak možná nikoliv přejmenovat, ale vytvořit Tile paralelně k Sectoru.
- Tile je konkrétní uspořádání několika místností
- Sector je konkrétní napojení Sectorů nebo Tilesů nebo TileSetů
  (s tím, že tam může být na výběr z několika různých tilesů se stejnými vstupy
    a výstupy).

TileSet
- množina Tilesů s matchujícími vstupy a výstupy, z nichž se jeden
  náhodně vybere.
(Asi by měla existovat nějaká obecnější třída EntitySet, která bude umět
 vybírat z množiny prvků podle nějakých kritérií (různé váhy u jednotlivých
 variant, atp.))
- TileSet by asi měla být entita (mít idčko), byť teda ne GameEntita.

Když budu chtít dlaždice využít v různých zónách, tak je prostě zdědím
z nějakého obecného prototypu, stejně jako bych to udělal s roomou.
(Hmm, tohle má asi za důsledek to, že vnumy mohou mít i roomy vnořené
 do obecného prototypu - což je ale asi ok).

IDEA: Propojování room v rámci dlaždice může být prostě podle čísel (nebo jiných
  jmen unikátních v rámci dlaždice). Tj. exit je do roomu "3" a je jasný, že
  to znamená do roomu 3 v této dlaždici.
  - je to ok, protože exity mezi dlaždicemi (a mezi zónami a tak) nevedou
    přímo do roomu (alespoň teda ne v prototypu), ale na connection point
    zóny nebo dlaždice.
Instance budou samozřejmě mít propojení přímo na roomy - přes idčko.

=> Z tohohle každopádně plyne, že prototype name nemůže být univerzálně
  unikátní.
  - instance mají prototypeId které unikátní je, takže to je ok.
  - možná by měly existovat dva druhy prototypů - obecné (s unikátními jmény)
    a "building blocks" v rámci zón bez unikátních jmen.
Jak říkat tomu neunikátnímu jménu?
- vnum asi ne, jednak to není unikátní, za druhé to nemusí být jen číslo
  (můžu si roomu pojmenovat jak chci) a zatřetí by se to pletlo s circlovýma
  vnumama.
vname?
- to zní dobře.
- asi by jich prototyp mohl mít i víc (tj. standardně číslo a když mu chci
  dát jméno, tak nemusím to číslo zrušit).
Ono to asi celkově dává smysl. "Obecné" prototypy budou mít className,
  "budovací" prototypy budou mít vname.
== Tak asi nakonec bude lepší používat klasické vnumy s typem 'number',
   přestože se budou trochu lišit od těch circlových (budou unikátní
   jen v rámci zóny/Tilesy).
   - pokud budu chtít paralelně používat vname, tak to prostě bude
     separátní proměnná.

Těm "obecným" prototypům bych asi neměl říkat "prototypy", ale "předci"
  (ancestors) - nebo ancestor prototype

Obecné prototypy asi budou mít 'vnum = null;'

Instance (*Dynamický prototyp) (+Hardcoded prototyp)
-----------------------------------------------------
Brutus World* (+World)
  - System Realm* (+Realm)
    - System Area* (+Area)
      - System Room (+Room)
  - Northern Lands* (+Realm)
    - The City of Midgaard* (+Area)
      - Market Square (*Market Square) (+Room)
        - a cityguard (*Cityguard) (*Humanoid) (+Character)
        - a cityguard (*Cityguard) (*Humanoid) (+Character)
        - a sign (*Sign) (+Object)


Propojení roomů
----------------
Může být buď klasicky na úrovni prototypů (špatné řešení)
- v zóně Valley of giants je 80 roomů 'Valley of giants', což je
  80 různých room prototypů, které jsou ale všechny zděděny
  z prototypu 'Valley of giants'.
Tj. takhle:
  (+Room) (*Valley of giants) (*Valley of giants0)
                              (*Valley of giants1)
                               ...
                              (*Valley of giants79)
  

Nebo až na úrovni instancí (dobré řešení)
- v zóně Valley of giants je jeden Sector, kterej určuje spojení mezi roomama.
  - každá rooma je Template, ve kterém je jeden prototyp (*Valley of giants)
  (tj. je to vlastně jakási mřížka blackboxů)
Ten Sector je co, instance? prototyp?
- asi instance Sectoru
-- Tohle je blbost, protože Sektor musí obsahovat struktury s exitama - což
   je přesně Room.
     A co víc, dědičnost prototypů mi udělá přesně to, co potřebuju:
     - prototyp roomu (*12312) zděděný z prototypu (*Valley of Giants) bude
       mít v sobě savnuté právě jen ty exity, zbytek (jméno, popisek) si
       vezme právě z prototypu (*Valley of Giants)
-> Což mě přivádí k tomu, že budu potřebovat něco jako vnumy, protože dělat
   prototypy s názvem (*Valley of giants79) zjevně není dobrej nápad.

Sectory by asi mohly být zone-specific
- nebo teda aspoň některé sectory, stejně jako některé prototypy roomů
  jsou sector specific, zatímco jiné jsou globální.

(virtuální jména a grupy teď nechám stranou, to jsou nadstavby).
- v základu by asi zóny mohly mít klasická čísla, sectory zas mohou mít
  čísla v rámci zóny (a nebude tím myšleno vnoření sektorů do sebe, tj.
  sektor 1.2 /zóna 1, sektor 2/ může být vnořený do sektoru 1.1).
- note that provázání je skrz idčka, nikoliv jména. Tzn. roomy můžu libovolně
  přejmenovávat.
Tohle pojmenovávání by mohlo být automatické (editor automaticky pojmenuje
  roomu 13, když už tam je 12 jiných).
== Což mě ovšem vede k otázce: Budou tahle číla sloužit coby className?
   - to je asi blbost, className musí být unikátní.
     A rozhodně v sobě nesmí mít tečky, takže 1.2.14 taky nebude ono.
     Možná to nějak skládat, tj. a1s12r20 (area 1, sector 12, room 20).
     - to teda zas není camel case... (A1_S12_R20)?

Virtuální grupy
(virtuální grupa může být prostě pole idček, to bude řešit ledacos).
- nebude, protože skript musí pracovat nad instancema. A instancí může
  být náhodný počet...
  - v tom v zásadě pole idček může fungovat dobře, protože se prostě
    naplní při instancování a skript pak bude pracovat s polem vnumů instancí,
    ať už se jich vygeneruje, kolik chce.
  - větší problém bude specifikovat konkrétní roomu

RESULT: Vykašlat se na adresářovou strukturu savu, dělit to jen na prototypy
  a instance. Vždycky to můžu dodatečně přesavnout do nové struktury.


Templaty (sety)
-----------------
Cityguard může mít různé rasy, classy, equip a tak.
  - jinými slovy, může to být jeden z několika různých prototypů

Templaty lze vkládat do sebe
- v domě žije otec, matka a dvě děti.
  - otec může být cityguard, písař, whatever...

---------------------

TODO: Tak zpátky na stromy:
  Pokud chci jména prototypů v adresářové struktuře, tak musím:
  - místo descendantIds držet descendantNames
  Změna jména prototypu pak bude znamenat:
  - změnit svoje className
  - změnit záznam v decendantNames předka
  - přejmenovat svůj save (fileName)
  - přejmenovat adresář, do kterého se savují moji potomci
To zní zasi relizovatelně.
- pořád to znamená, že půjde reálně změnit jméno prototypu (instance
  se budou na prototyp stále odkazovat idčkem nikoliv jménem).

ÚVAHA: Potřebuju vůbec ancestor (nebo ancestorId)?
- asi by stačilo prototypeId.
  - musel bych nějak jinak poznávat, že jde o prototyp (než že je
  prototypeId null).
  - zase by se stejným mechanismem loadovaly všechny entity, ať už jsou
    prototyp nebo ne.
- mělo by to být id a ne reference, ať nemám paralelně dvě reference na
  prototyp/předka. Když budu potřebovat referenci na předka, můžu jít
  přes .constructor.prototype (tím teda dostanu tvrdou referenci místo
  proxy, ale to by snad nemělo vadit).
TODO: Zrušit ancestorId (a ancestor).
[done]

TODO: Zkontrolovat, že se non-primitive properties korektně savují
  (jen jejich own properties).

TODO: Při vytváření prototypu mu nastavit 'className'.
[done]

TODO: Udělat z descendantIds Set místo Array
  - Set se asi neumí savovat/loadovat v SaveableObjectu.
- změnit to i v PrototypeManageru.
[done]

TODO: Nedědit Sector ze zóny ani naopak
  - pokud mají něco společného (třeba connection pointy), tak to něco
    může být jedna classa. Jinak jsou to ale různé věci.
[done]

TODO: Delete prototypu.
TODO: Když se vytváří/ruší istance entity, přidat na ni odkaz
  do její prototypové entity (do weakmapy).
    (ok tak do weakmapy ne, musí to bejt normální mapa.
     - weakmapu nelze iterovat a nelze se ptát, jestli je prázdná)
  - díky tomu bude možné checkovat, že od prototypu neexistují žádné
    instance, a tudíž je možné ho smazat.
  - a potenciálně půjde najednou změnit prototyp všem entitám instanciovaným
    od nějakého prototypu.
Tohle potřebuju i kvůli tomu, aby fungovaly věci jako getTotalCount().
- tzn. musí to obsahovat i instance, které jsou jen savnuté na disku,
  ale momentálně nejsou v paměti.

TODO: Možná přetížit entity.save(), aby savnul ancestora a případně
  PrototypeManager, pokud je to prototypová entita (ať user nemusí
  myslet na to, co všechno má savnout).
- ostatně stejně budu muset nějak pořešit save path pro prototypové entity,
  tak to můžu udělat při jednom.

TODO:
- vytvořit prototyp podle jména předka
- vytvořit prototyp podle idčka předka
  - v obou případech ho rovnou savnout.
  NOTE: Prototypy nikdy nemají unikátní jméno.
  - mají unikátní jméno prototypu, tj. className - to je zajištěno hashmapou
    PrototypeManager.prototypeObjects.
- savnout prototyp
- přejmenovat prototyp
- změnit, z čeho je prototyp zděděný
- možná smazat prototyp
- PrototypeManager.loadDynamicEntityPrototypes()


TODO: V obou proxy handlerech použít Reflect všude, kde to půjde.

TODO: interface PrototypeRecord asi může zůstat privátní,
  do EntityManageru můžu passnout jako parametry přímo jendotlivé
  property.

TODO: Parametry typeCast v EntityManageru přejmenovat na Class.

Parallel async processing
--------------------------
let [foo, bar] = await Promise.all([getFoo(), getBar()]);
(viz https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8#.u96s09vfj)



Jak na prototypy
-----------------

V rámci PrototypeManageru nejspíš potřebuju savovat pouze
idčka hardcoded entit a jejich potomky.
- non-entity classy není třeba savovat, jejich prototypeObjecty
  se vytvoří dynamicky.
- dynamické entity prototypy se loadnout rekurzivně podle idček
  a případně adresáře podle dědění. Čili jejich záznamy v PrototypeManageru
  lze taky vytvořit dynamicky (až na idčka potomků, leda by se
  savovala do entity)

V PrototypeManageru by byla hashmapa:
{
  // <jméno prototypu, prototypeObject>
  // entity prototypy by tam měly prostě referenci na entitu
  //  (aby nebylo potřeba přistupovat k tomu nadvakrát)
  prototypeObjects = new Map<string, Object>
}

Alternativně:
- všechny prototypové entity mohou mít record v PrototypeManageru
  - pořadí záznamů musí být v pořadí dědičnosti (aby se předci vždycky
    loadnuli dřív než potomci)
    - tady by mohl být problém při změně předka, asi bych musel vždycky
      vyndat záznam z hashmapy a znova ho tam vložit (protože když ho dám
      na konec, tak mám jistotu, že předek je určitě dřív).
      - na druhou stranu z něj může být zděděno něco dalšího, a to něco bych
        takhle přeskočil.
  - potom nebude třeba pamatovat si potomky, stačí si pamatovat
    předka.
  - všechny záznamy budou mít idčko - podle něj se loadne entita (pokud
    to není hardcoded prototyp - vlastně možná i když je, protože
    stejně musí být v EntityManageru, aby se na něj šlo dostat přes idčko).
Tohle by znamenalo, že prostě loadnu všechny entity v seznamu (podle idček).

------------------------
Po zralé úvaze takhle:
=======================




Všechny entity prototypy budou mít vlastní entitu v EntityManageru,
  včetně hardcoded entit.
  => descendantIds může být přímo v entitě pro všechny entity prototypy.

Pro hardcoded entity potřebuju savovat:
  - idčko odpovídající entity
  - descendantIds
otázka je, jestli bude lepší prostě ty "dummy" entity savnout
  (tím se savnou descendantIds), nebo si pamatovat id a descendantIds a dummy
   entity z nich při loadu vyrobit.
   - asi bude lepší savnout entity, protože pak nebudu muset psát novou metodu
     do EntityManageru, která by uměla vyrobit entitu na základě poskytnutého
     idčka (prostě tu entitu loadnu, což už EntityManager umí).
   - zároveň se tím savnou descendantIds (to taky bude jediná věc, kterou
     budou mít hardcoded entity prototypes v own properties.

I když počkat, jak ty hardcoded entity prototypy loadnu, když neexistují
prototypeObjecty?
- hmm, nijak. Tzn. hardcoded prototype entity asi fakt musím
  vyrábět vždycky ručně.
TODO: Přidat do EntityManageru metodu na vytvoření entity s daným idčkem
  a prototypeObjectem (prototype object bude prostě new Class - ať už
  při loadu, nebo při inicializaci hardcoded entity prototypu, ktrej ještě
  nemá přidělené idčko).

Čili v PrototypeManageru potřebuju savovat seznam záznamů pro každou
  hardcoded prototype entitu, kde bude idčko a descendantIds.
  - pořád nevím, jestli stačí pole, nebo by to měla být mapa (indexovaná
    nejspíš jménem prototypu)
  - budu pak procházet dynamic classes, hledat v nich entity a kontrolovat,
    jestli už mají záznam. Na druhou stranu to můžu kontrolovat v mapě
    prototypeObjects, do které se vytvořené entity pod příslušnými
    jmény nahází.
  => Asi fakt stačí pole záznamů
  {
    prototypeName: string,
    prototypeEntityId: string,
    descendantIds: string
  }
TODO: PrototypeManager.staticEntityPrototypes;



--------------------------------------------

TODO: Zkontrolovat relog na account.

TODO: Když při tvorbě characteru player pouze zmáčkne enter,
  nemělo by to po něm chtít nové, mělo by ho to hodit zpět do
  menu - protože se může stát, že v menu zmáčknu jedničku omylem
  a bez tohohle bych se z toho neměla jak dostat.

TODO: Uppercasovat hodnoty v NamedEntity.nameCathegory.

TODO: PrototypeEntity možná přejmenovat na ScriptableEntity?
[done]

TODO: Connection není zděděná z PrototypeEntity (což je ostatně taky divný
jméno), takže neprojdejde entity.setPrototypeId()
v EntityManager.createEntityProxyFromPrototype
- Co s tím? Asi prototypeId přesunout přímo do Entity, protože nedává smysl,
  aby ho neměla.
  - v PrototypeEntity by měly být věci kolem skriptů a tak.
[done]


Ok, nakonec to asi celkem dává smysl takhle:
- EntityManager (<idčka, entity>)
- PrototypeManager (<jména_prototypů, idčka nebo prototypeObjecty>)
- DynamicClasses sloučit s ClassFactory, protože to je v podstatě to samé.
  (možná prostě jen zrušit ClassFactory).
  - je to prostě jen seznam class, které mají jít dynamicky instanciovat.

createInstance() asi bude v PrototypeManageru (protože to vyrábí instanci
 založenou na prototypu)


Se jmény to můžu udělat tak, že když se vytváří nová instance entity, tak
se jí natvrdo setne "Unnamed Entity" (respektive createEntity() asi má
jako povinný parametr jméno, takže se prostě setne nové jméno).
- tzn. prototypy klidně mohou mít jméno, ať je poznat, co to je.

IDEA: ClassFactory (nebo možná PrototypeManager) by asi měl mít hashmapu,
  kde budou jména všech prototypů (míněno classNames), nejen hardcoded entit.
  A to proto, že když budu chtít dědit, tak nebudu zadávat idčko, takže stejně
  budu potřebovat umět přiřadit idčko ke jménu classy.
  - záznamy mohou mít funkci getPrototypeObject(), která buď přímo vrátí
    svou referenci na prototypeObject (když to není entita), nebo si řekne
    EntityManageru o příslušnou entitu.
  Díky tomu se asi obejdu bez dvojí hashmapy (v té druhé jsou idčka, což
  je asi zbytečné, protože idčka jsou už v EntityManageru).
  - pozn: descendantIds by v tom případě měly být v entitě, nikoliv
    v PrototypeRecordu.
- tahle hashmapa se může jmenovat přímo 'prototypes' a může to být
  mapa <string, Prototype> (tj. idčko a záznam o prototypu). Nebo
  možná prototypeRecords <string, PrototypeRecord>.
- ještě je otázka, co se strukturou na disku. Možná se nakonec vykašlat
  na celý adresář /prototypes? To by znamenalo, že by prototypy byly
  přímo v /entities...
  - asi ne. Pořád zůstává, že u prototypů je podstatné hlavně to, jak jsou
    vzájemně poděděné, zatímco u instancí je podstatné hlavně to, do čeho
    jsou vložené.
Takže:
TODO: Zrušit obě hashmapy v ClassFactory a dát místo nich prototypes
  nebo prototypeRecords.
- pak je tu ještě možnost, že by se Prototypes jmenovala classa, ve které
  budou prototypeRecords - a ta by se savovala. Takže v /data by byl
  soubor Prototypes.json - což dává smysl.



------------------------------------

TODO: se jménem entity je to možná dost podobné jako s idčkem
  - zdědit ho z prototypu asi není úplně dobrej nápad.

Loadování referencí
-------------------
- Contents by se měl loadovat jinak než volné reference.
  - Měl by se nejdřív loadnout obsah containeru, aby se pak
    do něj mohly dát existující reference.
- Volný reference (jako kdo castnul tenhle spell) se asi skutečně
  má loadnout jako invalid entity, pokud cílová entity není loadnutá
  - to taky znamená, že je s ní nutno pracovat s předpokladem, že
    může být invalid (vždycky si říct o currentReference a pak ji
    ještě testnout na isValid()).
TODO: LoadContents
  - savovat a loadovat to jinak než ReferenceRecord.

TODO: Zprovoznit loadování RefereceRecordu
  - nejspíš skrze createReference.

---------------

TODO: Vyrábění nových prototypů
TODO: Assignování idček při vytváření nového prototypu
  (ancestor do entity, descendants do předka).
  - tj. nějaké createPrototype()
    - asi v EntityManageru, protože dynamicky vytvářené prototypy
      budou vždycky entity.
    - a možná by mělo existovat i něco jako convertToPrototype()

Entity.load()
Entity.save()

TODO: Entitám je třeba nastavovat prototypeId.

TODO: Nahradit PrototypeManager.createPrototype() něčím aktuálnějším.

TODO: Savování prototypeId
  - a vytváření instance na základě prototypu při loadu

TODO: Savování/loadování class, které nejsou entity

/*
  Prototypy jsou regulerní entity, a to včetně prototypu "Entity'
  - jako osatní entity jsou v EntityManageru
  - jsou za EntityProxyHandlerem

  Hledat podle jména prototypu je ok, ale držet se musí vždy jen idčko
  - tj. v editoru můžu jako předka zadat "Character", ale do prototypu
    se uloží idčko získané přeložením "Character" na idčko.
*/

TODO: Určitě přejmenovat NamedEntity na UniqueEntity
  - bude se to míň plést s NamedClass

TODO: Uppercasovat hodnoty v NamedEntity.NameCathegory
  - lowercasovat to až při savu/loadu
  - asi by se to taky mohlo jmenovat prostě NamedEntity.Cathegory 

TODO: Instantiovat taky Acconty, Connectiony a podobně
  (a nemyslím tím jejich properties, ale přímo Account. Zatím se to děje
   jen u GameEntit, protože ty jsou vždycky za nějakým dynamickým prototypem)
Tohle je komplikované. Znamená to:
1) v ClassFactory si nepamatovat konstruktory, ale prototypy (tedy instance).
   tj. nikoliv Account, ale new Account.
2) v ClassFactory.createInstance() nedělat new Account, ale
   Object.create(accountPrototype).
3) Při vytváření dynamických prototypů pak asi nebude potřeba setovat
   properties do Class.prototype, místo toho se budou setovat do
   classPrototype, který si drží ClassFactory.
- možná by se pak class Prototype nemusela překopírovávat do Entity,
  mohla by se umět savovat sama o sobě. A nebyl by důvod držet je
  v PrototypeManageru, když by si je držela ClassFactory...
  - plus funkcionalita na vyrábění (a savování) skriptů by asi byla
    v nějakém zděděném mezistupni
  Znamenalo by to, že kód skriptů by měla každá instance?
  - neznamenalo, byl by jen na prototypu.
SOUNDS GOOOD

  /*
    3 vrstvy:

    mergnute_prototypy (predkove)
          |
          v
    primy_prototyp
          |
          v
    Object.create(primy_prototyp)

    - v primem prototypu budou jen nezdedene, pridane properties
    - v mergnutych_prototypech budou nakopirovane properties z prototypu predku

    Kazdy prototyp by měl mít seznam mergnutých prototypů, které jsou z něj
    zděděné, a které je nutné přenenerovat při jeho změně.

    Přejmenovávání prototypů
    - správné řešení by asi bylo, neodkazovat se na předka jménem, ale idčkem
      (protože předek je entita)
    - problém je, že to pak bude špatně čitelné na disku...
    Asi by to znamenalo, že i prototype savy by byly pojmenované idčkem,
    stejně jako entity.
    - měla by to být unikátní jména. Takže možná prostě přidat kategorii
      "prototypes"?
    - pak mi zas zmizí ta interní struktura...

    Smazání prototypu
    - je možné, pouze když nemá žádné potomky
      (tj. je třeba nejdřív potomkům nastavit, že jsou zděděné z něčeho jiného)

    Přejmenování prototypu
    - prostě se změní classname, plus se musí přejmenovat adresáře
      v /prorotypes a dost možná i v /entities (pokud i tam bude struktura
      podle dědičnosti.

    Prototypy v entity manageru
    - pokud budou prototypy přímo entity, tak asi mohou být přímo
      v EntityManageru místo v ClassFactory
      (classFactory pořád bude muset držet dynamické classy z kódu)
  - tak ne, prototypy by přece jen měly být v ClassFactory.

    Adresáře asi mohou být skrupturované podle typů
    - díky tomu by mohlo jít celkem snadno přejmenovávat classy v kódu,
      bude k tomu stačit současně přejmenovat adresáře ve struktuře
      (v /entities a v /prorotypes)
      - top-level prototypy budou to, z čeho jsou zděděné brát ze jména
        nadřazeného adresáře
        (tj. když ancestors === [], tak to znamená, že hledám dynamickou
        classu se stejným jménem jako adresář.
        - respektive možná ne classu, ale prototyp stejného jména, ale
          s malým písmenem (account). To by znamenalo, že adresáře uvnitř
          struktury budou malými písmeny (i když dynamické prototypy asi
          ne...)
  */

Jak to udělat se jmény?
- když prostě zdědím PrototypeEntity z NamedEntity a setnu jí unique name,
  tak všechny vytvořené instance automaticky budou mít to stejné jméno...
  (leda bych to hacknul v createInstance()...)

IDEA: Kašlat na stringová idčka, použít reference
  - problém s loadováním z disku. Z adresáře si přečtu jméno typu,
    tj. pořád potřebuju ta jména. 

IDEA: Určitě používat UpperCase jména, protože dynamické prototypy by
  v lowercasu nebyly čitelné (leda by to byl camelCase). Není to název
  proměnné, je to klíč v hasmapě, takže to klidně může být přímo ClassName.

TAKŽE:
- jméno předka se bude brát z názvu adresáře, aby při přejmenování prototypu
  stačilo přejmenovat adresář.
  - předci se vůbec nebudou savovat - kurnik ne, to nejde, to by nešla udělat
    vícenásobná dědičnost.

- určitě používat idčka. Ideálně teda vyrobit "dummy" prototypy i pro
  hardcoded classy.

- nemělo by se savovat, jaké mám předky, ale jaké mám potomky. Díky tomu
  půjde lodnout všechny prototypy rekurzivně - jen musí existovat kořen.
  (PrototypeManager?)

ALGORITHM loadování prototypů:
0) Pokud při startu hry neexistuje save GameEntity, tak se vytoří.
   (seznam classNames se vezme z DynamicClasses, idčka se vygenerují)
   - asi by se měla automaticky updatovat, i když náhodou existuje.
1) Loadnu GameEntity 
   - ta má seznam idček hardcoded prototypů.
   - z /data/names/prototypes si přečtu příslušné classNames.
   - Vytvořím instance (přes new className) a loadnu je z disku.
     - v savech je seznam idček potomků.
2) Rekurzivně instancuju potomky (už ne přes new? I když vlastně asi
   jo, tohle jsou prototypy).
   - tak ne, musím to dělat přes Object.create(), jinak by se mi v každém
     potomkovi znovu vytvořily všechny inicializované proměnné předků.
     - čili prostě vždycky loadnu generický JSON object - ale ideálně
       do instance, kterou jsem vytvořil přes Object.create(ancestor).

Pozn: V savech kromě primary potomků asi budou ještě secondary ancestoři
 (tj. ne přímý ancestor, jen doplňkoví, jako třeba Shaman).
 - ono vůbec asi zní jako docela dobrý nápad ty secondary funkcionality
   nedědit přímo z Entity.
  


TODO: Změna prototypu
- kromě jiného bude třeba znovu zavolat instantiateProperties().

TODO: volat instantiateProperties() taky při vytvoření prototypu.

TODO: CONNECTION_ERROR message by asi neměly být prompt (končit mezerou).

TODO: Sjednotit statická volání EntityManager.doCosi() a nepřímá volání
  Server.entityManager.doCosi()
- možná by entityManager mohl být komplet statický?

TODO: Pojmenované listy (AccountList) by se mohly jmenovat prostě Accounts
  (sedělo by to pak s názvem proměnných: public accounts: Accounts)

TODO: Ještě jednou se zamyslet nad unikátními jmény
 (unikátnost by se mohla setovat už v konstruktoru, každopádně teda
  nezávisle na setName()...)
- teď už do toho asi vrtat nebudu.

TODO: Ještě jednou projít celý proces vytváření a loadování entit.

TODO: Checknout, že je první založený char creator.

TODO:
Syslog message "Player X entered game with character Y"
Syslog message "Player X playing character Y has left the game"


TODO: K "welcome" mesage v connection.enterGame() by měl bejt přilepenej
  look do roomu.
  - nebo teda aspoň bezprostředně následovat.

TODO: Posílat info o uncaught exceptionech do syslogu.
  (v BrutusNext.ts)

IMPORTANT:
  Při dědění z prototypu se údajně neinstancují non-primitive properties,
tj. když má prototyp např. array, tak všechny jeho instance referencují
tu samou instanci pole.
Řešení:
  Inicializovat datové properties v konstruktoru.
  - jinak řečeno, prototyp by měl mít konstruktor, kterej projde data[],
    udělá z nich kopie a nasetuje je insatnci, kterou vytváří.
  - na druhou stranu tohle pak nebude dělat to, že změnou prototypu se změní
    všechny existující instance...
TODO: Vyzkoušet to
 - fakt to tak je :\
TODO: Jediné "řešení", co mě zatím napadá, je zavolat Object.freeze() na
  všechny non-primitive property prototypu - pak nejde ani přidávat prvky
  do pole.
  - ideálně rekurzivně.
- hází to pak TypeError při pokusu takovou property měnit.
BIG TODO: Rekurzivně freezovat všechny non-primitive property na dynamických
  prototypech.
- tak nakonec ne. Lepší bude dát všechny vnořené objekty za Proxy.
TODO: Při inicializování dat prototypu udělat z vnořených objektů (tj.
  ze všech non-primitive properties) Proxy.
- chce to nový proxyHandler
  Proxyhandler vnořeného objektu bude mít v sobě:
  - referenci na entitu (respektive teda na prototyp), do které je vnořený)
  - jméno property, kterou představuje (respektive nejvyšší level, pokud
    je to víckrát zanořené).
  V set() trapě:
    - Přes jméno property checkne, jestli už je na instanci entity naalokovaná
      instance vnořeného objektu.
      - pokud jo, tak do ní rovnou zapíše
      - pokud ne, tak ji nejdřív naalokuje a pak do ní zapíše
- musím si pamatovat referenci svého nejbližšího nadřazeného containeru
  a jméno property v něm, abych mohl poskládat dereference chain (a tudíž
  setnout správnou property poté, co naalokuju kopii v instanci). 
- musím umět poznat, jestli ta reference vede na entitu, nebo na vnořený
  objekt.
  - instance už možná může mít referenci na nadřazenej container 'null',
    protože už nebude potřebovat ten chain zkonstruovat.
- musím umět poznat, že už instance existuje
  - to by asi mělo jít porovnáním referencí - dokud není instancováno,
    tak by reference měly být rovné. 
TODO: Alokování dynamických class
  - asi jen className a ne přímo reference na kostruktor classy, ať není
  problém, když někdo ten prototyp vytvoří znovu (i když, hrozí to vůbec?
  změny se budou dělat setováním na existujícím prototypu. Problém může být
  jen přejmenování - a to zapamatované jméno neřeší, špíš naopak komplikuje)

[18:53] Rahman       : <64> Hmm, tak zatim to vypada, ze se savem/loadem nebude
                            vubec zadnej problem, jen musim rekurzivne
                            instanciovat entitu pred tim, nez ji necham
                            naloadovat
[18:54] Rahman       : <64> rekurzivni instanciovani udelat to, ze proleze
                            property prototypu a rekurznivne vyrobi prazdne
                            objekty zdedenych z tech na prototypu
[18:55] Rahman       : <64> tj. pri loadu bud ten prazdny objekt uz bude
                            existovat a pak se do nej proste zapise
[18:55] Rahman       : <64> nebo existovat nebude, ale v tom pripade neexistuje
                           ani na prototypu (protoze jsem duplikoval vsechny
                           property z prototypu), takze je to proste vec,
                           kterou ma instance navic oproti prototypu a tudiz
                           ji staci proste vytvorit a zapsat do ni to, co 
[18:56] Rahman       : <64> je v loadnutem JSONU

IDEA: SaveableObject bude savovat jen own properties.
  - což by mělo být ok, protože když se do nějaké zděděné property něco
    zapíše, tak se z toho stane own property
    - ovšem to platí pouze pro primitivní typy
- to asi znamená, že bych měl všem SaveableObjectům při instancování
  instancovat jejich neprimitivní properties.

ÚVAHY:
- Prtotypy asi můžu taky vyrábět přes Object.create() místo new class ...


TODO: vícenásobná dědičnost prototypů


TODO: Zvážit savování enumů stringovou hodnotou místo intu
- mělo by to výhodu v tom, že se to nerozbije, když někdo přidá hodnotu
  doprostřed enumu (tj. posunou se intové values).
- asi bych to musel savovat jako IndirectValue, abych při loadu
  zjistil, podle jakého enumu se ta hodnota má dereferencovat (ze stringu
  na int).
    Na to bych ale asi musel umět dynamicky přistoupit na enum podle jména
    ve stringu.
    - jinak řečeno, musel bych přidat enumy do dynamicClasses...

TODO: Při zakládání nového charu to mockrát checkuje existenci name lock file.

TODO: Při zakládání accountu se existence name lock file checkuje dvakrát.
- poprvé když hráč zadá jméno accountu
    (tam je to asi nutné, protože je třeba rozhodnout, jestli se loguje
     na existující account, nebo zakládá nový).
     - i když, Linux se vždycky ptá rovnou na heslo a až pak ověřuje.
       (i když v Linuxu se zas nezakládá účet prostým přilogováním)
       každopádně by to asi šlo pozdržet a ověřovat až po zadání hesla. Jen
       by to asi bylo míň uživatelsky přítulné (že jsem se přesal v account
       name bych se dozvěděl až po zadání hesla... To je asi špatně).
- podruhé když se nový account zakládá.
    Je to tady nutné? Teoreticky ten check už mám hotový. Na druhou stranu
    když ho tu neudělám, tak se nedozvím, že přepisuju existující name lock
    file (a že je někde nějaká chyba).
=> Asi jsou fakt oba checky nutné.

TODO: V ChargenProcessoru po neúspěšném isNameAvailable() zřejmě
  chybí nový prompt.
  - testnout a případně opravit.

TODO: V AuthProcessoru bych asi měl rovnou v loginAttempt() načíst
  account a zapamatovat si ho.
- tím, že si pamatuju jen accountName se jednak několikrát provádí check
  na unikátnost jména
  - a navíc se může stát, že než zadám heslo, tak někdo založí ten samý
   account a mě to pak failne.
Když založím account rovnou, tak tím zároveň vytvořím lock.
- na druhou stranu by asi bylo fajn mít aspoň nějakou DOS protection,
  tj. ideálně nezahazovat account hned (při nepovedeném hesle, shozené
  lince, atd.), ale až po nějakém timeoutu.
(druhá možnost je, udělat si ten lock v paměti. Tj. někde zaregistrovat,
 že se někdo snaží přihlásit pod daným jménem...)
 - buď je account online (někdo se reloguje), pak není co lockovat
   (ale možná by bylo dobré si pamatovat rovnou ten account místo accountName)
 - nebo online není, pak je třeba vyrobit lock
Ok, udělám si lock v paměti (hashmapou se jmény accountu - respektive asi
  spíš setem).
  - odstranit ho je třeba v okamžiku, kdy se vyrobí lockFile, případně když
    se closne connection.

TODO: Jelikož mám soft lock na accountName, tak už nemusím znova checkovat,
  že je volné, když vytvářím account.
  (na druhou stranu to se možná dělá automaticky...)

IDEA: Místo NamedEntity (createNamedEntity(), atd.) používat
  UniqueEntity (createUniqueEntity).

TODO: settings.ts možná hodit spíš do rootu projektu, než do ./src
  (a možná by to měl být spíš settings.json)


TODO: Misto Message.Type.AUTH_ERROR zavest SYSTEM_ERROR
  (ať nemám 20 různých druhů error messagů)
  - tak ne SYSTEM_ERROR (to už existuje), ale CONNECTION_ERROR.

BIG TODO: Vícenásobná dědičnost prototypů (a možná i hard codu, viz:
  https://typescript.codeplex.com/wikipage?title=Mixins%20in%20TypeScript)
Implementation: Nedělat dědičnot nastavením prototypu svému prototypu, ale
  zkopírováním všech properties z předků do svého prototypu.
  - Znamená to bohužel, že při každé změně libovolného prototypu bude potřeba
    updatnout všechny prototypy, které jsou z něj zděděné.

TODO: Zkontrolovat, že connection.close() dealokuje
  vše, co má dealokovat (odebrat account z listu, etc).
- asi jo...

TODO: Přejmenovat všechny 'filePath' v SaveableObjectu (a asi i jinde)
  na 'path'.

TODO: Nepoužívat Map<any, any> (což je implicitní, když napíšu
  jen newMap()), ale konkrétní typy.
  - tím mi zároveň odpadnou z commentu.

ÚVAHA: /data/entities by možná mohly mít strukturu podle struktury světa,
 tj. world/realms/areas/rooms etc.
- když bych chtěl dejme tomu statnout nějakej offline room (může to vůbec
  nastat?) tak mu prostě dám tuhle celou cestu. 

TODO:
  - ne všechny entity v rámci worldu by měly mít unikátní jména.
    Třeba roomy by nemusely.
Hmm, to bych asi měl nějak ošetřit na úrovni prototypu - jestli setName()
  setne unikátní jméno nebo ne (čili možná cathegory nesetovat v rámci
  setName, ale v konstruktoru/deklaraci?). 

TODO: getSaveDirectory může vrátit null
  - obecně při vytváření cesty nemá smysl dělat něco jako "INVALID_SAVE",
    protože by se mi stejně přepisovaly entity přes sebe.

IDEA: Množení referencí by šlo ještě vyřešit tak, že isValid() nebude
  automaticky obnovovat referenci - tj. bude to nutit k tomu, vždycky
  si od Entity manageru vzít novou referenci, když ta stará přestala
  být valid.
  - To je asi rozumné řešení, protože automatická validace dotazem na
    isValid() není zrovna intuitivní - zahlásí mi to chybu na invalid
    přístup, já si pak na stejné místo dám isValid() a ono se to najednou
    bude tvářit jako validní reference.
Výhledově by samozřejmě stále bylo fajn, kdyby to šlo pořešit úplně
automaticky a reference zachovávaly identitu, ale dokud to nepůjde, tak
je asi nejlepší řešení prostě jen hlásit invalid reference jako invalid
a nechat na uživateli, ať si je sám updatne na aktuální, když to potřebuje.

TODO: Handle file operation return variables in SaveableObject.

TODO: Sjednotit FileSystem
 - buď tam házet FATAL_ERROR
 - nebo hlášku do syslogu a vracet boolean
určitě ale neházet hlášku do syslogu a pak vyhodit exception, od toho
je fatal_error.
- ideálně asi vracet ten boolean (obecně by měl mud být co nejodolnější proti
  crashům).

TODO: Projít všechno zděděné z Entity a odstranit zbytky staré
  adresářové struktury

TODO: Rozhodnout, co se bude savovat v accountu (idčka?, jména + další info?)

TODO: Projít save()
  - u named i generic entit.

TODO: Zkontrolovat, že celý chain používající FS.exists() je async.

TODO: V rámci EntityManager.loadNamedEntity() je třeba přidat entitu
  do EntityManageru.

Entity.load() nemusí umět číst unique name soubory - entita vždycky zná
  svoje idčko.
Entity.save() musí umět savnout unique name soubor, protože když se změní
jméno entity, musí se změnit tenhle soubor.

V Accountu nesmí být přímo jména charů.
- protože když přejmenuju entitu, tak by odkaz z accountu přestal fungovat.
  - když tam budou idčka, tak je to v pohodě.
To ale znamená, že account bude muset při loadu načíst všechny chary
  - minimálně do té míry, aby z nich mohl přečíst jména (aby je mohlo game menu
    vypsat hráči a aby se hráč mohl loadnout s konkrétním charem.)
- možná bych mohl vyžadovat, že přejmenovat char jde jen s online acocuntem
  (tedy je to metoda accountu, pak by v accountu mohla zůstat jména...)

IDEA: V menu bych možná mohl vypsat víc informací o charu. Což ale zase
  znamená, že bych buď musel všechny ty chary načíst (aspoň do JSON objectu),
  nebo si to info pamatovat v accountu (stejně jako jméno charu).
  - ovšem věci jako level se potenciálně mohou měnit i když account nebude
    online (offline reward za questy třeba?)....

Moc to komplikuju, podrobnější info o charech v accountu teď rozhodně
implementovat nebudu - není to zásadní pro prvotní hratelnou verzi.
(ale počítat bych s tím mohl...)

----------------

TODO: Přibyla static metoda Entity.isValid(entity);
  - použít ji všude, kde dává smysl ji použít.

TODO: Předělat všechny async fce, které by mohly vracet hodnotu, ale nevrací,
  protože jsem si myslel, že to nejde.

/// TODO (ClassFactory.createInstance()): Typecast.name nemusi existovat
///   (u dynamicky vytvorenych class, coz jsou vsechny prototypy).
/// - nebo mozna jo (mohlo by to byt v NamedClass nějak ošéfované)?
      Zkontrolovat
      - tak není, je tam jen className. takže TODO (opravit to v ClassFactory)

TODO: Nesavovat property 'id'
  - id bude vzdycky dano jmenem souboru.

TODO: Nesavovat typ odkazované entity do objektů, ze kterých je odkazována
  - protože pak nepůjde měnit typ entit (savnuté odkazy by se pak loadovaly
    špatně).
- místo toho savovat jen stringId, podle kterého se načte soubor (do
  generického Objectu, takže v pohodě), z něj se přečte className a až podle
  něj se vyrobí instance.
- problém bude s Accountama, Worldem a podobně, kde nejde z idčka odvodit
  cesta k save filu.
  - Obojí by asi šlo odvodit z jména...
Takže:
- odstranit className z id recordu v savech
- charactery savovat nadvakrát. V /data/characters budou soubory pouze
  s idčkem (tj. bude se tím překládat jméno na idčko a bude se tím kontrolovat,
    že je jméno unikátní)
Asi bude nejlepší udělat to úplně jednotně, tj.:
  - všechny uniqueNamedEntities budou mít soubor v adresáři data/uniqueNames
    - v něm budou podadrešáře (/world, /account, /character), unikátnost
      bude per adresář (což zajistí prostě to, že to budou soubory v adresáři).  
    Tyhle soubory budou obsahovat pouze idčko...
...
Hmm, už vím, na co jsem potřeboval typ v id recordu - bez něj nedokážu
  zkonstruovat adresář, do kterého se to savuje. Musely by být všechny entity
  v jednom adresáři
  - vadí to něčemu?
    Nebude to tak přehledné na disku, nepůjde třeba jednoduše prohledat jen
    všechny moby...
...
Ze hry budu chtít dělat:
  stat file Zuzka
  stat file account Rahman
  načtení accountu při logování do hry (podle jména accountu)
  pejmenování charu (takže by asi jména charů neměla být přímo v accountu) 
...
- asi bude nejlepší nesavovat vůbec entity.name do hlavního souboru,
  - to je blbost, protože bych pak nedohledal jméno čistě na základě idčka.
Nedá se nic dělat, jméno musí být na dvou místech.


TODO: Zařídit, aby se šlo na jeden account lognout s vícero connectionama
  aby do hry šlo vlézt s jedním mortalem a vícero immortalama či testplayerama.

TODO: Savovat Server
  (zatim kvuli MOTD, ale možná přibudou i další properties na savování).
  - možná ne celý server, ale jen do něj vložit SaveableObject?

TODO: Přejmenovat Connection.receive() na něco jiného (něco ve stylu
  sendAuthPrompt v authManageru) - a nastavovat msgType až uvnitř téhle
  metody.
  (neměla by to být obecná metoda na posílání messagů connectionu).

IDEA: Možná to s messagama udělat trošku jinak:
  - místo GameEntity.receiveMessage, Game.sendCosi, AuthProcessor.sendCosi atd.
    udělat statické metody do Message. Takže půjde psát např.:
    Message.sendToConnection(connection, text, msgType, sender);
    - statická metoda prostě založí new Message() a pošle ho.
sounds goood

TODO: Server možná zpřístupňuje věci, které by mohly zpracovávat
  metody Serveru. 

TODO: V LobbyProcessoru predelat menu
- po zalozeni accountu tam bude:
     0) Quit game
     1) Create new character
- po zalozeni prvniho charu tam bude:
     0) Quit game
     1) Enter game as Zuzka
     2) Create new character

TODO: Projít celý kód a ze všech protected funkcí, které nemusí být
  protected, udělat private.

TODO Po promotu/demotu savnout AdminList.

TODO: Co když je imm do něčeho switchnutý?
  - asi se mu budou message bufferovat, podobně jako když je LD, a vypíšou
    se, když se odswitchne.

TODO: Předělat posílání všech stringů ve hře, aby používaly Message.

TODO: Vyzkoušet save/load Admins

TODO: Promotovací a demotovací syslog hláška a info.

TODO: Automatické přidávání (a případně i žraní) tečky na konci věty.
  - automaticky ji přidávat za text v příkazu send(), pokud tam není.
  - automaticky ji žrát z ERROR stringů.

IDEA: Pouze admin charactery mají private referenci na admins: Admins
    (důležité je, že je ta reference private v třídě GameEntity, takže
    potomci se na ni nedostanou přímo, ale pouze voláním existující metody)
  - Metoda udělá co:
    - zavolá this.admins.doSomething(this, action, params);
  + server má 'admins: Admins;' taky jako privátní proměnnou.

TODO: Nastavit idčko v entitě jako immutable property.

TODO: Immlevely ukladat nekam jinam nez k charu
- (asi do AccountManageru?)
TODO: Udělat na to classu Admins
  - instance v Serveru nebo v Game? Asi v serveru, protože práva se týkají
    i serverových věcí. 

TODO: Loadovat chary do konkrétní roomy.
[To je tak napul. Rahman ma nastavenou 'location', Zuzka ne a nove zalozene
chary taky ne]

TODO: Když se zakládá první character, udělat z něj implementora a dát ho do
  SystemRoom.
  - možná se bude hodit držet si systemRoomId ve Worldu jako proměnnou.
[jakz takz]
- Zatim spis nejakztakz
TODO (stále)

TODO: Zkontrolovat, že dobře loguje BAD PW attempt

------------------------------------------------------------------------------

TODO: Zpřehlednit kód na parsování barev.
- celé přepsáno
[done]

TODO: &&b by se mělo zobrazit jako neobarvené &b
- ve web klientovi [done]
Pozn: Pouze pokud následuje barevný kód.
 (Díky tomu se nezprzní text jako: 'if (a && b)').
 [done]

TODO (lepší nápad):
  Když se narazí na '&&b', tak se to zobrazí jako '&b' - ale nějakou
  speciální barvou (asi jinou než local-echo color).
[done]

TODO: Opravit nekonečný cyklus, když string začíná barvou.
[done]

TODO: Přidat do obarvovacích fcí parametr 'baseColorOverride'
  - a sjednotit kód na vyrábění barevného textu, ať to není na
    dvou místech pokaždé jinak.
[done]

TODO: Při dělení kusů message podle newlinů je třeba někam
  poznamenat, kde byl enter a kde ne - jinak se mi to rozsype
  na milión řádků.
[done]

TODO: Parsování barev trochu jinak:
1) Nejdřív zaměnit /r/n za <br>
   (protože <br> může bejt klidně i uvnitř spanu)
2) Pak to parsovat celé jako jednu řádku.
[done]

TODO: Když recallnu poslední command a dám enter, tak se sice
  nemá přidat do bufferu, ale má se posunout counter.
[done]

TODO: Šipkou dolů by se mělo jít vrátit až na prázdný řádek.
[done]

TODO: Prázný příkaz by se neměl přidávat do bufferu.
[done]

TODO: Zopakování posledního příkazu by ho v bufferu nemělo zduplikovat.
[done]

TODO: Poskakování textu při traverzování command bufferu...
[snad]


TODO: Když do inputu pastnu víceřádkový příkaz,
  do outputu se musí poslat více řádek (tj. je to třeba naparsovat).
[done]

TODO: scrollování outputu, když mám seleknutý input.
  - idea byla odchytávat keyboard eventy na ScrollView místo na inputu.
    To je trochu problém, protože div nemůže dostávat focus
Možná je nejlepší se na to vykašlat, odchytávat všechny eventy na inputu
a volat ruční scrolling na outputu¨
-- i když sakra, jak to, že to můžu klávesnicí scrollovat?
/*
  Adding document level keypress handler does the trick!

  var ar=new Array(33,34,35,36,37,38,39,40);

  $(document).keydown(function(e) {
      var key = e.which;
        //console.log(key);
        //if(key==35 || key == 36 || key == 37 || key == 39)
        if($.inArray(key,ar) > -1) {
            e.preventDefault();
            return false;
        }
        return true;
  });


  // It handles PgUp(33), PgDn(34), End(35), Home(36), Left(37), Up(38), Right(39), Down(40)
*/
[done]

TODO: vytvořit ScrollViewOutput (podobně jako input)
[done]

TODO: Na error reporting v klientu pouzivat /error/ERROR.
[done]

TODO: Vkládat text do outputu přes $.parseHTML().
  - bacha, vytvoří to dom element, nikoliv jquery element.
pozn.: $(htmlElement) vyrobí jqueryelement, není třeba ho hledat podle idčka.
[done]

Pozn k 'input' textaree:
- udělám to tak, že pouze zablokuju odřávkovávání a na enter se celý příkaz
  odešle.
- Vykaslu se tedy na ctrl+enter na interni odradkovani.
To znamena, ze stale pujde pastnout viceradkovy text, ale nepujde vytvorit
uvnitr text arey - to jsem ostatne snad jeste nikdy nepotreboval.
[done]


TODO: Výhledově asi předělat celý content-creation v creation na
  bastlení html tagů (na rozdíl od document.create() je to synchronní
  a navíc asi rychlejší, když se celé html vyrobí stringově a pak naráz
  appendne).
- Tak nakonec asi ne. Smysl to dává tak, jak to je - do scrollView by se
  měl text přidávat najednou, tj. insertem html. Zbytek se může dělat přes
  DOM (je to hezčí kód a o rychlost tam zas tak nejde).
[deprecated]

--------------------------

Struktura aplikace (úvahy)
--------------------

/src
  client.ts
  server.ts
  /client
  /server
  /shared
  /game
Tohle asi může zůstat tak, jak to je?
Nebo to raději oddělit víc, tj. takhle:
(asi jo, bude to líp sedět se strukturou buildu)
- otázka je, jestli se budou nějaké zdrojáky sdílet mezi
  klientem a serverem (namedClass možná?). Pokud jo,
  tak /shared by bylo na úrovni /client a /server
  a některé věci z něj (třeba /entity) by spadly pod
  /server.
/src
  /client
    client.ts
    clientSettings.ts
  /server
    server.ts
    serverSettings.ts
    /shared
    /game
[done]
  
Build by ale rozdělený být měl, už proto, že adresář /build/client
bude zpřístupněný web serverem a neměly by v něm tudíž být serverové
javascriptové soubory.
/client
  /js
    /build
/server
  /build
[done]

Další otázka je, jak do /build dostat html a podobné nesmysly...
- asi začnu tím, že to dám rovnou tam, no (to ale zas bude znamenat,
  že se to bude muset dávat do gitu).
  (Rozhodně ale chci, abych nemusel překopírovávat zbuilděné zdrojáky
   klienta - musí stačit je zkompilovat a dát ctrl+f5 v browseru).
[done]

----------------------------------------------------------------------------

TODO: Zvážit, jestli by stack tarce nešel získávat elegantněji než z error
  objectu, viz:
 using System.Diagnostics;
 StackTrace st = new StackTrace();
 Console.WriteLine(st.GetFrame(1).GetMethod().Name);

TODO: Sjednotit styl, jakým se píšou Enumy (asi na ten z Message.ts, protože
  potřebuju typ používat v jiných modulech).

TODO: Vyzkoušet, co se stane, když savnu objekt s invalid referencí
  (hráč třeba odlognul).
  - mělo by se savnou idčko.

TODO: Z invalid reference by asi pořád mělo jít vytáhnout idčko,
  name a className.
  - tzn. trapovat přístupy na tyhle fce/proměnné.

TODO: Vyzkoumat, jak je to udelane, ze v putty neni pri zadavani videt heslo

TODO: Do zahlavi souboru nakreslit stromy dedicnosti.

TODO: Udelat tridu Command, do ktere se vrazi cely command string, a ktera
  s nim bude umet pracovat (parsovat argumenty, atd.)
- Tohle je otazka. Koukal jsem na to a mozna to neni az tak dobry napad,
  v ruznych situacich se command parsuje ruzne (kazdy skill to muze delat
  jinak, napr.)

TODO: Zkontrolovat, ze datove properties, ktere maji get i set a pri
getu a setu se s nima nedela nic vic nez prirazeni a cteni, jsou rovnou
public.

TODO: Ve vsech classach hodit data na zacatek.

TODO: OLC

TODO (výhledově): Dodělat do AbbrevSearchListu funkčnost, že dokud je v něm
  málo záznamů, tak se vůbec nebude konstruovat vyhledávací struktura, prostě
  se lineárně projde pole aliasů (to proto, aby se zbytečně nezabírala paměť
  vyhledávací strukturou pro pár mobů v roomě, pát itemů v inventáři, atp.)

TODO: Otestovat AbbrevSearchList
  - pridat do nějakého roomu pár characterů
  - implementovat příkaz tell (globální search)
  - implementovat nějaký social do roomu (search v roomu)

TODO: Zprovoznit příkaz na založení nové entity (na Brutusu se tohle děje,
  když dám editovat dosud neexistující objekt)

TODO (hodně výhledově): Zajistit, aby se ze skriptů nedal nastavovat
  Account::adminLevel a nedaly dělat věci, na které je třeba adminLevel > 0.
  (viz ./documentation/code_architecture/admins)

TODO: Zprovoznit prikaz look (zatim asi jen do roomy)
[kostra by snad byla]

TODO: Používat 'new Map' místo 'new Object' (hlavně proto, že dynamicky
  generované klíče mohou kolidovat s existujícíma properties na objektu).
  - vyzkoušeno a přidáno do Saveableobjectu
TODO: Udělat to všude

TODO: Všude, kde se to hodí, předělat předávání parmetrů. Předávání objektem
  dělá kód mnohem čitelnější .
  - tímhle si nakonec nejsem až tak jistej.

TODO: Zvážit, jestli nepřejmenovat všechny proměnné typu newArray (zrušit new).

TODO: Optimalizovat savovani prototypu, kdyz se zmeni jen jeden prototyp
  (takze neni treba savovat uplne vsechny prototypy)
  - mozna metodou Prototype::save(), ktera zavola save prototypeManageru
    na konkretni prototyp?

TODO: Pokusit se sjendotit dynamic typecast (metodou z UTILS?)
  - ideálně ji přesunout někam jinam (někam do entity inheritance chainu)

TODO: Projít všechny FATAL errory a zkontrolovat, jestli musí být FATAL.

IMPORTANT TODO: U prototypu savovat jen přetížené properties, ne ty
  z prototypu.

TODO: Velmi výhledově se zamyslet nad lepším formátem savutých skriptů
  (hjson? samostatný soubor?), protože je to přece jen kód a bude se
  například diffovat v gitu (co na něm který immortal změnil?)

TODO: Casem odstranit consoli ze skriptoveho sandboxu.

TODO: Checkovatko na memoryleaky

TODO: Kontrola, že skript dostal správné parametry.
  - A to ve fci Script.scriptFunction (deklarovane v constuctoru classy Script)

TODO: Nastavitelný Lock proti opakovanému spouštění běžícího skriptu.

TODO: script.recompile

TODO: script.rename (nebo možná Prototype.renameScript)

TODO: Asi všude zrušit property deklarované jako parametry konstruktorů
  (ne vždy se konstruktor volá se všemi parametry a pak se stane to, že
  property není inicializovaná. Kromě toho to znepřehledňuje kód - hůř
  se hledá, co je nějaká property zač.)

TODO: Ještě jednou zvážit typescriptové enumy (Entity.satus, atpod.).
  - použít se dají (je třeba je deklarovat mimo classu a a do classy je pak
    dát jako static proměnnou).
TODO: Projít kód a zvážit, kde by se spíš hodil enum.

TODO: Typescript používat inline místo linkem.

TODO: Odstraněním saveTree z PrototypeManageru jsem přišel o informaci, jaké
  prototypy se mají načíst při startu hry.
  - nějak to pořešit.
Jedna možnost je, prostě prolézt celý adresář /Prototypes

TODO: Při loadu game entity kontrolovat, že savnutá 'location' (její stringové
  idčko) odpovídá tomu, do čeho entitu loaduju (stejné stringové idčko).
  - pokud neodpovídá, tak odmítnout entitu přiřadit
    (Tohle ošetřuje situaci, kdy se jeden player savne, dá item druhému
    playerovi, ten se savne a následně spadne mud. Tomu prvnímu to při loadu
    item nedá, protože nebude sedět location. Tomu druhému load projde.
    - to samé platí i pro restorování ze zálohy.)

TODO: Classu EntityRecord asi vyhodit z EntityManageru do samostatného
  modulu.

TODO: V SaveableObjectu (a možná i jinde) předávám do vnořených volání
 hromadu stejných parametrů.
 - zabalit je do objektu 'param', dost se tím ten kód zpřehlední.

TODO: Výhledově přesunout některá nastavení z workspace settings (ve VS code)
  do user settings. User settings by to ale pak asi chtělo přidat do gitu,
  ať je mám vždycky po ruce. 

TODO: Pokud budu implementovat EditableObject (jako že asi jo), tak
  ho nejspíš přesunout ze /shared do /editor

TODO: Zkontrolovat, že všude, kde něco dereferencuju, je to oifované
  (zejména v SaveableObjectu).

TODO: V SaveableObjectu sjednotit jména parametrů, aby to nebylo jednou
  'myProperty' a podruhé 'variable', když obojí znamená totéž.

TODO: Úplně se mi nelíbí, že fci entityManager.createUniqueEntity()
 (a asi i createEntity()) dávám jako parametr stringovou reprezentaci
 typu a za ní ještě typ.
 - asi by bylo lepší udělat dvojice fcí, jedna (createDynamicEntity()?)
   co dostane i string a druhá, která si vystačí s konstruktorem classy.
   - nebo možná dát string jako volitelný parametr (kontrolovat to uvnitř
     funkce).
Jo a při tý příležitosti bych asi mohl udělat statické fce, abych nemusel
chodit přes Server.entityManager....
  (a nebo se na to vyprdnout a dělat to naopak vždycky, tj. zrušit tu
  existující statickou zkratku)

TODO: Sjednotit návratové hodnoty: Když něco není nalezeno, tak nevracet
  null, ale undefined
TODO: Zrušit z entity proměnné SAVE_DIRECTORY

---------------

Úvahy o hot reloadu
  - nakonec asi bude nejjednodušší udělat si to růčo, podobně jako
    save/load. Nejspíš tak, že se po reloadu modulu vytvoří instance
    příslušné entity a všechny existující entity v game entity containeru
    si vždycky najdou svůj nový "prototyp" (nejspíše podle className),
    projdou všechny svoje properties (jdou projít i metody?), metody si
    přiřadí ty z nového "prototypu", existující property si nechají
    (možná zruší ty, které na novém "prototypu" nejsou) a přidají ty, co
    má nový "prototyp" navíc - zkopírováním, takže budou inicializované
    podle nového kódu.
  - reload proběhne automaticky, protože poběží watch na změny příslušných
    souborů.


------------------------------------------------------

Vyhledove rozbehat tslint

===============================================================================
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
===============================================================================

TODO: ClassFactory.createInstance() stačí jen jedna.
  - jednak může poznat, jestli je potřeba vytvořit prototyp
    nebo instanci
  - a za druhé mi asi nic nebrání vyrobit při startu prototypy
    i pro classy, které nejsou entity.
Potřebuju umět:
- createInstance() podle ClassName (i když je to entita)
- createInstance() podle idčka
createInstance() se podívá do class
- když nenajde, tak se podívá do idček
(obojí povede na prototyp?)
Tak ne - mapu id -> entity přece nepotřebuju, ta už je v EntityManageru.
=> to znamená, že v ClassFactory mi stačí držet className -> instance prototypu
Algoritmus pro init bude:
1) V DynamicClasses.init se budou rovnou vyrábět instance prototypu
   - tak ne. Protože potřebuju rozhodnout, jestli je to entita nebo ne.
   - takže tady se pouze nastaví konstructory class, prototypové instance
     se z nic vyrobí až v ClassFactory.initPrototypes().
2) V ClassFactory.initEntityPrototypes se přidají entity do EntityManageru.
Algoritmus pro createInstance() bude:
1) mrkni do ClassFactory.prototypes
2) pokud tam 'prototypeNameOrId' není, tak to ještě může být idčko, takže
   mrkni ještě do EntityManageru.
[done]
/*
ClassFactory.initPrototypes()
{
  if (isEntity)
  {
    let prototypeEntity = new Entity; // obecne new Class

    let prototype = EntityManager.createEntityFromPrototype
    (
      prototypeEntity,
      NamedEntity.Cathegory.prototypes
    )
  }
  else
  {
    let prototype = this.createPrototype(Class);
  }

  this.add(prototype);
}

public ClassFactory.createInstance(prototype)
{
  instance = Oject.create(prototype);
  instance.instantiateProperties();

  return instance;
}

public ClassFactory.getPrototype(className)
{
  return this.prototypes.get(className);
}

private ClassFactory.createPrototype(Class)
{
  prototype = new Class;

  return createInstance(prototype);
}

------------------------------------------

public EntityManager.createEntity(prototypeId, nameCathegory)
{
  let prototype = this.getEntity(prototypeId);

  let entity = this.createEntityFromPrototype(prototype, nameCathegory)

  this.proxify(entity);
}

public EntityManager.createEntityFromPrototype(prototype, nameCathegory = null)
{
  let bareEntity = ClassFactory.createInstance(prototype);

  bareEntity.setId(generateId());

  let proxy = proxify(bareEntity);

  if (nameCathegory !== null)
    setUniqueName(proxy);

  return proxy;
}

------------------------------------------

SaveableObject.loadCosi()
{
  className = loadFromFile();

  let prototype = ClassFactory.getPrototype(className);

  ClassFactory.createInstance(prototype);
}
*/

TODO: Kromě mapy id -> prototypeObject potřebuju ještě
      className -> prototypeObject
(Protože chci tvořit instance hardcoded entit z kódu a nemůžu jako parametr
 předávat idčko.)
- blbnu, to tam samozřejmě už je.
[done]

Jinak:
- nechci implementovat prototype chain v rámci hardcoded class.
  Když chci instanci přímo hardcoded classy, tak bych měl udělat
  (Object.create(new Class)).instantiateProtperties();
  - to způsobí, že se na prototypu nainicializuje všechno, co je hardcoded,
    a instance to bude korektně dědit díky Object.create()
    a instantiateProperties().
  - Díky tomuhle postupu můžu korektně udělat instanci libovolné hardcoded
    classy
    - není možné kombinovat hardcoded classu se savem, ale to je asi ok
      ... vždycky můžu z hardcoded classy zdědit prototyp a ten savnout.
Ok, teď už jen musím nějak zajistit, že se z hardcoded classy dá zdědit
  editovatelná classa.
  - problém je přejmenovávání hardcoded class, proto jsem chtěl idčka.
    Kdybych totiž hardcoded předka odkazoval jménem, při přejmenování
    bych musel změnit tenhle odkaz ve všech přímých potomcích (no, asi by
    to taky šlo...)
  - idčka bych asi mohl držet stranou, třeba v tvrdém savu EntityManageru
    nebo ClassFactory.
    - savovala by se asi mapa <id, className>.
    - a v initu by se vytvářely hardcoded prototype entity prostě jako isntance
      daných entit.
    - při vytváření editovatelného prototypu by se idčko předka hledalo nejdřív
      v harcodedPrototypes a pak v EntityManageru.
  - stále by zůstalo automatické dogenerovávání idček pro nové hardcoded
    classy.
Stále taky zůstává, že se do prototypové instance hardcoded classy savují
  idčka editovatelných potomků
  - to znamená, že v hashmapě musí být nějaký savovatelný record.
[snad done]

TODO: V createEntity() bych asi přece jen měl dělat dynamickej typecast
- už proto, že když vyrábím entitu z hardoced prototypu, tak tu classu
  stejně předávám...
- možná by šlo vždycky předávat classu (typecast) a dát prototypeId jako
  nepovinnej parametr
  - tzn. by se vzalo typeCast.name, pokud by prootypeId bylo 'null'.
[done]

TODO: Fci EntityManager.createEntity() dávat jako parametr 'prototype'
  přímo classu místo jejího jména, tj. createEntity(Account) místo
  createEntity('Account').
  - interně se pak přečte Class.name.
- bude se teda muset testovat, jestli 'prototype' je string, ale to je
  snad ok.
Výhoda: Typescript to zvaliduje.
- ještě možná jinak: Co mi brání použít jako klíč hashmapy přímo class
  constructor, tj. Account místo 'Account'?
  Díky tomu nebudu muset extrahovat Account.name...
Tak ne, to nejde - protože hashmapu přiřařující idčka classám potřebuju
  savovat, tudíž klíč musí být strinové class name.
[tak nakonec jinak - když není uvedeno prototypeId, prototyp se bere
 z parametru 'typeCast']

TODO: Zrušit automatické updatování referencí
  (místo toho si user musí vzít novou referenci:
    if (!entity.isValid())
      entity = EntityManager.get(id);
- Zrušit pole proxyhandlerů v EntityRecordu
Co si potřebuju pamatovat?
- určitě proxy, protože tu vracím, když někdo chce entitu
- a určitě proxyHandler, protože tomu nastavuju .entity na null,
  když smažu entitu.
=> stále potřebuju EntityRecord
[done]

TODO: EntityManager.getPrototype() asi nebude dobře
- a stejně tak i EntityManager.loadEntityFromJsonObject(), ze které se volá
(správně bude asi ClassFactory.getPrototypeObject()).
- zrušeno
[done]

TODO: getPrototypeObject z EntityManageru zrušit.
- místo toho zavolat rovnou getPrototypeObject z ClassFactory a z ní
  volat EntityManager.get().
[done]

TODO: Možná by mohlo jít přes invalid referenci získat valid referenci
  nějakou fcí:
    character = character.getCurrentReference();
    // Mělo by se to jmenovat getNěco(), aby z toho bylo jasné, že
    // je výsledek třeba přiřadit.
(Aby se ve skriptu nemuselo psát EntityManager.cosi)
- Úplně ideálně by se to mělo volat v opačném pořadí, tj. takhle:
  character = character.getCurrentReference();
  if (!character.isValid())
     return;

TODO: EntityManager.loadEntity(id: string)
- vykašlat se na trapčení s vytvářením invalid reference a následným
  loadováním.
Ono to asi v podstatě existuje, jmenuje se to loadEntityById().
- asi by to šlo přejmenovat na loadEntity().
--- konfliktí to s funkcí loadEntity(), která se volá z load() handleru
    proxy 
- a každopádně by to mělo být public.
/*
  ÚVAHA:
  Chci entity.save()?
  - určitě ano (ale to s loadováním nesouvisí).
  Chci entity.load()?
  - asi by se to hodilo třeba v případě, že bych měl referenci na playera,
    který mi quitnul - při znovupřipojení bych mohl chtít na tuhle referenci
    zavolat prostě load().
  - na druhou stranu co mi brání udělat 'character = loadEntity(id);' ?
  - ta první varianta (character.load()) by obnovila funkčnost ostatních
    existujících referencí...
   
  Každopádně to ale znamená, že nepotřebuju žádné 'createInvalidreference()'.
  - když referenci nemám, tak zavolám prostě loadEntity().
*/
TODO:
- Prozatím zrušit load() trapu z EntityProxyHandleru
- Zrušit starou fce EntityManager.loadEntity() a udělat z ní novou loadEntity()
- možná starou loadEntity() přejmenovat na onLoadTrapHandler()
[done]

- entity.load() použitá na the root prototype entitu jako prototype
  použije 'new Entity'.
[tohle už je jinak]


TODO: loadAccount v AccountListu a loadCharacter v CharacterListu
  jsou téměř totožné fce - nějak to sjednotit.
[done]

TODO: To, že se player disconnectuje přes connection.quitGame(), není
  zrovna intuitivní. Mělo by se to dělat přes connection.disconnect()
  (nebo close()).
- zavírat přes connection.close().
[done]

TODO: Rename named entity - musí přesavovat soubor v /data/names
 - viz class NamedEntity
[snad done]

TODO: V class Entity:
  - setId() by mohlo checkovat, že id je null a nepovolit setnutí, pokud není
    (tzn. id by bylo "write once").
[done]

TODO: Za všechny message přidávat defaultní "ukončovací" barvu
- a to proto, že tak bude obarven player input (a ten by asi měl
  mít vždycky stejnou barvu).
[done]

TODO: World má sice reference na vybrané entity, ale ty entity v něm
  nejsou vložené (respektive Realmy v něm nejsou vložené, ten zbytek
  zas rekuzivně do svého nadřazeného konteineru), takže se nesavujou.
[done]

TODO: Možná založit classu na unikátní jména - UniqueNames
  - bude umět checknout existenci souboru v příslušném adresáři
  - bude mít enum s kategoriemi (v NameSearchListu to fakt není
    moc intuitivní).
[done]
TODO: Někde se checkuje unikátnost jmen -> přesunout to do classy
  UniqueNames
- V character listu se to checkuje (metodou existsSync()).
[nakonec je to jinak, dělá to přímo NamedEntity]

IDEA: vykašlat se na flagu isNameUnique, savovat pouze cathegory.
- když je cathegory null, jméno není unique.
[done]

TODO: Možná unikátní jména dávat do adresáře /data/names/
[done]

TODO: SaveableOject, bufferování requestů
  - mělo by to být tak, že saveToFile() se vrátí až poté, co je skutečně
    savnuto (a ideálně poté, co je savnut její request, ne až když se
    dosavují úplně všechny, co přišly v průběhu savování).
- jak to udělat?
IDEA: Každy si savne svůj vlastní request (a jen ten jeden).
- pokud je nějaký request v bufferu, tak musím dát do fronty
  svůj resolve callback, abych dostal slovo, až na mě dojde řada.
CONSIDERATION: Deduplikovat requesty ano, ale pouze ty, které se
  ještě nezpracovávají. Aktuálně zpracovávaný request je třeba zopakovat,
  kdy přijde ten samej, protože se mezi tím mohou změnit data, která se
  mají savnout.
IDEA: Možná by se save procesy měly registrovat globálně. Teď spoléhám
  na to, že se každý SaveableObject savuje do jiného souboru, ale to nemusí
  být 100%
ALGORITHM:
1) Checknu, jestli je cílový soubor v globálním registru právě savovaných
   souborů.
   - pokud ne, tak se zaregistruju, savnu, odregistruju.
   - pokud ano, musím svůj request přidat do globálního bufferu
     (deduplikace, ale pouze u requestů, které se ještě nezačaly savovat)
globální saveProcessBuffer bude hashmapa.
  klíč: savePath
  value: true/false? Možná taky odkaz na následující save proces.
[done]

TODO: Použít classu Reference na savování entity referencí.
[done]

IDEA: classu MapRecord přejmenovat na Hashmap.
- možná něco podobného i s Date record... (ale co?) DateObject?
- DateRecord asi nakonec není úplně zlé (když to Date být nemůže).
[done]

TODO: Na savovaní Entity Reference taky udělat samosatnou classu.
  (jako DateRecord nebo MapRecord (asi Reference?)).
[done]

IDEA: classy Map a Date by se asi neměly do JSONu savovat přímo svou
  primtivní reprezentací (tj. string, respektive array), ale jako Object
  s nějakou className).
Důvod: Půjdou pak loadnout i do null proměnné, protože typ půjde poznat
  z JSON objectu.
[done]

TODO: Sjednotit metody TelnetSocketDescriptor.normalizeCRLF
  a Message.normalizeNewlines (asi do Utils)
[done]
TODO: Sjednotit taky konstantu NEW_LINE
[done]

TOODO: Vyházet debugovací spam z logu.
[done]

TODO: Message by asi neměly začínat na '\n'
  - odřádkování by se mělo řešit v Message.compose().
[done]

IDEA - jak řešit MOTD:
  - metoda getMotd() prostě jen vrátí obarvený string s motd,
    který se pak z různých míst pošle různě.
    - hra ho pošle jako Message.Type.COMMAND
    - AuthProcessor za něj (nebo možná před něj přilepí) last login info
      (taky getLLI() a taky pouze string) a pošle to celé jako
      Message.Type.LOGIN_INFO
[done]

TODO: Z enmumů v AuthProcessoru, LobbyProcessoru a možná i Connection
  vyhodit hodnotu INITIAL a místo ní používat 'null'.
[done]

TODO: Možná by stálo za to přesunout MessagePart.Type do Message a říkat jí
  Message.Type a původní MessageType přejmenovat na Message.Cathegory.
  - sice to bude trochu matoucí v rámci implementace MessagePart a Message,
    ale bude to možná dávat vštší smysl při použití zvenku (a hlavně bude
    stačit includovat Message).
A nebo se na MessagePart vykašlat úplně.
  - což dává smysl i vzhledek k pojetí base color, kdy je to první barva
    v odesílaném packetu a vztahuje se na celý packet (každý message se nakonec
    odešle jako celý packet).
  => odpadne mi separátní obarvování exitů a tak.
- MessagePart je komplet zrušeno.
[done]

ÚVAHA: Potřebuju vůbec k něčemu MessageType? Teoreticky na filtrování
  celých messagů, třeba jestli chci vidět gossip.
IDEA: Udělat to šalamounsky:
- Základ bude MessagePart.Type
  - tady budou všechny možný typy message partů
- Message.Type budou:
  - buď celé kategorie jednopartových messagů (např. COMMUNICATION)
  - nebo jednotlivé vícepártové message (třeba who)
- nakonec je to všechno v Message
[done]

TODO: Barvy messagů přesunout do nějaké samostatné struktury, ideálně
  i do samostatného modulu (MessageColors.ts).
  - pořád se budou indexovat message typem
  - getovací metody, dostanou messageType a coloredSectionType
    ("base", "quotes", etc.)
    - zaindexuje to message typem, checkne to, že existuje property
      příslušného jména, vrátí to barvu (nebo defaultní barvu, když něco
      failne).
[done]

TODO: Šaškování s promptem přesunout z Connection do Message.
- bude se vůbec nějakej message posílat jinak než jako prompt?
  - multipart message totiž asi řeší kusy, které se jako prompt neposílají.
[done]

TODO: Zrušit color kódy z AUTH_PROMPT messagů, přidávat je až v classe
  Message.
  - částečně done. Z messagů jsou zrušeny, ještě se ale nepřidávají
    v Message (respektive MessagePart.format().
KE ZVÁŽENÍ:
  Tohle je ve skutečnosti otázka. Určitě nepůjde obarvovat komplet všechno
  až uvnitř Message, to by se musely používat nějaké symbolické názvy barev
  (což by teda šlo, třeba něco jako <color:TELL.quotes>). Pokud ale budu
  stringy obarvovat tam, kde se vyrábí (a brát si barvy z MessageColors),
  tak pak moc nedává smysl přidávat base color až uvnitř Message (i když,
  ušetří to obarvování syslogu a podobných jednobarevných messagů, takže to
  asi smysl má, hmm...)
OK, asi to nakonec nechám tak, jak to mám. BASE color se bude přiřazovat
  automaticky v Message, interní barvy se budou dávat do stringů tam, kde
  se vyrábí stringy.
  - potom ale nepůjde přebarvit už jednou vyrobený string podle nového barevného
    schématu, hmm.
  - když bych někdy chtěl dělat lokalizaci, tak barevné kódy (ať už přímo
    kódy barev nebo nějaké symbolické varianty) budou muset být součástí
    překladových stringů. Na druhou stranu překladové stringy je taky třeba
    nějak skládat do sebe a ty skládací algoritmy musí být v kódu, takže
    možná dává větší smysl mít barvy jako součástí těch skládacích algoritmů
    a za překladové stringy pokládat ty malé jednobarevné kusy, ze kterých
    se message skládá...  
[done]

TODO: Zautomatizovat přidávání mezery za prompt mesage.
  - asi v Message.composeRawMessage().
[done]

TODO: Connection bude mít public metodu send(), která bude jako parametr
  chtít Message (aby se nedalo volat connection.send() přímo).
  - ta pak zavolá message.getRawText().
[done]

TODO: Asi přejmenovat MessagePart.format na MessagePart.addBaseColor()
[done]

TODO: Zavést color code pro message_base_color (aby se dala měnit barva
  celé zprávy s tím, že to zachová barvu zvýrazněných slov).
[done]


TODO: Syslog by se měl posílat charům (které na to mají admin level)
[done]

TODO: Řešit jinak single-part a jinak multi-part message, minimálně
  teda při vytváření. Volat na single-part messagi extra addMessagePart()
  je opruz.
  - asi to oiffovat v konstruktoru, že parametr 'text' je volitelný.
    (nebo možná volitelný parametr messagePartType).
- hlavně bych chtěl vyhodit partType SAME_AS_MESSAGE, což bych asi udělal
  přesunem textu u jednopartového message přímo do message. Ale pak by mi
  zas chyběla metoda format(), hmm. 
[done]

TODO: Static metoda Server.getAdminLevel();
  - metoda serveru a ne entity, aby si ji entita nemohla predefinovat
    a vracet creatora ;-)
[done]

TODO: Visibility dává smysl jen u sendToAllIngameConnections
[done]

TODO: class Admins by se asi měla jmenovat spíš AdminList.
[done]

TODO: Je dobrý nápad nastavovat messagi target?
- možná by bylo lepší prostě zavolat příslušnou metodu
  (sendToConnection(), sendToGameEntity(), sendToAllInRoom(),
   sendToShoutingDistance(), sendToAllInGame(), SendToAllConnections()).
  - v těhle funkcích se pak případně může zapamatovat, komu jsem to
    posílal a tak.
[done]

TODO: Kdo bude sender u Syslog messagů? Standardní message se filtrují
  podle visibility sendera...
  - možná přiadat do sendu parametr reciever_level s defaultní hodnotou
    MORTAL?
    (možná jen do plošných sendů. "Tady máš message speciálně pro tebe, ale
     nemůžeš si ho přečíst, protože na to nemáš admin level" je asi blbost :-))
- sender bude null.
- visibility už jde messagům předávat (ale nekontroluje se ;-)).
[done]

TODO: Chekovat u messagů visibility.
[done]

TODO: Funkce Entity.send(sender, string) by přece jen mohla existovat,
  interně vyrobí Message a pošle si ho.
[done]

IDEA: Založit class Message
  // Asi by mel existovat nejaky anonymni sender (system? nebo world?)
  - sender
  // muze jich byt vic
  // nemusi byt inicializovane hned od zacatku
  - recipients
    // TELL, GOSSIP, SKILL, COMMAND
    // Podle typu se bude obarvovat a gagovat.
  - type
Proč?
  Protože si je pak můžu házet do bufferu (takže budu mít historii),
  a buffer různě zpětně filtrovat
message.send()
  - tj. nepoužívalo by se sendToChar() ani char.send(), ale vždycky
    message.send().
message.format()
  - něco jako act() na Brutusu
- Je fakt, že tímhle můžu dost šetřit paměť, nemusím mít u každého
  playera zkopírovnaé každé INFO, můžu to mít na jednom místě jako
  Message a v playerově messageHistory na něj mít pouze odkaz.
- budu se moct zpětně podívat, kdo psal message v době, kdy jsem měl
  blind (je teda otázka, jestli je to žádoucí featura, ale půjde to.
  Jo a taky je otázka, jestli by blind měl mít vliv na to, co SLYŠÍM ;))
  (I když vlastně já to slyším, jen nevím, kdo to řekl. No...).
[done]

TODO: Metoda Game.sendToAll()
  - to samé co u sendu (na druhou stranu info je asi vždycky info?)
  - možná ne Game.info, ale game.send(message, INFO);
  Pozn: Procyklovat přes všechny connection, nikoliv přes všechny herní
    entity (nemá smysl procházet entity, kterým se nic posílat nebude).
[done]

TODO: Metoda send()
  - nebude to sendToChar(), protože posílat string jde kde čemu, ne pouze
    charům.
  TODO: Zvážit, jestli by by to nemělo bejt nějak oflagované, aby se to
    podle toho dalo třeba gagovat nebo automaticky obarvovat.
    - asi určitě ano.
nakonec existují metody:
  sendToSelf()
  receiveMessage()
[done]

TODO: Možná parametr 'type' u Messagů přejmenovat na 'msgType'.
[done]

TODO: Syslog má nějaký msgType a Message má type. Možná by se to dalo Sloučit
  (pod Message.type, protože to je obecnější).
[done]

ÚVAHA: Má smysl pamatovat si seznam entit, kterým jsem poslal Message?
- Když mi lidi odejdou z roomu, tak posílat jim ten samý vzkaz (vázaný na room)
  už nebude dávat smysl...
- asi je to blbost, message se prostě pošle všem valid targetům v okamžiku
  volání message.send() a zapomatuje se jen co se posílalo, ne komu.
- Každý recipient si bude své message dávat do své vlastní historie, takže
  'this' bude recipient při jejím parsování.
  - pokud bych si chtěl pamatovat například visibilitu v okamžiku poslání
    zprávy, tak si ji musím uložit asi do té historie, mimo vlastní Message
    (protože Message je sdílený záznam pro všechny, kdo jej dostali).
TODO: Zrušit Message.recipients.
  - Komu se pošle tell? Na to se asi přece jen bude muset recipient nastavit.
[done]

TODO: Přidat do accountu seznam charů, které mají admin práva (nebo možná na
  char flagu, že má admin práva - checkne se this.playerConnection, přes ni
  account a na něm je adminLevel).
[Tohle bude jinak - pres classu Admins]

TODO: Charactery savovat na disk v lowercasu
  - ze dvou duvodu:
    1) aby neslo vytvorit soucasne char Zuzka a zuzka
    2) aby se slo prihlasit case-insensitive verzi
  - nebo se na to vykaslat a enforcovet Prvnivelke pismeno ve jmene charu?
    (Asi prece jen bude hezci, kdyz na disku budou chary savnute s velkym)
  - kazdopadne to case-insensitive prihlaseni by fungovat melo.
[Forcuje se Prvni Velke]

TODO: Zrušit automatické updatování invalid referencí.
  - automaticky se updatuje při volání isValid()
  - neupdatuje se při přístupu na ostatní properties.
[done]

TODO: class Admins (a ani EntityList) nemůže interně používat reference
  jako klíč v hashmapě, musí používat stringId. A to proto, že mohou
  existovat různé proxy odkazující na stejnou entitu, takže by se do seznamu
  mohla dostat jedna entita víckrát.
  - Admins jsou předělané (interně je klíč string id, metody si ho vytahují
    z reference na entitu).
  - EntityListu se to kupodivu netýká, protože ty už stringovým idčkem klíčují
    (reference na entitu je hodnota klíčovaná stringovým idčkem, což je ok).
[done]

TODO: Přejmenovat AdminLevels na AdminLevel
[done]

TODO: Na AdminLevels by asi fakt byl lepsi enum.
[snad done]

===============================================================================  

TODO: co se stane, když mi umře entita, na které běží async skript?
[to už by mělo být ošetřené]

TODO: Možná založit adresář /game/search a dát do něj AbbrevSearchLis.ts
  (časem by tam mohlo být vyhledávání v grafu místností, apod.)
[tohle zatím dělat nebudu]

TODO: Dodělat ClassFactory (zbývá Prototype a PrototypeManager)
[done]

TODO: Možná do ClassFactory přesunout i vytváření nových class (to je tuším
  v prototypu).
[done]

TODO: Přidat do /documentation soubor se seznamem používaných datových
  struktur a návodem k použití (Object, Array, Map, FastBitSet,
  FastPriorityQueue, Enum...).
[přidal jsem na to adresář]

TODO: Mudlog přejmenovat na Syslog a možná ho přesunout do /shared
- nechám ho v /server, protože bude posílat text online charům.
[přejmenováno]

TODO: Sjednotit názvy adresářů. Neměl by se jeden jemnovat characters
 (se 's' na konci) a druhej /entity (na druhou stranu /flags by asi mělo
 zůstat. I když...)
[flags zůstaly, zbytek je v jednotmém čísle]

TODO: Možná založit adresář /shared/entities a dát tam vše, co se týká
  entit
[done]

TODO: Možná založit adresář /shared/error a dát tam ERROR a FATAL_ERROR
[done]

TODO: Ještě jednou se zamyslet nad tím, jestli má smysl chybový výpis v apply()
  handleru InvalidValueProxyHandleru.
  - pravděpodobně nemá, navíc to pak spamuje při systémových voláních (výpis
  do konzole, util.inspect, apod..
[Asi tam fakt být nemá. Okomentováno]

TODO: V SaveableObjectu
  - operátor 'in' nefunguje na proxy, je třeba ho volat nad entitou.
  - to se týká i případu if ('saveIdToJsonObject' in variable)
[done] 

TODO: Vyzkoumat, proč se mi savujou skoro prázdný entity
[snad done]

TODO: TrimType.PROXY_HANDLER uvnitr get() by se mel trimovat jen o 4
[Snad done]

TODO: Přesunout EntityRecord do samostatného souboru
[done]

TODO: Jit trochu jinak na error messages:
  - Vsemu rikat ACCESS_VIOLATION a o co presne jde upresnit v doplnujicim
    message.
[done]

TODO: Poresit zacykleni pri vypisu stack trace pri invalid property accessu.
- a asi taky trimovani o jiny pocet radku nez pri ERRORu
[tak to uz zrejme necykli, nejspis jsem to necim opravil]

TODO: V abbrevSeachList.ts::170 se nejak divne maze z hashmapy.
[opraveno]

TODO: metodu dynamicCast() asi přesunout z EntityManageru do Entity.
[je presunuta do EntityProxyHandleru]

TODO: Otestovat, že prirazeni this opravdu priradi proxy
[Zda se, ze opravdu ano, uff!]

TODO: createSystemRealm() a všechno uvnitř.
[done]

ÚVAHA: Monžná se přece jen vrátím k classe Id (- nakonec ne)
  - ne proto, že bych se chtěl zbavit přímých referencí, ale proto, že když
    si někdo říká o entitu na základě stringového idčka, tak musí dodat i typ,
    aby šla vrátit invalid entity se správně nastaveným typem v handleru (aby
    pak podle něj šla vytvořit správná instance).
Na druhou stranu ale kdy by se tahle classa použila?
- jako dočasná proměnná při savování
- jako dočasná proměnná při loadování
Držet si ji nikdo nebude, protož držej se reference a tyhle informace jsou
  schované v handleru.
S tím souvisí:
- kdo bude potřebovat volat entityManager.get()?
  - asi to samé, pouze SaveableObject.loadReferenceFromJsonObject().
  nebo ještě někdo?
  - z nejěkých důvodů jsem tam chtěl ošetřit, když je "id" null
[Tak nakonec ne]

TODO: EntityManager by neměl vyčítat data z JSON objectu - to má dělat
  SaveableObject.
[přesunuto do SaveableObjectu]

TODO: metoda createInstance() by neměla být v SaveableObjectu.
  - místo toho by měla existovat Server.classFactory a na ní by měla
    být metoda createInstance().
TODO: Při té příležitosti do ní přeshnout i dynamicClasses, ať nestrašej
  v global objectu.
[done]

TODO: EntityManager.proxyHandler by mozna nemuselo bejt pole (ale mapa).
  - nakonec to bude Set
[done]

TODO: Vytvořit modul EntityManager (again ;-))
TODO: Konstruktor Entity by měl vracet Proxy.
  IDEA: Konstruktor Entity bude vracet 'new Proxy()', takže nejpůjde mít
    nezaproxynovanou entitu.
TODO: Sebrat IdProvideru funkcionalitu na trackování idček.
  [done]
TODO: Předělat IdListy na EntityListy.
TODO: Ošetřit savování referencí na entity v SaveableObjectu.
  - musí se savnout Id záznam místo entity.
  - při loadu se zase jen načte Id záznam
    - možná to bude znamenat, že entity proxy musí umět ještě jeden stav
      (kromě entity = null). Nebo možná prostě jen pamatovat si idčko
      (protože EntityProxyHandler teď vlastně slouží jako původní class Id).
TODO: Přetypovat idčka z Id na string.
[některé věci jsou jinak, ale v zásadě done]

TODO: Odchytavat pristup na neexistujici property.
[done]

Pozn.: Accounty se mi savují postaru do /Accounts/Rahman.json, což je nakonec
  asi dobře. Každopádně to chce zkontrolovat.
[snad ok]

TODO: Opravit savovani entit.
[snad done]

TODO: Opravit AttributableClass
  - protože super.metoda dělá něco trochu jiného, než jsem si myslel
    (nevolá metodu přímého předka, ale toho předka, který ji jako první
    má jinou. Tzn. to může přeskočit několik stupňů dědění. A já je
    v AttributableClass potřebuju projít všechny).
  - toť otázka. Není to náhodou tak, že se mi ta statická proměnná
    automaticky zdědí, takže ji prostě uvidím na this.constructor, ať
    je deklarovaná na jakémkoliv předkovi?
    - v tom případě tam naopak šaškuju zbytečně složitě...
[Hmm, tak zjevně jsem to dělal zbytečně složitě.]

TODO: Opravdu to udělat, zní to rozumně.
BIG IDEA: Zuršit ASSERTY.
  Místo toho používat:
  //
  if (condition === false)
  {
    ERROR
    (
      "message"
    );
  }
  //
  - Ve skutečnosti stejně ty asserty píšu vždycky do podmínek a navíc ten
    zápis if (!ASSERT(condition, "message")) není moc intuitivní.
  - vyřeší to problém s tím, že se mi provádí kód na skládání stringu,
    přestože string není potřeba.
[done]

TODO: Korektne vycistit SaveableObject od pozustatku EntityId.
  (protože EntityId nemůže být includnuté v SaveableObjectu, byl
   by to křížový include (nebo je z něj zděděné). On to sice typescript
   compiler povolí, ale zuchne to pak v runtimu).
[done]

TODO: Asi se fakt vrátnit k Id místo EntityId.
[nakonec to je úplně jinak]

IDEA: Přesunout fci getTrimmedStackTrace do modulu Mudlog a zrušit UTILS.
[done]

TODO: Specialni kod na loadovani idcek musi byt primo v SaveableObjectu,
  ne az v Entity. Sice jen Entity muze mit idcko, ale to neznamena, ze si
  nekdo nemuze vytvorit SaveableObject, do ktereho si da idcko na JINOU entitu.
[done]

TODO: Zavest pocitadlo rozdanych referenci v IdManageru
  - kdyz klesne na 0, tak je mozne idcko vyhodit z manageru.
- Tak jinak, misto toho idProvider drzi idcka ve WeakMape
[Nakonec je to úplně jinak, ale done]

IDEA: Idcko se automaticky zaregistruje v IdManageru, pokud jsou parametry
  konstruktoru definovane.
  - diky tomu se mi nestane, ze by si nekdo vytvoril idcko (pres new EntityId)
    a nevlozil ho do IdManageru (jako se mi povedlo s WorldId).
  - ono se mu to teda asi nepovede ani tak, kdyz bude idProvider schovany
    uvnitr IdManageru. Ale takhle aspon usetrim kod, ktery se stejne musi
    vzdycky provest.
[asi done]

TODO: protected -> private v EntityId
[done]

TODO: Nastavovat idčkům status.
[snad done]

TODO: V SaveableObjectu sjednotit fce isPrimitiveObject, isDate, atd.
      - pokud bude fungovat .constructor.name, tak používat to.
[done]

TODO: Všude po volání entityId.getEntity() dát check na to, že result
      není null.
      (entityId.getEntity() může vrátit null. Dereference by pak shodila hru)
[už je to úplně jinak]

IDEA: Sloučit AbbrevSeachList a IdSearch list do jedné classy
      (AbbrevSearchList prostě bude zděděnej z IdListu)
      Přidat classu NameSearchList (zděděnou z IdListu)
[done]

TODO: PlayerConnection přejmenovat na Connection
      a Server.playerConnections na Server.connections
[done]

TODO: V Server a Game oddělit managery od idListu a dát k tomu komentáře,
      čím se to liší.
[done]

TODO: IdList přesunout do /shared
      (IdSeachList asi taky)
[done]

TODO: Všechny XXXManager přejmenovat na XXXList a zdědit je z IdList nebo
      IdSearchList
      - nebo ještě druhá možnost, místo AccountList prostě Accounts
      (ale asi raději AccountList, Accounts je divné jméno pro classu)
TODO: Všechny xxxList přesmenovat na xxxs (characterList na characters).
TODO: EntityContainer přejmenovat na EntityManager
      (bude z toho jasnější že je jen jeden)
TODO: Container přejmenovat na ContainerEntity
[done]

Obecně se držet schématu:
- Manager obsahuje přímo instance
  - EntityManager obsahuje entity (což jsou instance)
  - FlagNamesManager obsahuje instance FlagNames objektů
  - PrototypeManager obsahuje instance Prototypů
  - List obsahuje idčka
[v zásadě done]

TODO: Přidat classu IdSearchList a přesunout do ni abbrevSearchList z IdListu.
[done]

TODO: game/EntityContainer přejmenovat na něco jiného
      - buď EntityIdContainer
      - nebo GameEntityContainer
      - nebo prostě Container?
Nebo možná raději přejmenovat /shared/EntityContainer na EntityManager?
[done]

TODO: Pokud budu managery dědit z idListu, tak to udělat
      i s PlayerCharacterManagerem
[done]

TODO: Přesunout NamedEntity do shared
  (a možná i další classy).
[done]

TODO: Id přejmenovat na EntityId (a classu EntityId zrušit).
  - tohle si asi ještě rozmyslím... I když...
[done]

TODO: Výhledově dát 'dynamicClasses' někam jinam než do global objectu.
  - asi do serveru
TODO: Výhledově nějak líp pořešit dynamické classy než přes dynamicClasses.ts
  (možná všechny moduly requirovat místo importovat?)
[done]

TODO: S loadováním/savováním hashmap jsem se, zdá se, radoval předčasně
  - opravit loadování SaveableObjectů uložených v hashmapě.
[snad už ok]

TOFIX:
ARGH - directReference v Idckach je udelana spatne :\
  - dokud vsichni odkazuji na Idcko, ktere si drzi samotna entita,
  tak je to asi ok. Ale muze se stat, ze si nekdo vytvori vlastni
  instanci Id - třeba po loadu ze souboru. V ten moment se to rozbije,
  protože neexistuje jediná instance Idčka pro danou entitu...
Jak to spravit?
  - instance Idček asi budou muset být v příslušném containeru spolu
    s entitama. Takže (i při loadu) si nebudu nikdy vytvářet vlastní Idčko,
    vždycky si budu muset říct containeru, aby mi Idčko vyrobilo
    (já mu dám stringId a on mi buď vrátí referenci na existující instanci Id,
    nebo si ji vyrobí...)
[je to celé jinak]

TODO: entity.stopScript(scriptName);
TODO: entity.stopAllScripts();
- musí to vycházet z entity, ne ze Skriptu
[idea has been dropped. attachovat/detachovat scripty na entity nebude možné]

TODO: Skripty v Prototypu dávat do hashmapy místo do pole (protože bude třeba
  umět skript najít například při 'edit TutorialRoom.onLoad');
[done]

TODO: Do Script.code dávat jen tělo funkce. Hlavičku funkce a {} tam přilepí
  engine.
[done]

TODO: Změnit odkaz na prototyp ve Scriptu na jméno prototypu.
[done]

TODO: Otestovat skripty
  - ukládání do souboru [done]
  - zkompilovat a pustit dva různé skripty [done]
  - rekompilace běžícího skriptu [done]
[done]

TODO: Naucit SaveableObject savovat a loadovat obycejne objekty.
- ono by to v zásadě mohlo být ok, pokud je to dynamická classa a má
   className, tzn. by ji bylo možné instanciovat. Ale to už rovnou můžu
   trvat na tom, aby to byl SaveableObject.
[Aha, on už to umí. Odmítá savovat jen classy, které nejsou obyč Object
 a nejsou zděděné ze SaveableObjectu, což je asi dobře.]

TODO: Nahackovat savovani staticke property 'className'
[done]

TODO: Ještě přece jen zvážit, jestli nepoužívat nepojmenované classy
  (tj. že Class.constructor.name bude "") a nedávat jim className jako
  moji vlastní property.
  - ono to celkem dává smysl, protože to prostě nejsou statické classy.
[budu používat nepojmenované classy]

TODO: Změnit NamedClass, aby className nebyla property na instanci,
  ale statická property (tj. na constructoru).
[done]

TODO: Zjistit, jestli by classDeclarationScript nemohl byt zkompilovany
  jen jednou (a brat si parametry ze sandboxu).
[pokud mi bude fungovat vyrábění class bez skriptu, tak tohle nebude potřeba]

TODO: Ucesat Prototype.setMethods()
[done]

TODO: assert na internalFunction !== null
[done]

TODO: Testnout, jestli můžu z jednoho sandboxu vyrobit dvě skriptové funkce,
  které budou mít různé skriptName.
[done, nemůžu]

TODO: Instance savovat do /data/instances
[snad done]

TODO: Zkontrolovat, ze jsem Flags-related classy prejmenoval spravne
[snad jo]

TODO: Presunout flagNamesManager ze Serveru do Game
 - asi to nebyl dobrej nápad, protože když bych chtěl mít account flagy,
   tak nebudou fungovat bez toho, aby existovala hra.
   - nejspíš to budu muset přesunout zpět.
[done (přesunuto zpět)]

TODO: Projít nově vytvořená data a opravit všechny chyby
[done]

TODO: Při savu Map objectu je vždycky první prvek 'undefined'
[fixed]

TODO: Přejmenovat FlagsData na FlagData a FlagsDataManager na FlagDataManager
[done]

TODO: Promyslet a zkontrolovat, jak SaveableObject pracuje s null hodnotama
- nejspíš je tam navíc ten ASSERT, kterej to kontroluje, null už by to mělo
  zvládat (buď se vytvoří objekt správného typu, nebo se přímo přiřadí hodnota
  loadnutá z JSONu)
[done]

TODO: Možná mám někde zbytečně metody save() a load()
  - jsou v IdableSaveableObjectu (takže pokud je něco zděděné přímo ze
    saveableObjectu, tak to tyhle metody nemá.)
[snad done]

TODO: Zacina bitvector od nuly nebo od jednicky? Zjistit.
[zjevne od nuly, takze to mam spravne]

TODO: Loadovani/savovani classy 'Map' v SaveableObjectu
[snad]

TODO: Adresářová struktura prototypů (a asi i v rámci PrototypeDataManageru)
[snad done]

TODO: Když neexistuje adresář /data, tak vytvořit defaultní flagsData
  a prototypeData
  - respektive možná bude stačit ve flagsDataManageru hodit loaded flagu
    na true, aby se flagy vytvářely samy...
[asi ok]

TODO: Nekam naimplementovat metody setPrototypeData() a setMethods() :-)
- nekam do GameEntity chainu, asi na urovni /shared.
 (Nakonec jsou v PrototypeData, protože je to potřeba setovat zvenku do 
  class_constructor.prototype)
[Zatím je jen setPrototypeData()]
TODO: setMethods()
TODO: Skripty
[done]

TODO: V PrototypeData doplnit typ k predavanym typum (ja vim, zni to divne...)
[Jakz takz, nekde jsem neprisel na to, jak na to]

TODO: Hodit ASSERT_FATAL do samostatneho modulu (a fci getTrimmedStackTrace()
  taky, aby se dala includnout z obou assertu).
[done]

TODO: PrototypeData a PrototypeDataManager presunout do /shared
[done]

TODO: Zvážit, jestli nedávat dynamické classy (repsketive jejich konstruktory)
někam jinam než přímo do global objectu (asi do global.dynamicClasses ?).
[done]
TODO: Popravdě možná spíš pod server, nebo tak něco... Těžko říct.
[done]

TODO: Zrušit prefixy z flagů.
[done]

TODO: vsechna createNew asi prejmenovat jen na create (když něco vytvářím,
  tak je jasné, že to bude nové).
[done]

TODO: Přidat do SaveableObjectu savovani classy Map.
  (Ono to možná funguje samo, chce to každopádně zkontrolovat.)
  - tak samo to opravdu nefunguje
[done]

TODO: implementovat flagy (bitvector engine).
[done]

TODO: Udělat vlastní FS modul, ať jsou všechny souborové fce na jednom místě.
[done]

TODO: Nastavovat entity.location (kdyz entitu vkladam do nejake jine).
[Snad done (mozna ne vsude)]


IDEA: Udělat z IDčka generic - id.getObject() pak vždycky vrátí správný typ.
[Tohle nepůjde]
- místo toho id.getEntity() dělá dynamický typeCasting.
[done]

TODO: predelat vsechna idcka v savech na EntityId
- to asi pořeším tím, že vyrobím celý svět znovu.
[done]

TODO: Pri vytvareni noveho sveta generovat mistnostem nejake defaultni
  RoomInfo.
  (A to asi tak, ze se pri vytvareni nove rommy vytvori automaticky, pokud
  konstruktor nedostane jako parametr template - nebo mozna dve funkce, jedna
  na vytvoreni templatove roomy a druha na vytvoreni odvozene roomy?)
/* Predelavam cely koncept prototypu, takze tohle bude cele jinak */
[je to jinak]

TODO: Idcka dostala přímou referenci na odkazovaný objekt
  - při vytváření objektu je třeba tuhle referenci v idčku inicializovat
    (je to parametr constructoru)
  - a při mazání objektu (odebírání ze seznamu objektů) ji zase invalidovat.
[snad done]

TODO: V AbbrevSearchListu nahradit prime odkazy na GameEntity Idckama (idcko
  ma ted v sobe primy odkaz, takze to nebude vyrazne pomalejsi).
[snad done]

TODO: Zprovoznit resolvování aliasů složených z více klíčových slov
   v AbbrevSearchListu:
   - Dám do něj jednotlivě všechna klíčová slova z alias listu.
   - Při heldání je všechna matchnu, čímž dostanu n polí se seznamem entit
    "slyšících" na dané jméno. Ty následně projdu a vytvořím seznam idček,
    které se nachází ve všech těchto polích.
[snad done, zatím netestováno]


TODO: Vsude doplnit metodu getErrorIdString() a dusledne ji pouzivat v
  chybovych hlaskach.
[done]

TODO: Checkovat, ze loadnute id odpovida idcku, podle ktereho jsem
  entitu naloadoval.
  (a taky ze id odpovida nazvu souboru, pokud entita neni unikatni)
[snad done]


TODO: Zautomatizovat protopyování - asi by to měly umět všechny gameEntity
minimálně do té míry, že si budou držet odkaz na prototyp (idčko) a budou
automaticky prototypovat 'name'.
[tohle je jinak]


---------------------------------------

TODO: Upravit LobbyProcessor, aby prompt posilal pres generatePrompt()
[done]
- Pro AuthProcessor to neni dobrej napad, vedlo by to ke spouste internich
  stavu
[done]

TODO: v metode PlayerConnection::generatePrompt()
/// TODO: switch na stage lobby processoru by mel byt v LobbyProcessoru
[done]

TOFIX: Asserty pri connecteni z ruznych terminalu
[Co jsem vedel tak fixed]

TOFIX: Stalo se mi, ze jsem se pripojil, jeste nez se neco zinicializovalo,
  takze jsem nedostal menu.
  - a uz asi i vim, jak se mi to stalo: Nalogoval jsem az do hry a zabil
    putty (zavrel connection), nasledne jsem se pokusil znovu prihlasit.
  - bude to nejspis tim, ze zatim nemam implementovane korektni zavreni
    connection, kdyz player shodi connection, zatimco je ve hre.
    (viz PlayerConnection::close(), prvni vetev ifu)
[nejspis fixed]

TOFIX: Kdyz naloguju, vlezu do hry, quitnu a zatimco jsem v menu, tak se
  priloguju pres novou connection, tak to do logu vypise:
  "Player Rahman [::1] closed connection before logging in" 
  - zrejme se pri quitu ze hry neco nenastavi spravne.
- asi je spatne jen hlaska. Je spravne, ze je account null - byl setnuty
  na null proto, aby ho connection neodlogovala (protoze jde o reconnect)
  Ve fci PlayerConnection::onSocketClose() by mel byt switch podle
  stage lobbyProcessoru, ne jen test na to, jestli je je account null.
Pozn.: stage lobbyProcessoru bych nemel switchovat v metode PlayerConnection,
  mel bych na to udelat metodu v lobbyProcessoru.
[fixed]

TOFIX: Kdyz si uzurpnu connection, tak se nezavre
[fixed]

TODO: stage ve vsech managerech predelat z intu na stringy, at je pri
  debugovani videt, co je to za stage.
[done]


TODO: fixnout SYSTEM ERRORY, ktere vznikaji tim, ze se spusti 'onError'
event po zavreni connection
- mozna se to vyresi, kdyz pri zavirani socketu odstranim listenery
  na data:
    socket.removeAllListeners('data');
- tak ne.
[snad fixed]

TODO: Zprovoznit start z neexistujicich dat
(musi se vytvorit world, v nem 1 realm, v nem 1 zona, v ni 1 room)
[done]


TODO: Opravit barvy
[done]

TODO: loadovani a savovani obyc objektu (nezdedenych ze SaveableObject)
- kdyz objekt nema loadFromJsonObject, tak do nej proste priradit to, co se
  loadnulo z jsonu.
- tohle je potreba kvuli loadovani Date objektu.
- nebo mozna rozpoznavat, ze jde o Date object, tezko rict. Tohle prirazeni
  by mohlo vest k tomu, ze objekt nebude mit vsechny properties, ktere by mel
  mit.
  - asi by bylo lepsi detekovat, ze to je Date object...
[done]

TODO: Misto this.isSaved pri loadu/savu checkovat
  ClassAttributes.getAttribute(className, property, attribute);
[done]

TODO: Poresit radkovani pri posilani menu
/*
  Kdy se vypisuje menu:
  - pri nalogovani do hry
      (to jde tesne po prikazu a musi byt odradkovane)
      - tady by ve skutecnosti melo byt nejdriv MOTD a po nem "Pres return"
  - pri quitu ze hry
      (to jde po bloku textu, nema byt odradkovane, protoze odradkovani zaridi
      engine)
  - invalid option v menu (vypise se znovu jako prompt)
      (odradkovane ma byt v tomhle pripade "That's not a menu choice, takze
      menu jde opet po bloku jako prompt)
*/
[snad done]

TOFIX: Ponastavovat isSaved = false vsude, kde je to potreba
[snad done]

TOFIX: abbrevSearchList by nemel byt case sensitive
[done]

TOFIX: Do abbrevSearchListu se ocividne nedava posledni prvek
- a naopak se tam dava i prazdny string
[done, fixed]

TOFIX: Prvky v poli ocividne savuji saveRequests property
[tak prvky v poli se savovaly spravne, chyba byla v hashmape, coz je obyc
 Object]

TODO: Za prompt pridavat mezeru (aby byl player input od promptu oddeleny)
[done]

TODO: Fixnout "Invalid prompt >" pri "That's not a menu choice!"
[fixed]

TODO: Nejspis budu muset zrusit zrani newlinu na konci inputu, holt si to
  koderi budou muset hlidat sami. Bude to potreba na to, abych na patricnych
  mistech vyrobil vicenasobne odradkovani.
/*
  - mozna by se to mohlo kontrolovat v ramci sendAsBlock(), tj. kdyz to konci
  promptem. Tam se mezi prompt a blok automaticky prida mezera (pokud player
  nema brief mode) a asi nikdy nebude hrozit, ze by tam mely byt dve.
  - tohle by asi mohlo i stacit, btw. Drtiva vetsina herniho outputu bude
  rozhodne posilana jako blok (urcite sendToChar(), urcite act()).
*/
/*
  Tak ne, je to blbost. Po bloku bez promptu stejne nasleduje newline a po
  promptu naopak logicky byt nesmi, jinak by hrac psal na novou radku misto
  na stejnou.

  Ve skutecnosti je nekde potreba newline pred outputem, protoze je treba
  odradkovat po odeslani prikazu, a to se jinak udelat neda.
*/
[rozhodnuto: Newliny na konci outputu se zerou, je povolena newline pred
outputem - pouziva se na oddeleni outputu od player commandu]

TODO: Poresit barvu player inputu
/*
  Zjevne se pise barvou, kterou naposledy poslal mud.
  - tj. asi by to chtelo na konec kazdeho stringu prilepit &w.
*/
[done]

TODO: Poresit automaticke radkovani prikazu.
/*
  Uvaha: Za odradkovavani VZDYCKY zodpovida engine, tj. zadny send_cosi() prikaz
  nesmi koncit enterem
  - tohle mozna enfocnout v kodu - ASSERTEM a tim, ze se pripadny enter
    automaticky odstrani.
  - povolene jsou pouze entery uvnitr stringu, pokud ma byt viceradkovy

  TODO: Zajistit, aby to takhle opravdu bylo, i v prubehu logovani do hry.

  TODO: Sjednotit, jak se budou entery psat - asi vzdycky '\n' s tim, ze
    se to pripadne tesne pred odeslanim hromadne preklopi na '\r\n'

  Pozn: Matne si vzpominam, ze pri posilani progressbaru bylo potreba
    rozlisovat mezi sendem, ktery se ma odradkovat, a ktery se odradkovat nema
    - respektive mozna to bylo jeste jinak, ze se zapnul mod "ted posilam
    updaty progressbaru", pri kterem se neodradkovava nic.
*/
/*
  Je to trochu jinak:
  - za promptem nikdy neni newline, takze se prikaz pise rovnou za nej. Promt
    jsou i vsechny prikazy v menu a tak.
  To znamena, ze je treba rozlisovat, jestli se posila prompt, nebo neco
  jinyho.
*/
[snad done]

Zrusit savovani IdProvideru, misto toho k idcku prilepovat boot timestamp.
[done]

Zrusit prvni parametr z IdProvider.generateId()
[done]

TOFIX: Po quitu nebo reconnectu je nejspis nastaveno provazani
  s playerConnection, opakovany quit nezabere (respektive pak vubec nefungujou
  prikazy)
  [done]

TOFIX: qui spusti doQuit() misto doQui()
[Fixed]

---------------------------------------------
---------------------------------------------
---------------------------------------------
---------------------------------------------

Important TODO: Saving request buffer na savovani lastIssuedId
[Done - IdProvider ted vyuziva mnohem vic funkcnosti ze SaveableObjectu,
 vcetne bufferovani save requestu]

---------------------------------------------

TODO: Zrusit pevne idcko worldu. Bude se loadovat ze souboru
world.json, kde je ulozene.
[Done]

---------------------------------------------

TODO: accountName prejmenovat na name, at se savuje na zacatek souboru.
[Done]

---------------------------------------------

TODO: Udelat hack do SaveableObjectu, ze kdyz ma entita property 'name',
  tak se savne jako prvni (jestli to teda pujde).
[done]

---------------------------------------------

GameEntity by mel byt IdContainer<Id>
- tedy container Idcek
[Done - obsahuje IdList]

Staci mi, ze se idcka davaji do hashmapy?
- nestaci, protoze potrebuju pevne poradi
[Done - IdList ma Array idcek]

V cem se lisi:
EntityManager, IdContainer, EntityContainer?
  IdContainer
  /* Mel by se jmenovat asi spis IdableItemsContainer */
  - neni z niceho zdedeny
  - je to template (IdContainer<T extends IdableSaveableObject>)
  - itemy jsou v hashmape
  Umi:
    - pridat item pod existujicim idckem
    - vygenerovat itemu idcko a pod nim ho pridat
    - odebrat item z containeru
    - odpovedet, jestli je item daneho idcka v containeru
    - vratit item podle idcka (pres hashmapu)
    IMPORTANT: IdContainer nedrzi idcka, ale primo itemy!
  EntityManager
  - neni z niceho zdedeny
  - je to template (EntityManager<T extends GameEntity>)
  - vubec si nedrzi idcka ani itemy, drzi si pouze abbrevSeachList a uniqueNames
  Umi:
    - pridat item pod existujicim idckem
    - pridat novy item do Game.entities (tam se mu vygeneruje idcko)
    - checknout, jestli je entita v Game.entities (nikoliv jestli je v manageru)
    - vratit entitu (vezme ji z Game.entities, necheckuje, jestli mu idcko patri - nema jak)
    - odebrat entitu z manageru
  - jestli ma entita unikatni jmeno nebo ne je vlastnost entity, manager ji podle toho zaradi do
    seznamu unikatnich jmen nebo ne
  EntityContainer
  - je zdedeny z predka GameEntity (EntityContainer extends CommandInterpretter)
  - zatim nema nic, ale mel by mit SaveableArray idcek
  - mel by asi umet so same, co EntityManager (ale unikatni jmena ho asi nezajimaji)
[Done - jmenuje se to IdList]

save() a load() by mel automaticky savnout/loadnout i vsechny obsazene entity,
aby se nestalo, ze loadnu container, ale ne to, co je v nem.
[Done]

Zaver: GameEntity by v sobe proste mela mit entity manager
[Done - je to tochu jinak, misto manageru je ted classa IdList, ktera v sobe
 drzi seznam idcek a umi v nem vyhledavat.]

------------------------------------------------------------------------

Ke zvážení: Dávat před string idčko nějakou předponu, třeba e jako entity,
  a jako account?
- teoreticky by se pak dala generovat "spotřební" idčka (třeba timery) s jinou
  předponou zase od začátku
[Zatim na to kaslat]

Nesavovat playerConnectionId
[done]

Load/save entityContainerů
[asi done]

Check, že existují adresáře, do kterých se mám savnout (možná je automaticky
vyrobit, pokud neexistují?).
[done]

-----------------------------------------------------

TODO: Implementovat binarni vyhledavaci pole na hledani abbreviationu.
[nahrubo asi done. Je to hashmapa]

TODO: Pridelat do entity manageru trackovani neunikatnich jmen.
[snad done]

TODO: Z protected metod zrusit predponu 'my', stejne ji vetsinou nepouzivam.
(u dat zustane)
[zruseno i u dat]

------------------------------------------------------

Hodne vyhledove:

[23:49] Huan         : jiste ze muzou vracet. promise.resolve(navratovahodnota)
[23:50] Huan         : a presne tohle streamline resi
[23:50] Huan         : a resi i ty exception

[exceptiony jsou jakz takz poresene tim, ze se odchyti a vyhodi znova, takze
to vypise stack]


===============================================================
Uvahy k prototypovani, skriptovani, hot reloadu, etc.
-------------------------------------------------------

    /*
    // TEST:
    let script = "return 'Changed function!'";
    this.location.getEntity().printContents =
      <() => string>new Function(script);

      - Tohle funguje. Znamena to, ze skript muze byt ulozenej
      jako string a muzu ho v runtime povesit jako metodu na nejaky
      objekt (novou nebo existujici).

      - otazka je, jak udelat wait

      - chybi odolnost proti zacykleni (ale to zas neni tak zasadni, to
      se stava malokdy)

      - neni videt this, musi se predat jako parametr (coz je ale asi ok,
      tak se chovaji i brutusi skripty).

      - nejde volat jine funkce, pouze metody toho, co se preda jako
      parametr (nemam to ozkousene, ale snad jo). Coz je ale asi spravne,
      aspon je to odolne proti zneuziti.

      - musi to byt javascript (nemuze to byt typescript). Dalo by se ale asi
      udelat nejake externi volani typescript compileru
      vol
    */



    Asi by taky šel použít node.js modul 'vm':
    https://nodejs.org/api/vm.html

    - to bohužel pořád funguje jen na úrovni javascriptu...



    Když bych chtěl prototypovat nativní javascriptovou prototype inheritancí
    (jako že bych určitě chtěl), tak by každý brutusí vnum musel odpovídat
    samostatné class. Pak by prostě javascriptový prototyp té classy fungoval
    jako mudový prototyp.
      Editace prototypu v runtime by pak vypadala takhle:
        Mob82003.prototype.maxHitPoints = 20;



  ------------

  Jak na dynamické generování nových typů (prototypů)?

  - Musím to samozřejmě načíst z nějakého souboru v rozumném (tj. JSON) formátu
  - Co všechno dávat do jednoho souboru? Po zónách to asi organizované mít
    nechci... (respektive určitě by mělo jít vypsat, jací mobové jsou použiti
    v dané zóně, ale neměli by se vyrábat mobové (roomy, atd.) přímo do zón).

    Každopádně zatím můžu začít jednou entitou v jednom souboru, pak to kdyžtak
    rozšířím.

Takže:

class PrototypeData
{
  type: string;
    /* Jaky typ se má dynamicky vytvořit */
    - ten by se asi měl generovat automaticky
    ("Mob"/"Obj"/"Room" etc. - nebo možná 'mOrc21') + jméno + případně číslo?
    - je podstatné si uvědomit, že prototypy se nedávají do zón a že od každého
    prototypu může existovat víc instancí (i od prototypu roomy). Takže když
    budu chtít ve skriptu projít 10 room v zóně, tak budu ty roomy odkazovat
    přes jejich stringová idčka (nebo nějaký logický dns-like ekvivalent),
    nikoliv přes jméno prototypu.
    - na druhou stranu loadovat budu z prototypu, takže 'load mOrc21' se
    používat bude

  ancestor: string;
    /* Z čeho se má zdědit */

  data: Array<any>;
    /* Jaké property a s jakými hodnotami se mají nasetovat prototypu
      (tedy do Type.prototype) */

  scripts: Array<Script>;
    /* kusy kodu, ze kterych se maji vyrobit metody a povesit na prototyp */
}

class ScriptData
{
  methodName: string;
    /* Pod jakym jmenem se ma funkce povesit na prototyp */

  code: string;
    /* Tohle není přímo tělo funkce. Při navěšování na prototyp se ještě
       obalí nastavením sandboxu a voláním s timeoutem. */
}
    


Pozn (Globální skriptové funkce):
  Pokud budu chtít mít nějaké skriptové fce, tak je asi nahážu do nějakého
  objektu, který automaticky přihodím do každého sandboxu (tedy do každého
  nového prototypového typu, protože sandbox bude nejspíš vždycky celá
  entita).
  - to by znamenalo, že by se volaly přes nějakou dot notation, nejspíš
  se.doSomething(); // 'se' jako ScriptEngine
  (nebo možná utils.doSomething()?)
- on možná sandbox objekt funguje jako 'global', takže půjdou funkce volat
  přímo. Chce to vyzkoušet.


TODO: pořešit 2 death scripty na mobovi (obecně víc skriptů na stejném triggeru
  jedné entity)


===============================================================
Bitmapy
-------------------------------------------------------

IDEA: Zkombinovat moznost deklarovat flagy v kodu a deklarovat je dynamicky.
- Když je flaga v kódu i v soboru (a sedí value), tak to tak
  zůstane. Když je v kódu a není v souboru, tak se dosavuje do souboru.
  (Tj. vždycky budou všechny flag values v souboru, včetně těch deklarovaných
   v kódu, ale ne všechny flagy musí být deklarované v kódu).
- když to při loadování hry nesedí (v kódu je stejná flaga jako v souboru ale
  s jinou hodnotou), tak to sprostě zařve FATAL_ASSERTEM

Jinak řečeno (a i jianak implementováno): V kódu budou deklarovány jen
  symbolické konstanty (bez hodnoty), hodnota bude jen v souboru (repsketive
  v hashmapě).

/*
 Jinak: FlagValue nepotřebuju, tu si vyrobím interně při indexaci.
   (a vlastně ani to ne, budu přece přistupovat na Flags object konkrétního
   typu a ten mi řekne, že value "PLAYER_DISCONNECTED" v RoomFlags není).

 - možná by stálo za to vyžadovat, aby všechny flagy mělo globálně unikátní
   názvy (možná formou prefixů).
   (Prefixy by fungovaly tak, ze každý FlagData by si svůj prefix pamatoval
   a kontroloval by, že jím nově vytvářená flaga začíná (neměl by se připojovat
   automaticky, jen kontrolovat)).
*/


- flagy by měly jít přidávat za běhu, což znamená, že se musí umět savovat
  na disk (do kódu se za běhu zapisovat nedá).
  (Naprd je, že pak nebude napovídat visualko...)

Hodnota (konkrétní flaga) by měla být objekt, který v sobě má:
- vlastní číslo flagy
- jméno typu
(Díky tomu půjde za běhu kontrolovat, že RoomFlags indexuju opravdu room flagou
 a ne třeba PLR flagou se stejným číslem).


class RoomFlags extends Flags
{
  public static get ROOM_HOT() { return ROOM_HOT; };

  /*
     Not all existing room flags are necessarily defined here.
     Some of them may be declared dynamically - in that case the flag
     exists in files but doesn't have symbolic name here.
       Feel free to add symbolic names for such flags here if you want
     to use from the code.
     
     Note also that only the name of the flag is declared here, not its
     integer value. The value is still saved to file.

     You can also add a new flag here that doesn't yet exist in the file.
     It will be added there automatically on the next reboot (when the
     game loads itself from file) and an unused numeric value will
     automatically be assigned to it.

     If you really want to delete a flag (maybe because you addes some by
     mistake or it becomes obsolete), the only way to do it is to edit
     the file with respective FlagData (///TODO: cesta k souboru).
   */
}

--------------------

Automatický update flaglistů:
------------------------------

- FlagsDataManager má flagu this.loaded, díky které lze assertovat,
  když se někdo pokusí hrabat na FlagData před tím, než jsou poprvé
  loadnuta ze souboru.

- instance Flags objektů (třeba new CharacterFlags()) mají referenci
  na příslušný FlagsData object inicializovaný na false.
  Až když ho někdo bude chtít poprvé použít, tak se na FlagsDataManageru
  checkne, že takový FlagsData objekt existuje (a že už je loadnuto).
  Pokud ne, tak ho vytvoří a savne.
  - tohle se pochopitelně provede jen jednou za boot, proože při příštím
    accessu už existovat bude.

- Když si konkrétní instance Flags objektu žádá o referenci na svůj FlagsData
  object, tak se taky provede update seznamu flag podle statických proměnných
  na Flags objektu, které začínají příslušným prefixem.
  - FlagsData object má flagu this.flagsAutoUpdated, která zaručí, že se tohle
    provede jen jedno, i když instancí příslušného FlagsObjectu bude více
    (každá z nich si při prvním použití vyžádá referenci na svůj FlagsData
    object)


===============================================================
Multiple characters and connections per account
------------------------------------------------

0) Exit BrutusNext
1) Enter game as Rahman
nebo
1) Reconnect as Rahman
// Pokud už char ve hře je

2) Create new character.
3) Delete a character.


  // Player can be connected to her account multiple times - for example
  // When immortal wants to play her mortal character on one session and
  // here immortal on another.
  /* Pozn: Mortalove by mohli mit omezeni na jedinou connection soucasne. */
  pendingConnections = new Array<PlayerConnection>();


Reconnect:
- Zahodi se existujici connection navazana na character (pokud je jeste ziva)
  a misto ni se setne pending connection, od ktere prisel request.


===============================================================

Scripting
----------

Každý skript je deklarace funkce
- jméno skriptu je totožné se jménem funkce (obalovací kód musí umět vytáhnout
  ze sandbox objectu proměnnou s danou funkcí - což bude dělat kód, který se
  přilepí na konec skriptu. A ten samozřejmě musí vědět, jak se má ta fce
  jmenovat).
- díky tomu, že skript deklaruje funkci, je možné v ní použít i return.
- script editor by při editaci nového scriptu měl automaticky vložit hlavičku
  funkce + prázdné tělo. Může to být šedivé, tj. uvnitř editace skriptu edituju
  jen obsah a když chci změnit jméno fce nebo parametry, tak musím vyskočit
  ven (nebo si to prostě naparsuju, ono to zas tak těžké nebude - prostě první
  vnější {})

'stopscript'
- Už v zásadě vím jak na to: Nechám doběhnout timer a místo resolve() zavolám
  reject(). Tím vyhodím výjimku, kterou pak následně odchytím (jako všechny
  výjimky z async funkcí přímo v BrutusNext.ts, akorát musím odflitrovat,
  že jde o stopscript exception - nejspíš podle err.message).

  Otázka je, jak v kódu, kterej se zavolá po skončení timeoutu, zjistit, že
  patří ke skriptu, kterej někdo stopnul.
  - nestačí na to jméno funkce, protože mezi tím se ten skript mohl pustit
    znova a kdyby novému spuštění dřív doběhnul timeout, tak bych umřel to nové
    místo starého. Takže musím přesně identifikovat každé jednotlivé spuštění
    timeoutu (možná přes ten timeout id?)

Související problém: Rušení skriptů běžících na entitě, kterou někdo zabil.
  - když bych ty skripty nestopnul, tak budou sahat na neexistující this
  - to znamená, že údaje o spuštěných skriptech (do kterých se bude
    poznamenávat, které skripty se mají stopnout, nemůžou bejt přímo na entitě.
    Po smazání entity bude timeout stále čekat.)
    - teoreticky by to mohlo být na classe (jako static proměnná). To ostatně
      asi i dává smysl, protože skripty jsou vlastnost prototypu (můžu v zásadě
      přiřadit na instanci nějakej skript, ale definovat se budou na prototypu.
      Takže budu psát něco jako 'stopscript PrototypeRoom::onLoad()', což by
      mělo stopnout všechny běžící instance tohohle kusu kódu, včetně těch,
      které jsem připojil na nějakou jinou entitu než odvozenou
      z PrototypeRoom.)
      - ok, takže na classe PrototypeRoom budu mít něco jako 'runningScripts',
        což bude hashmapa indexovaná jmény skriptových fcí (třeba 'onLoad').
        A pro každou běžící instanci tohohle skriptu tam bude záznam.
        (díky tomu půjde vypisovat i statistiky, kolik instancí nějakého
        skriptu mi běží, na jakých běží entitách, atd.)

  Ok. Otázka teda je, jak do PrototypeRoom.runningScripts přidám info o právě
  spuštěném skriptu.
  - jediné možné místo je asi kód funkce delay(). A musím do ní nějak
    propašovat informaci Prototype::scriptName - s tím, že Prorotype nemusí
    nutně být this.prototype, protože metodu SystemRoom.doCosi() můžu klidně
    pustit i na nějaké jiné entitě (s jiným prorotypem).

  Jak to udělat?
  - když buildím skript, tak vytvořím funkci. Může ta funkce mít vlastní
    funkci delay? (Která zavolá funkci performDelay() s parametry 'Prototype'
    a 'ScriptName'?).

/*
TOHLE NEBUDU IMPLEMENTOVAT
- nepůjde attachovat/detachovat skripty na instance (entity), to je antipattern.

Stopování běžících skriptů
- ideálně bych měl do běžícího skriptu propašovat odkaz na 'script' object
  a odkaz na internalFunction(). Když bude při doběhnutí timeru
  internalFunction uvnitř funkce delay() jiná než ve script.internalFunction(),
  tak to znamená, že se má skript stonout.
- alternativně můžu předávat compilationCounter a incrementovat ho na 'scriptu'
  (když má delay() menší compilationCounter, tak to znamená, že se má stopnout)
*/
-----------------------------------------------------

Přejmenování skriptu
- Pokud je script jen na prototypu, tak to je relativně jednoduché, na
  prototype se ze Scriptu dostanu (a prostě assignu undefined místo původního
  jména a novou scriptFunction na nové jméno)

/*
TOHLE NEBUDU IMPLEMENTOVAT
- nepůjde attachovat/detachovat skripty na instance (entity), to je antipattern.

- Pokud jsem script attachnul na entitu, tak to bude těžší.
  IDEA: Při attachnutí skriptu na entitu se nesetne rovnou scriptFunction,
  ale nejdřív nově vytvořená interFunction, která bude vědět, (přes jaké jméno
  byla zavolána. Ta se následně může podívat, jestli skript s takovým jménem
  ještě existuje (jak?))...
*/

---------------------------

IDEA:
Deklarovat fci delay() uvnitr skriptu místo uvnitř compile().
- díky tomu uvidí na 'me' predane do skriptu jako parametr
Nevyhoda: Vsechny skriptove fce budou muset mit explicitni parametr 'me'.


IDEA:
- 'script' můžu pořád dostat do delay() přes closure metody compile(),
  jen musí přidat ještě jedno volání, které ji zavolá.

  (tj. delay() bude deklarovaný ve skriptu a uvidí na 'me' a na funkci
  interDelay, která je deklarovaná v closure metody compile() a nastavená
  jako parametr sandboxu - což je problém, protože sandbox je jen jeden
  pro všechny skripty....
  - může být interDelay() deklarovaný v closure scriptFunction()?
    - to mi asi k ničemu nepomůže. Leda že by...

  - může být interDelay() předaný jako parametr do skriptové fce? Asi může...


  IDEA: Script.internalFunction prejmenovat na Script.run


======================================================

  Úvahy nad idčky a entitami
  ---------------------------

  - IdableObject přejmenovat na IdableEntity (nebo jen Entity)
    (protože idčka mají funkci getEntity, tak ať to dává smysl)
    (pořád bude rozdíl mezi Entity a GameEntity)

  - IdableObjectContainer přejmenovat na EntityContainer

  - V celé aplikaci mít jen jeden Entity Container
    (tzn. budou v něm accounty, game entity, atd.)

  - Sloučit IdProvider s EntityContainerem (nejspíš ho dát do entityContaineru)


Validita idček
  Když idčko loaduju z disku
  - checknu, jestli už není zaregistrované v IdProvideru
    - pokud ano, vezmu si referenci (a už má validitu zjištěnou)
    - pokud ne, přidám ho do IdProvideru - a asi bych měl ověřit validitu
      (a nastavit ji do interní proměnné)

  Hmm, validita může znamenat různé věci
  - valid entita, ale není loadnutá
  - smazaná entita

  public status = Entity.STATUS.UNKNOWN;
  
  public static STATUS =
  {
    // Initial value - we don't know yet.
    UNKNOWN:                  "UNKNOWN",
    // Entity is valid and loaded.
    VALID:                    "VALID",
    // Entity is valid (not deleted) and loaded from disk.
    NOT_LOADED:               "NOT_LOADED",
    // Entity has been deleted, you should not access it anymore.
    DELETED:                  "NOT_LOADED"
  }

  // internalReference jde zcela nezavisle. Entita muze byt loadnuta
  // a validni a pritom internalReference null
  // - nebo ne?
  //   Co mi brani updatnout internalReference hned?

  TODO: Zrušit classu EntityId
  TODO Id.getEntity<T>() bude generic a bude dynamicky přetypovávat
    na requestnutý typ T.


=======================================================================
Úvahy o idčkách, weakmapách, atd...
=======================================================================


Počáteční stav
---------------

IdProvider
"a-skh2swe" : id->zlyMob

Zuzka
 id->zlyMob




delete zlyMob
--------------

id.entity = null;	// entity se smaže z paměti
id.entityDeleted = true;

/* ----------- */

aktuální IdProvider:
"a-skh2swe" : id->zlyMob

Zuzka
 id->zlyMob

Potřebuju vědět, že:
- můžu smazat stringový klíč
- můžu smazat id


stringKey můžu smazat až ve chvíli, kdy zmizí poslední reference na idčko
- protože do té doby potřebuju být schopen dohledat idčko podle jeho stringKey


================================================

Idea: Zrušit class Id, používat přímé reference

- když SaveableObject narazí na Entitu, tak zavolá entity.saveReference(), což vytvoří
  podobný záznam, jaký teď má idčko.

- při loadování se z tohohle záznamu vezme stringId a checkne se, jestli je odpovídající
  entita loadnutá. Když ne, tak se reference nastaví na null (nebo místo toho na Id object?).

- při pokusu dereferencovat odkazovanou entitu se znova zkusí najít entita podle stringId
  (respektive byla by to možnost. "Už je online?" "A teď?")

No jo, jenže...
  Kam se savne to stringId, když bude reference null? To by se musela automaticky vytvořit
  nová promměná ve stylu "jméno_proměnné" + "stringId" a do ní by se hodilo to string idčko...
  - a nebo se tam místo entity hodí ten object Id a dereferencování jeho metod bude holt
    crashovat... (dereference null by crashnula taky)

Proč přece jen používat idčka?

- protože o tom, že je problém, se dozvím už ve chvíli, kdy použiju
  id.getEntity()


- problém je se skriptama, protože tam si dám do proměnné entitu a pak
  dám wait... a entitu může mezi tím někdo smazat.

Proč raději používat přímé reference?
- protože když nenapíšu if (id.getEnity() !== null) ..., tak mi to spadne
  při pokusu na entitě cokoliv zavolat
Když místo toho neoifuju referenci, tak mi na ní metoda zavolat půjde - sice
  se bude volat na invalid entitě, ale nespadne na tom celá hra.
- zato můžu do nativních metod entit psát checky typu:
  if (!this.valid)
  {
    ERROR(message);
    return;
  }
  Takže se dozvím, že se snažím manipulovat se smazanou entitou (a přitom to
  nic neudělá a neshodí to hru).




================================================

1. Dejme tomu, že dokážu checknout, jestli je entita s daným idčkem savnutá
   na disku.
   - Jak na to?
     - musím umět získat fullSavePath od každé entity, ideálně bez toho,
       aby ta entita musela existovat (static metoda? Jenže jak zavolám static
       metodu, když nemám entitu? Přes dynamicClasses?
       - jo, to by asi šlo).



2. Při smazání entity:
   - nastaví se jí flaga deleted
   - smaže se z disku
   - smaže se záznam z idProvideru

Dokud je záznam v idProvideru, tak určitě existuje alespoň jedna reference
na entitu. Tzn. nemusí být reference nikde jinde.

IMPORTANT: V metodě Entity.save() zkontrolovat flagu deleted.
  - takže se smazaná entita nesavne.

Co se stane, když si za běhu vezmu referenci na entitu a někdo tu entitu smaže?
- Entita pořád existuje v paměti (já se na ni odkazuju), ale má flagu deleted.
- Už není záznam v idProvideru
  - když se teď někdo zeptá idProvideru, jestli je entita smazaná, dozví se, že
    ano.
  - když se loadne někdo s referencí na entitu:
    - Zeptá se idProvideru a dozví se, že záznam nemá.
    - Checkne, jestli existuje save. Pokud ne, znamená to, že je entita
      smazaná.


Úvaha bokem: Hráčské postavy a unikátní jména
- hráčské postavy se nemažou (tj. delete nesmaže záznam z disku, pouze nastaví
  flagu deleted), ale může se teoreticky smazat jméno.
- přitom bych ale asi potřeboval možnost zjistit čistě dotazem na existenci
  souboru, jestli je entita smazaná. To nejspíš znamená, savovat hráčský char
  na dvě místa - pod stringIdčkem a pod unikátnímJménem.



Struktura dat:
---------------

  ./data
       /Account
         1-imt2xk99.json
       /Character
         4-imt2xk99.json
     /entities
       /Account
         6-imt2xk99.json
       /World
       /Room
       /Character
     /prototypes
       /World
       /Room
       /Character
          7-imt2xk99.json
          /Orc
            8-imt2xk99.json
     /unique_names
       /*
         Pro každé unikátní jméno jeden prázdný soubor. Podle jejich
         existence se zjišťuje, jestli je jméno volné.
         (teoreticky tu mohou být podadresáře, pokud bych chtěl mít víc
         nezávislých kategorií unikátních jmen)
       */
       Zuzka
       Rahman

- hmm, asi bych chtěl, aby se všechno, co patří k Accountu, savovalo
  do /Accoounts/Rahman, včetně všech charů na accountu, lodí, základen, atd.
  - i když je to otázka, dost značně to všechno zkomplikuje.
  - navíc počítám s tím, že "hráčovy" assety mohou žít svým vlastním životem,
    takže pak nejsou až tak úplně 100% hráčovy...
    (což znamená, že by se u některých entit měnilo, komu patří, takže by se
     pak savovaly na různá místa na disku... Asi na to spíš kašlat a savovat
     všechny entity stejně.)

PS: Smazání entity, která má být obnovitelná, ji prostě přejmenuje na
.json.deleted, není třeba ji přesouvat do jiného adresáře.

---------------------------
Co by bylo potřeba, aby se daly savovat playerovy entity do /Acccounts?

- každý savnutý odkaz na entitu by si musel pamatovat, jakému Characteru
  a jakému accountu to patří.
  - co když hráčova věc zůstane ve hře a vezme si ji někdo jiný?
    - měl by ji vůbec mít savnutou hráč, když je stále ve hře?
      Očividně se to může stát, když hráč napíše 'save' a následně věc někomu
      dá. V ten moment je má savnutou u sebe a dotyčný si ji může savnout taky.
      Tím se nevynutí save prvního hráče, takže ji nyní mají savnutou oba,
      pokud dejme tomu crashne mud.
    - když by každý z nich měl savnuté jen idčko, tak se pořád může stát, že si
      to idčko savnou oba. Pak se při loadu stane co? Budou mít oba dva
      referenci na stejný item?
    - když se budou s hráčem savovat jen reference, tak to půjde pořešit přes
      to, že item samotný má u sebe savnutou 'location'. Když při loadu
      location entity nebude odpovídat tomu, do čeho se loaduje, tak se může
      zase zahodit - znamená to, že o ni hráč po svém savu přišel a savnul ji
      někdo jiný.


[09:51] Rahman       : <64> Zacinam si cim dal vic klonit k tomu, nesavovat
                            itemy do player filu ale do /Objects
[09:51] Rahman       : <64> Hlavnim duvodem je obrana proti duplikovani itemu
[09:52] Rahman       : <64> Kdyz jeden player napise 'save', da item druhemu
                            playerovi, ten napise 'save' a nasledne spadne mud
                            bez savu, tak je ten item savnuty ve dvou pfilech
[09:52] Rahman       : <64> a kazdy z nich ma jako ownera jineho playera
[09:54] Rahman       : <64> zatimco kdyz bude u playera savnute jen stringove
                            idcko itemu a item bude jinde, tak timhle vznikne
                            stav, kdy item je savnuty dvakrat na stejne misto
                            a dva ruzni playeri maji na nej odkaz (tvari se, ze
                            je item jejich)
[09:55] Rahman       : <64> jenze item ma u sebe savnutou 'location', takze
                            kdyz se logne ten prvni player, tak mu muzu rict
                            'sorry, tenhle item uz ma nekdo jiny'
[09:56] Rahman       : <64> samozrejme to znamena, ze bude peklo rucne
                            vytahnout playera ze zalohy, protoze jeho itemy
                            budou rozstrkane vsude mozne
[09:56] Rahman       : <64> na druhou stranu to pujde celkem jednoduse
                            zautomatizovat, takze ho budes moct restornout za
                            behu primo ze hry
[09:57] Rahman       : <64> proste si vytahnes prislusnou verzi z gitu do
                            jineho adresare (protoze v gitu bude ulne vsechno)
                            a forcnes playera, at se loadne ze /zaloha/data
                            misto z /mud/data
[09:58] Rahman       : <64> a pri te prilezitosti to muze item po itemu
                            kontrolovat, jestli nahodou neexistuji v ostre
                            verzi a nema je nekdo jiny, takze se zabrani
                            duplicitam


Ad unique names
- možná bude lepší držet je v paměti, ono jich zas až tak strašně moc
  nebude. Takže asi vytvořit nějaký UniqueNamesManager.
  - v něm budou kategorie accounts a characters

Class inheritance tree
-----------------

NamedClass
- AttributableClass
  - SaveableObject
    - AutoSaveableObject
      - Entity
        - NamedEntity
          - Account
          - CommandInterpretter
            - ContainerEntity
              - GameEntity
                - Sector
                  - Area
                - Dimension
                - Realm
                - Room
                - World
                - Character

Ok, co jsou kořeny adresářového stromu?
- Account (respektive NamedEntity) (protože ./data/entities/Account)
- GameEnity (protože ./data/entities/Realm apod.)

Tzn při volání getSavePath():
- NamedEntity by měla vracet ./data/entities
- GameEntity by měla vracet ./data/entities
- Entity by asi taky měla vracet ./data/entities
- Account by měl vracet className + super.getSavePath()
  // A navíc to nebude moct bejt super. protože se to nebude volat na instanci,
  // ale na prototype chainu.



================================================

IDEA: Rozlišovat:
  - Adresář, kam se savne celá hra se vším všudy před bootem
    (a po bootu se z něj zase celá se vším všudy loadne)
  - A adresář, kam se savují player data v průběhu bootu...

Asi spíš jinak: Mít dvě gitové repository. Do jedné se budou
  commitovat změny v kódu (samozřejmě i s aktuálním stavem dat),
  do druhé zálohy dat (samozřejmě i s aktuálním stavem kódu.
- restore dat ze zálohy se bude provádět z běžícího mudu, prostě se ty
  entity natáhnou z /backup/data místo z /mud/data
Důvodem pro dvě repository je, že nechci, aby do programátorské nespamovaly
commity se zálohama...
(Možná to takhle jednoduše nepůjde, uvidíme...)


================================================

Undelete
---------

Problém: Někdo si schová referenci na char, který smažu.
  - v ten moment se maže záznam z hashmapy (stringId->entita).
  Následně provedu undelete (ve stejném bootu). Znova loaduju entitu
  z disku a měl bych ji napojit na už existující, protože si ji někdo
  stále pamatuje - jenže na tu už se nemám jak dostat, protože už není
  záznam v hasmapě.

Řešení: undeletnutelné entity nemazat z hashmapy.
  - Týkat se to bude asi jen player charů (lodí, designů a tak)

Problém: Někdo qitne s charem a pak se zas naconnectí
  - to je vlastně stejnej problém jako s tím undeletem: Nemůžu vyhodit
  záznam z hashmapy, protože bych se pak nedokázal napojit na instanci,
  na kterou si někdo stále drží referenci.

  Tzn. quitnutý char bude zůstávat v paměti
  - teoreticky na něj můžu držet jen weak link (dát ho do WeakMapy),
    takže se pak z paměti vyhodí aspoň entita - jo, to zní hezky, ale jak
    to udělat? Já potřebuju držet tu referenci na entitu

================================================

Použití node-weak:

Když vyrábím novou entitu, tak si do hashmapy dám strong referenci a současně
weak referenci. Vrátím weak referenci, která se bude přiřazovat ve zbytku kódu.

Když budu chtít entitu zahodit z paměti, tak:
- do strong reference v hasmapě zapíšu null
  - v ten moment můžu dokonce rovnou checknout, jestli weakRef.isDead() a pokud
    ano, tak zahodit celý záznam v hashmapě (protože nikdo jiný nemá referenci).
    Pokud není dead, tak si nechám weakRef, protože mě možná časem někdo bude
    chtít oživit.

- využití callbacku:
    Když se mi zavolá callback, tak můžu vyhodit celý záznam z hashmapy,
    protože to znamená, že nikdo už nedrží referenci na entitu.
    - když se mi někdo relogne, undeletne, nebo tak, tak se prostě dá nový
      záznam do hasmapy

================================================

Využití proxy:
  - Entita je proxy, která defaultně jen předává přístupy zapouzdřené entitě.
  - Když na Entitu zavolám delete, tak se v proxy změní metody get() a set()
    a místo předávání vnitřní entitě budou reportovat přístup na smazanou
    entitu.

- Teoreticky takhle půjde odchytávat i pokus o přístup na neexistující property
  (takže program nespadne - respektive nespadne na volání neexistující metody
   entity, ale může pořád spadnout, když přistoupím na to, co mi ta
   neexistující metoda "vrátí").

ÚVAHA: Využití Proxy k ošetřetní relogu bez nutnosti počítat reference:

    Lognu se

    Někdo si na mě vezme referenci

    Odlognu (save)

    Dotyčný zkusí na referenci přistoupit
    - Proxy checkne hashmapu a zakáže mu to

    (load )Znova se lognu
    - Vytvoří se nový objekt. Dotyčný má stále referenci na ten smazaný

    Dotyčný zkusí na referenci přistoupit
    - Proxy checkne hashmapu, zjistí, že objekt byl znovu vytvořený, takže
      přesměruje interní referenci na nový objekt
      (pro dotyčného se to tváří, jako kdyby objekt stále žil)




================================================

TODO:

- Domyslet novou strukturu dat
- Přejít na novou strukturu dat

- Líp vymyslet dynamicClasses
- Implementovat to

- otestovat node-weak


- Přejít z Idček na reference na entity


- otestovat Proxy


================================================

Game.createWorld()
{
- chci nové idčko

  // Tohle je asi ok
  this.world = SaveableObject.createInstance
    ({ className: param.prototype, typeCast: World });
}

Game.load()
{
  - potřebuju idčko loadnout ze souboru
    (world má unikátní save name, takze nepotrebuju znat id, abych vedel,
    z jakeho souboru se mam loadnout)

  /// Tady by melo byt: createInvalidReference();
  /// PS: Na to nemusim ani znat typ - respektive ano, musim ho zapsat do
  ///    handleru.
  this.world = SaveableObject.createInstance
    ({ className: 'BrutusWorld', typeCast: World });

  // Load current state of world from file.
  await this.world.load();
}

SaveableObject.loadFromJson()
{
  - tady se loaduje invalid reference, to uz mam napsane.
    (a dělá to EntityManager - to je důležité)
}

Tzn. asi bych nikde neměl sám volat SaveableObject.createInstance(),
měl bych volat EntityManager.createInvalidReference()
- proč rovnou invalid? Však klidně může být i valid, když zadám platné
  idčko a entita už bude v EntityManageru...
nebo EntityManager.loadReferenceFromJsonObject()
- to už se děje, ze SaveableObjectu
nebo EntityManager.createEntity()
- to ještě neexistuje. Místo toho tam je metoda add(), která přidá už
  existující referenci. Mělo by to asi být tak, že add() bude private
  a zavolá se automaticky.

[ok, už by snad měl jít zavolat load() na invalid referenci (ostatně i na
 valid) a mělo by to entitu loadnout a přidat do EntityManageru]

 IMPORTANT:
 - bude existovat jen jedna funkce na vyrábění nových entit (tedy s novým
   idčkem), a to EntityManager.createEntity().
   - nikde jinde nemusím vyrábění nového idčka řešit.

===============================================================================
===============================================================================

Ještě jednou proxies and references
------------------------------------

Jedna mapa (weak?):
- to nejde, protože do weak mapy se dá dát jen object
Entity ----------------> Proxy 

Proxy  --------------->  Entity

- Reference, kterou dávám k dispozici
  - ta ukazuje na proxy, za kterou je další proxy reference, kterou nedávám
    k dispozici
    - ta ukazuje na entitu

Id - potřebuju najít unikátní proxy

- Nic, asi to nemá řešení.

Plyne z toho:
--------------
- class EntityList nesmí interně držet přímo reference, protože by se pak
mohlo stát, že tam nějaká entita bude dvakrát (dvě různé reference na proxy
budou ukazovat na stejnou entitu).
  To samé platí pro všechny ostantní classy, které by chtěly držet reference
  na entity (ContainerEntity, Admins, atd.)

- ve skriptu se nebude smět porovnávat reference na entitu, tj. něco
  ve stylu if (actor === ch)...
Tohle je dost průšvih, budou z toho určitě vznikat chyby, které se budou
extrémně špatně hledat...
  Jediná útěcha může být, že časem do Javascriptu přibude nějaká featura, která
  to celé umožní udělat líp:

  [16:56] Rahman       : potreboval bych bud moznost predefinovat porovnavaci
                        operatory (abych mohl rict, ze jsou si dve entity
                        rovne, i kdyz maji ruznou referenci),
  [16:57] Rahman       : nebo mit moznost pouzivat weak reference (abych mohl
                        vratit existujici referenci a negenerovalo to
                        memoryleaky),
  [16:57] Rahman       : nebo mit moznost predefinovat assignment operator,
                        abych mohl pocitat, kolik referenci existuje.

===============================================================================

Ještě by šlo zvážit, že by se invalid entity reference nevalidovaly
automaticky. Tzn. že jakýkoliv přístup na invlid entity by byl chybný,
a to i v případě, že někdo jiný mezi tím znovu instancioval entitu stejného
idčka.
- nevyřeší to problém s porovnáním, protože to nemám jak trapnout.
  Pořád mi to řekne, že mám jinou entitu.
- nevyřeší to asi ani idlisty, protože mrtvá entita se z nich automaticky
  nevyhodí.
  - entita by si musela pamatovat, ve kterých listech je uložena (a stejně by
    to nevyřešilo proměnné s referencí.
- na druhou stranu to pomůže najít chyby, které by automatická revalidace
  reference zamaskovala.

===============================================================================

IDEA: Admin rights by se ještě daly udělat přes WeakMapu - savovat je
  jako info mimo objekt. Asi to ale není moc praktické